<!--
    The breve Simulation Environment documentation
    Copyright (C) 2003 Jonathan Klein
-->

<chapter id="graphics-and-sound">
<title>Graphics and Sound</title>
<para>
<indexterm><primary>graphics</primary></indexterm>
This chapter discusses customizing graphics and sound in a breve simulation.
</para>
<para>
The first section, Lighting (<xref linkend="lighting">) shows how to enable 
and use lighting.  (<xref linkend="shadows-and-relections">) 
shows how shadows and reflections can be added to simulated objects.  
</para>
<para>
(<xref linkend="loading-images">) shows how to load images into a simulation.  Once
an object has been loaded into a simulation, it can be used to display an agent as 
an image (<xref linkend="bitmapping">), to texture an object (<xref linkend="texturing">) 
or to display an object as a translucent "lightmap" (<xref linkend="lightmapping">).  
In addition, the image data may be accessed and manipulated, as described in (<xref linkend="imageclass">).
</para>
<para>
Users can also create custom drawings in the world which are not associated with simulated
objects.  This feature is described in (<xref linkend="drawing">).
</para>
<para>
Finally, (<xref linkend="sounds">) describes how sound files can be loaded and played as 
part of a breve simulation.
</para>

<sect1 id="lighting">
<title>Lighting</title>
<indexterm><primary>lighting</primary></indexterm>
<indexterm><primary>enable-lighting method</primary></indexterm>
<indexterm><primary>disable-lighting method</primary></indexterm>
<indexterm><primary>move-light method</primary></indexterm>

<para>Lighting can be used to aid in the visualization of a
simulation. By default, lighting is enabled for physical
simulations (those which use a controller subclassed from 
<ulink url="../classes/PhysicalControl.html">
PhysicalControl.tz</ulink>) and disabled all other
simulations.</para>
<para>To enable lighting or disable lighting, use the 
<ulink url="../classes/Control.html">Control.tz</ulink> methods 
<ulink url="../classes/Control.html#enable-lighting">
enable-lighting</ulink> and 
<ulink url="../classes/Control.html#disable-lighting">
disable-lighting</ulink>. To move the location of the light, use
the method 
<ulink url="../classes/Control.html#move-light">
move-light</ulink>. The following example shows how lighting could
be enabled and setup as part of the controller object's init
method:</para>
<para>
<screen>
	self enable-lighting. 
	self move-light to (0, 50, 0).
</screen>
</para>
</sect1>
<sect1 id="shadows-and-relections">
<title>Shadows and Reflections</title>
<para>
<indexterm><primary>shadows</primary></indexterm>
<indexterm><primary>reflections</primary></indexterm>
breve's visualization engine offers support for both shadows and reflections.
These graphical effects not only make a simulation look better, they also
enhance the benefits of visualization as an aid to understanding and discovery
of simulation behaviors.
</para>
<para>
Reflections and shadows are quite simple to set up.  For reflections, there 
is a single technique; for shadows, there are two techniques to choose from.
These techniques are outlined below.
</para>

<sect2 id="reflections">
<title>Setting Up Reflections</title>
<para>
<indexterm><primary>enable-reflections (method)</primary></indexterm>
<indexterm><primary>disable-reflections (method)</primary></indexterm>
The first step to setting up shadows or reflections is to set
up lighting as described in the previous section (<xref linkend="lighting">). 
The next step is to pick the "floor" object to "catch" the reflections.  The 
reflection-catching object must be a stationary object with one face pointing 
upwards on the Y-plane. Any unrotated rectangular solid should work just fine.
You can specify the ground object using the 
<ulink url="../classes/Stationary.html">Stationary.tz</ulink> method 
<ulink url="../classes/Stationary.html#catch-shadows">
catch-shadows</ulink>.  In spite of its name, this method is used to specify
the ground floor for both shadows <emphasis>and</emphasis> reflections.
</para>
<para>The final step in displaying reflections is to enable them, 
using the <ulink url="../classes/Control.html">Control.tz</ulink> method
<ulink url="../classes/Control.html#enable-reflections">
enable-reflections</ulink>.
</para>
<para>
Reflections can be turned off later using the 
<ulink url="../classes/Control.html">Control.tz</ulink> method
<ulink url="../classes/Control.html#disable-reflections">
disable-reflections</ulink>.</para>
</sect2>

<sect2 id="shadows">
<title>Simple Shadows</title>
<para>
<indexterm><primary>enable-shadows (method)</primary></indexterm>
<indexterm><primary>disable-shadows (method)</primary></indexterm>
The first variety of shadows available in breve renders shadows onto a 
single ground plane, just as reflections are.  This technique allows all
objects, including bitmapped objects, to cast shadows onto the ground 
plane.
</para>
<para>
To setup these simple shadows, you'll need to set up the lighting and
"shadow-catcher" plane as described in the previous section 
(<xref linkend="reflections">).  Once the lighting and ground plane are
configured, simple shadows can be enabled using the 
<ulink url="../classes/Control.html">Control.tz</ulink> method
<ulink url="../classes/Control.html#enable-shadows">enable-shadows</ulink>,
and later disabled using 
<ulink url="../classes/Control.html#disable-shadows">disable-shadows</ulink>.
</para>
</sect2>

<sect2 id="shadow-volumes">
<title>Better Shadows With Shadow Volumes</title>
<para>
<indexterm><primary>shadow volumes</primary></indexterm>
<indexterm><primary>enable-shadow-volumes (method)</primary></indexterm>
<indexterm><primary>disable-shadow-volumes (method)</primary></indexterm>
<firstterm>Shadow volumes</firstterm> offer an improvement over the 
simple shadows described above.  Shadow volumes can be used to cast
shadows over <emphasis>any</emphasis> object, not just flat planes.  In 
addition, shadow volumes will cast shadows over <emphasis>all</emphasis>
objects in the simulation, not only on a single "ground" object.  This means
that with shadow volumes, all objects cast shadows on all other objects.
</para>
<para>
Because shadow volumes can be drawn onto non-flat objects, shadow volumes 
are the only way to draw shadow onto terrains 
(<xref linkend="terrains">)&mdash;simple shadows will not work.
</para>
<para>
There are, of course, a few disadvantages with this approach.  One problem
is that shadow volumes cannot correctly draw shadows for bitmapped objects.
Bitmapped objects will get shadowed as spheres when using shadow volumes.
Another issue is that shadow volumes are often slower than simple shadows.
The exact performance hit depends on the number and complexity of objects
in your simulation, but is often negligible.  The final disadvantage of
shadow volumes is that they are more prone to visual artifacts than 
simple shadows.
</para>
<para>
In spite of these disadvantages, shadow volumes offer far more realistic
shadows than the simple shadows described above.  Unless it's important
to render accurate shadows of bitmapped objects, shadow volumes are 
recommended over simple shadows.  To use shadow volumes, you'll need
to enable lighting, and then enable the shadows using the 
<ulink url="../classes/Control.html">Control.tz</ulink> method
<ulink url="../classes/Control.html#enable-shadows">enable-shadow-volumes</ulink>.
Shadow volumes can be disabled using 
<ulink url="../classes/Control.html#disable-shadows">disable-shadows-volumes</ulink>.
</para>
</sect2>

</sect1>

<sect1 id="loading-images"><title>Loading Image Files</title>

<note><title>Changed in breve 2.0</title>
<para>
The methods used for loading images have been changed from breve 1.x, 
so pay close attention to this section if you're updating your 
simulation from a previous version of breve.
</para>
</note>

<para>
<indexterm><primary>SGI image files</primary></indexterm>
<indexterm><primary>JPEG image files</primary></indexterm>
<indexterm><primary>PNG image files</primary></indexterm>
breve can use image files to texture objects, display objects as 
bitmaps, or to display objects as lightmaps.  These techniques are
described later in the chapter.  This section describes how image
files can be loaded into breve.
</para>
<para>
<emphasis>breve</emphasis> supports three image file formats: 1)
SGI, 2) JPEG, 3) PNG. Though JPEG is the most common, most graphics
programs can output images in all three formats. Specifically, the
shareware program Graphic Converter can convert between the three
formats.</para>
<para>
<emphasis>PNG is the preferred image format&mdash;it allows more control
over how the image is loaded into a texture</emphasis>. Support for
the SGI format is provided for backward compatibility. Support for
the JPEG format is provided because it is somewhat more common than
PNG.</para>
<para>
Prior to version 2.0, breve required all images loaded into breve to
be square, and for the length of the sides of the images must be a power 
of two (for example, 256x256 or 128x128).  This is no longer strictly
required, though it may still be preferable.  breve will automatically 
surround the image with a transparent border in order to fulfill the 
size requirements.
</para>
<para>
Images are loaded using the class Image.  To load an image file, 
create a new instance of the class Image, and load a file with the 
load method:
<screen>
	image = new Image.
	image load file "myimage.png".
</screen>
</para>
<para>
Once an image file has been loaded, it can be used as a texture,
bitmap or lightmap, as described later in this chapter. 
</para>
</sect1>

<sect1 id="bitmapping">
<title>Displaying Objects as Bitmaps</title>
<note><title>Changed in breve 2.0</title>
<para>
The methods used for bitmapping have been changed from breve 1.x, 
so pay close attention to this section if you're updating your 
simulation from a previous version of breve.
</para>
</note>

<para>
<indexterm><primary>bitmapping</primary></indexterm>
<indexterm><primary>set-bitmap-image Method</primary></indexterm>
Agents in <emphasis>breve</emphasis> can be displayed as 
user-specified image files.  This technique is referred to as 
<emphasis>bitmapping</emphasis>.  If an object is set up for 
bitmapping, the bitmap image is shown instead of the 3D object
and will always face forward, regardless of the viewer's 
perspective.  This is in contrast to <emphasis>texturing</emphasis>,
in which the image is used as a surface for a 3D shape.  Texturing 
is described in the next section, <xref linkend="texturing">.
</para>
<para>
To set a bitmap image for an object in breve, the image must be 
loaded into breve as described in the previous section 
<xref linkend="loading-images">.  Once the image has been loaded,
you can set the bitmap image of an object by passing the image 
to the method "set-bitmap-image" found in
<ulink url="../classes/Real.html">Real.tz</ulink> 
</para>
<para>
The following code loads an image and uses it as the bitmap
image for an instance of the class Bird (this example is taken
from the Swarm demo): 
<screen>
	breveTexture = (new Image load from "breve.png"). 
	bird = new Bird. 
	bird set-bitmap-image to breveTexture.
</screen>
</para>
<para>
This technique is used in the Swarm demo to generate flying 
<emphasis>breve</emphasis> logos shown below.
<mediaobject><imageobject><imagedata align="center" fileref="images/billboard.jpg"></imageobject></mediaobject>
</para>

<para>
Don't forget that the bitmap is set on an instance by
instance basis, so you should call these methods for explicitly for
each instance you want to bitmap. 
objects.
</para>
<para>
Also note that loading multiple textures use up a lot of memory
and hurt performance, <emphasis>even if you are loading the same
texture multiple times</emphasis>.  It is therefore preferable to
share the same texture image among many agents when possible.
This may require the controller to load the texture and pass it 
out to the agents, instead of having the agents load it themselves:
<screen>
	# bad idea!
	
	self set-bitmap-image to (new Image load from "texture.png").
	
	# good idea!
	
	self set-bitmap-image to (controller get-shared-texture).
</screen>
</para>
</sect1>
<sect1 id="texturing">
<title>Texturing Objects</title>

<note><title>Changed in breve 2.0</title>
<para>
The methods used for texturing objects have been changed from breve 1.x, 
so pay close attention to this section if you're updating your 
simulation from a previous version of breve.
</para>
</note>

<para>
Texturing allows images to be tiled on a 3D object.  This is in
contrast to the bitmapping described in <xref linkend="bitmapping">,
in which an image is displayed in place of the 3D object.  An example
of object texturing is shown below, with a semi-transparent textured cube:
<mediaobject><imageobject><imagedata align="center" fileref="images/textured_transparent_cube.jpg"></imageobject></mediaobject>
</para>
<para>
The first step in texturing an object is loading in the texture from
an image file.  Instructions for loading image files for texturing are
given in <xref linkend="loading-images">.  Once the texture image has 
been loaded, texturing can be done by passing the texture image to 
the method <ulink url="../classes/Real.html#set-texture">set-texture-image</ulink>
for any <ulink url="../classes/Real.html">Real</ulink> object.  
</para>
<para>
As mentioned in <xref linkend="bitmapping">, loading multiple instances
of the same texture image will be expensive in terms of both memory and 
performance, so if you're using the same texture on many agents, you 
should reuse the same Image object.  An example of this is shown in 
<xref linkend="bitmapping">.
</para>
</sect1>

<sect1 id="lightmapping">
<title>Displaying Objects as "Lightmaps"</title>

<note><title>Changed in breve 2.0</title>
<para>
The methods used for lightmapping have been changed from breve 1.x, 
so pay close attention to this section if you're updating your 
simulation from a previous version of breve.
</para>
</note>

<para>
<indexterm><primary>lightmapping</primary></indexterm>
Lightmaps use textures to  make objects glow transparently.  An image 
from the included <function>ParticleFountain</function> demo is shown below.
<mediaobject><imageobject><imagedata align="center" fileref="images/lightmap.jpg"></imageobject></mediaobject>
</para>
<para>
The first step in applying a lightmap to a object is loading in the texture 
from an image file.  Instructions for loading image files for lightmapping are
given in <xref linkend="loading-images">.  Once the image has been loaded, 
lightmapping can be done by passing the image to the method 
<ulink url="../classes/Real.html#set-texture">set-lightmap-image</ulink>
for any <ulink url="../classes/Real.html">Real</ulink> object.  
</para>
<para>
Lightmapping will work with any image, but looks best with spherical images which 
taper off around the edges.  Two images that work well as lightmaps are included 
with breve.  The files are included in the classes directory and are available 
as "images/lightmap.png" and "images/dirtylightmap.png".
</para>
<para>
As mentioned in <xref linkend="bitmapping">, loading multiple instances
of the same lightmap image will be expensive in terms of both memory and 
performance, so if you're using the same lightmap on many agents, you 
should reuse the same Image object.  An example of this is shown in 
<xref linkend="bitmapping">.
</para>

</sect1>

<sect1 id="imageclass"><title>Using the "Image" Class</title>
<para>
Once an image file has been loaded in to an Image object 
(as described in <xref linkend="loading-images">), the image data can be 
accessed or manipulated directly via methods in the class 
<ulink url="../classes/Image.html">Image.tz</ulink>.
</para>
<para>
The Image class method 
<ulink url="../classes/Image.html#set-pixel">set-pixel</ulink> (and related 
methods for setting red, green, blue and alpha pixel values individually)
can be used to modify an image dynamically.  This will dynamically alter 
the appearence of any objects using the image as a texture, bitmap or 
lightmap.  The demo "DynamicTexture" shows an example of how image textures
can be dynamically modified.
</para>
<para>
The Image class method 
<ulink url="../classes/Image.html#get-pixel">get-pixel</ulink> (and related 
methods for getting red, green, blue and alpha pixel values individually)
can be used to read individual pixel data from an Image.  This allows the 
image data to be used as simulation input.  The demo "Painter" shows an
example of how an Image file can be used as input data for a simulation.
</para>
</sect1>

<sect1 id="drawing"><title>Custom Drawings with the "Drawing" Class</title>
<para>
It is sometimes desirable to draw lines or polygons directly into the simulated 
world.  Custom drawings can be created by using class
<ulink url="../classes/Drawing.html">Drawing.tz</ulink>.  After creating an
instance of the Drawing class, individual drawing instructions are added to 
create line segments and polygons, or to change color and transparency values.
More information on creating drawings can be found in the documentation for 
the class <ulink url="../classes/Drawing.html">Drawing.tz</ulink>
</para>
</sect1>

<sect1 id="sounds"><title>Playing Sound Effects</title>
<para>
<indexterm><primary>sounds</primary></indexterm>
<indexterm><primary>Sound class</primary></indexterm>
<indexterm><primary>AIFF sound files</primary></indexterm>
<indexterm><primary>WAV sound files</primary></indexterm>
Sounds can be loaded and played using the class <ulink url="../classes/Sound.html">Sound</ulink>.
Supported file formats for sounds are AIFF and WAV.  To load a sound file, created a new instance
of the Sound class, and load in the file using the method 
<ulink url="../classes/Sound.html#load">load</ulink>.  You can then play the sound using the method
<ulink url="../classes/Sound.html#play">play</ulink>.  Sound instances can play multiple overlapping
copies of the same sound simultaneously, meaning that one sound need not finish before another 
call to <function>play</function> is made.
<tip><title>Bad Sound Files</title>
<para>
Though AIFF and WAV are well-defined standards, it is not uncommon to find AIFF or WAV files 
which play fine in some programs, but which cannot be read by others.  If you have an AIFF or 
WAV file that does not seem to play correctly in breve, try loading it into a good quality
sound editor (such as QuickTime Player on Mac OS X), and re-exporting the sound.
</para>
</tip>
</para>
</sect1>

<sect1 id="included-sounds"><title>Sounds Included With breve</title>
<para>
A few sounds are included in the breve distribution for use in any simulation.  The are 
located in the <function>classes</function> directory, in a subdirectory called 
<function>sounds</function>.  
</para>
<para>
The sounds provided are:
<itemizedlist>
<listitem><para><function>sounds/cat.wav</function></para></listitem>
<listitem><para><function>sounds/chimp.wav</function></para></listitem>
<listitem><para><function>sounds/dog_bark.wav</function></para></listitem>
<listitem><para><function>sounds/explosion.wav</function></para></listitem>
<listitem><para><function>sounds/laser_cannon.wav</function></para></listitem>
</itemizedlist>
</para>
</sect1>

</chapter>
