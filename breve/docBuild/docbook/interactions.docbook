<!--
    The breve Simulation Environment documentation
    Copyright (C) 2003 Jonathan Klein
-->

<chapter id="interactions">
<title>Interactions Between Agents</title>
<para>
This chapter describes implementing interactions between agents in a breve 
simulation.
</para>

<sect1 id="controller">
<title>Interacting With the Controller Object</title>
<para> 
The controller object is the heart and soul of the breve simulation and every 
object should be able to speak to it.  The class
<ulink url="../classes/Object.html">Object</ulink>&mdash;and thus all other
classes ever created in breve&mdash;has a variable called controller which is the 
simulations controller instance. 
</para>
<para>
This simply means that the expression "controller" will automatically refer to the 
simulation's controller instance.  You should not try to modify the value of 
the controller variable, as this will have unexpected results on the simulation.
</para>
</sect1>

<sect1 id="collision_callback">
<title>Triggering Events When Agents Collide</title>
<para>
<indexterm><primary>collisions</primary></indexterm>
<indexterm><primary>handle-collisions (method)</primary></indexterm>
It is frequently desirable to have agents perform some sort of interaction 
when they collide.  The agents might exchange information, fight or 
reproduce, for example.  In order to specify what happens when a collision
occurs, use the method 
<ulink url="../classes/Real.html#handle-collisions">handle-collisions</ulink>
found in <ulink url="../classes/Real.html">Real.tz</ulink>.  This method
expects a <function>string</function> method name, which is the method
that will be invoked when the collision occurs, and a 
<function>string</function> type, which specifies the class name to set
up the handler for. 
</para>
<para>
The handler method must expect a single argument, of type 
<function>object</function>.  When the collision occurs, the method
is called with object that is encountered.  In the following code 
excerpt, for example, an agent defines a method called 
"setup-collision-handler" to setup a collision handler for a (fictional)
class called "Food".  When the agent collides with a piece of food,
the method "eat" will be called, and the argument passed in is the 
piece of food with which the agent has collided:
<screen>
+ to setup-collision-handler:
	self handle-collisions with-type "Food" with-method "eat".

+ to eat food foodObject
	print "I just ate $foodObject.  It was yummy
	free foodObject.
</screen>
</para>
<para>
If two agents collide, and both have collision handlers setup, then the 
collision callbacks are not guaranteed to be executed in any particular 
order.  It is sometimes desirable for both objects to execute their 
callbacks, while in other cases, only one agent should execute the callback.
If the callback is expected to trigger a one-time interaction (like a fight)
for example, then you don't want to allow the callback to be executed for 
both agents.  In this case, make your collision handler return a positive 
number.  <emphasis>If the first callback method returns a positive number,
then the second callback will not be executed</emphasis>.  If the callback
returns zero, or doesn't return a value at all, both callbacks will be 
executed.
</para>
</sect1>

<sect1 id="neighbor_checking">
<title>Finding Neighboring Objects</title>
<para>
<indexterm><primary>neighbor detection</primary></indexterm>
<indexterm><primary>set-neighborhood-size (method)</primary></indexterm>
<indexterm><primary>update-neighbors (method)</primary></indexterm>
<indexterm><primary>get-neighbors (method)</primary></indexterm>
The slow way to find neighboring objects is to look at every object in the 
simulation and determine whether they are close enough the be considered 
neighbors.  To repeat this process for N objects which want to keep track 
of, N*N checks are required for each iteration.  This quickly becomes the 
an inefficient bottleneck.
</para>
<para>
breve offers a solution to this problem in which the time required to 
find neighbors grows roughly linearly with the number of the objects in 
the simulation.  The feature is referred to as 
<firstterm>neighbor checking</firstterm>.  Neighbor checking is done
in three steps:
<orderedlist>
<listitem><para>Set each agent's "neighborhood size".</para></listitem>
<listitem><para>Ask the engine to update the neighbors at each iteration.</para></listitem>
<listitem><para>Retrieve each agents list of neighbors at each timestep.</para></listitem>
</orderedlist>
</para>
<para>
The neighborhood size specifies the distance that each agent will look in 
order to find any neighbors.  This is typically done during object 
initialization, but it may be changed at any time during the simulation.  
Neighborhood size is set using the method 
<ulink url="../classes/Real.html#set-neighborhood-size">set-neighborhood-size</ulink> in <ulink url="../classes/Real.html">Real.tz</ulink>.  Real is the parent class of both 
<ulink url="../classes/Stationary.html">Stationary</ulink> and 
<ulink url="../classes/Mobile.html">Mobile</ulink> objects, so the method can be used with 
these classes as well. 
</para>
<para>
The second step, updating the neighbors, is done with a call to the method 
<ulink url="../classes/Control.html">update-neighbors</ulink> in the iterate method 
of your simulations controller object.
</para>
<para>
The final step of retrieving the neighbors is done using the  
<ulink url="../classes/Real.html#get-neighbors">get-neighbors</ulink> method of 
<ulink url="../classes/Real.html">Real.tz</ulink>. This method returns the 
neighbors as a <function>list</function>.  For example, the following iterate 
method would print out a list of the agent's neighbors at each time step, 
assuming that the neighborhood size has been set and that the neighbors are
being updated: 
<screen>
+ to iterate:
	neighbors (list).
	item (object).

	neighbors = (self get-neighbors).

	foreach item in neighbors: print "$item is in my neighborhood.".
</screen>
</para>
</sect1>

<sect1 id="closest_object">
<title>Finding the Closest Object</title>
<para>
<indexterm><primary>closest object</primary></indexterm>
Finding the closest object can be slightly more complicated than simply getting the 
neighbors, because it's possible that the closest object is not within an object's 
neighborhood.  However, assuming that some number of neighbors are found for your
agent, the following code should help:
<screen>
+ to find-closest-neighbor:
	closestNeighbor (object).
	distance, minDistance (float).

	# start with an arbitrarily high distance

	minDistance = 1000000.

	foreach i in (self get-neighbors): {
		distance = | (self get-location) - (i get-location) |.

		if distance < minDistance: {
			minDistance = distance.
			closestNeighbor = i.
		}
	}

	return closestNeighbor.
</screen>
</para>
<para>
If there are no neighbors within the local neighborhood then it is sometimes necessary
to do a search of all agents in the simulation.  To do this, the code above can be 
modified by using an <function>all</function> statement (<xref linkend="all">) in place of the "self get-neighbors" expression:
<screen>
	foreach i in (all "Reals") {
		# code to select the closest neighbor
	}
</screen>
</para>
</sect1>

<sect1 id="notifications">
<title>Triggering Events Using Notifications</title>
<para>
<indexterm><primary>notifications</primary></indexterm>
<indexterm><primary>announce method</primary></indexterm>
<indexterm><primary>observe method</primary></indexterm>
Notifications allow instances to make announcements to an arbitrary set of 
"listeners".  This allows instances to communicate somewhat indirectly&mdash;
the announcing instance care or keep track of who is listening to 
the announcements.
</para>
<para>
An object may make an announcement at any time by using the method 
<ulink url="../classes/Object.html#announce">announce</ulink> in the class 
<ulink url="../classes/Object.html">Object</ulink>.  The announcement may reflect a state 
change in the object or a reaction to a specific event.  
</para>
<para>
The announcement itself does not affect the other instances in the simulation unless they 
have explicitly decided to "observe" the announcer using the observe. 
The observe method expects the object to be observed, the name of the announcement to look 
for, and the method to call when the announcement occurs.  For example, an instance 
interested in monitoring the controller for a (fictional) "New Object" notification would call: 
<screen>
self observe controller for-notification "New Object" with-method "new-of-new-object".
</screen>
The observing object would then get a call to the method notify-of-new-object whenever 
the controller made the announcement "New Object". 
</para>
<para>
Once an observer instance begins to observe another instance, the observer will get a 
callback every time the desired notification is announced. The callback method must 
take 2 arguments: the source of the announcement and the announcement string.  
The keywords are unimportant, but a simple example is: 
<screen>
+ to notify-of-new-object from-instance announcer (object) with-message message (string):
	print "I got the message $message from $announcer!".
</screen>
</para>
</sect1>

<sect1 id="all">
<title>Finding All Objects of a Given Type</title>
<para>
<indexterm><primary>all expression</primary></indexterm>
You can find all instances of a given class using the "all" expression: 
<screen>
# get a list of all mobile objects in the simulation

myMobile = all Mobiles
</screen>
</para>
</sect1>

<sect1 id="can_respond">
<title>Testing Whether an Object Responds to a Method Call</title>
<para>
<indexterm><primary>can-respond (method)</primary></indexterm>
If you need to know whether an item can respond to a certain method call, use the 
method <ulink url="../classes/Object.html#can-respond">can-respond</ulink> in 
<ulink url="../classes/Object.html">Object.tz</ulink>.  As with is, this method is 
used like a statement that returns true or false: 
<screen>
    if (item can-respond to "sing-and-dance"): item sing-and-dance.
</screen>
</para>
</sect1>

<sect1 id="object_types">
<title>Testing the Type of an Object</title>
<para>
<indexterm><primary>is (method)</primary></indexterm>
If you need to determine whether an object is of a certain type, you can use the 
method <ulink url="../classes/Object.html#is">is</ulink> from 
<ulink url="../classes/Object.html">Object.tz</ulink>.  The method takes a single 
keyword, "a", such that the method call can be written: 
<screen>
    item is a "Dog".
</screen>
</para>
<para>
The call returns a int value 1 if the item is of the specified type, or 0 
otherwise.  This would most likely be part of an if statement: 
<screen>
    if (item is a "Dog"): item roll-over.
</screen>
</para>
<para>
This method is useful in collision callbacks or when examining neighbors in order
to determine the appropriate action.
</para>
</sect1>

</chapter>
