<!--
	The breve Simulation Environment documentation
	Copyright (C) 2003-2004 Jonathan Klein
-->

<chapter id="source">
<title>The breve Source Code</title>
<para>
This chapter describes the breve source implementation, and how it can be 
extended.  This documentation describes only key API features for extending
certain aspects of breve functionality.  For more detailed documentation of 
the source code, see the <ulink url="http://www.spiderland.org/breve/docs/source">full breve source code 
documentation</ulink>.
</para>

<sect1 id="source_structure"><title>The basic structure of the breve source code</title>
<para>
The following image shows the basic structure of the breve source code:
<mediaobject><imageobject><imagedata align="center" fileref="images/breve_structure.jpg"></imageobject></mediaobject>

The text in bold for each layer indicates the source code directory where the 
source code for that layer is found.
</para>
</sect1>

<sect1 id="language_frontend"><title>Adding a front-end language to the breve engine: the breve object API</title>

<para>
This section describes how to incorporate another front-end language with breve.  
Using this information, you'll be able to use the breve engine from any language 
which can interface a C library.
</para>

<para>
The following steps are required to set up a language front-end in breve.
<itemizedlist>
<listitem><para>Write special callbacks for the language front-end (<xref linkend="breve_object_callbacks">).</para></listitem>
<listitem><para>Construct a new breve object type, and add classes to the breve engine (<xref linkend="breve_object_type">).</para></listitem>
<listitem><para>Add instances to the breve engine (<xref linkend="breve_object_api">).</para></listitem>
<listitem><para>Connect the language frontend to an application frontend (<xref linkend="application_frontend">) or write your own customized frontend (<xref linkend="custom_application_frontend">).</para></listitem>
</itemizedlist>
</para>

<sect2 id="breve_object_callbacks"><title>Callbacks required to add a new front-end language</title>
<para>

In order to provide a language front-end to breve, a set of callbacks must be defined.  

<itemizedlist>
<listitem>
<para>
<function>findMethod</function>: locate a method for a class by name and argument count.
	<screen>void *(*findMethod)(brObject *object, char *name, int nargs);</screen>
</para>
<para>
The breve engine will need to be able to locate methods by name and argument count in order to preform
certain callbacks.  Looking up methods by name may be time consuming, so breve will lookup the method 
by name once, and then cache the result for future use.
</para>
<para>
This callback method is given a breve object struct (<function>brObject</function>) a name character
string, and a number of arguments.  The callback then looks up the method, making use of the 
<function>brObject</function> "pointer" field, and returns a pointer corresponding to the desired 
method.  This <function>void*</function> pointer will be stored in the "pointer" field of a 
<function>brMethod</function> structure.  This data will be used later, when a method call is triggered.
</para>
</listitem>


<listitem>
<para>
<function>callMethod</function>: trigger a method call in the front-end language.
	<screen>int (*callMethod)(brInstance *instancePointer, brMethod *method, brEval **arguments, brEval *result);</screen>
</para>
<para>
The breve engine will need to trigger method calls in the front-end language for a number
of events such as iteration and collision handling.  This callback is used to trigger such
events.
</para>
<para>
The callback is given the instance to be used, a <function>brInstance</function> instance structure 
(which contains a native language instance pointer in the "pointer" field); the method to 
be called, a <function>brMethod</function> structure (which contains a native language 
method pointer in the "pointer" field); an array of <function>brEval</function> argument pointers, 
and a pointer to an output <function>brEval</function> structure.
</para>
<para>
The callback should trigger the method call <replaceable>method</replaceable> for the instance
<replaceable>instancePointer</replaceable>.  It expects that the <replaceable>arguments</replaceable>
array contains the number of items specified by the <function>brMethod</function> structure's 
argumentCount field.
</para>
</listitem>

<listitem>
<para>
<function>isSubclass</function>: determine whether a class is a subclass of another.
	<screen>int (*isSubclass)(brObject *class1, brObject *class2);</screen>
</para>
<para>
In order to correctly handle certain interactions like collisions, the breve engine needs to
know whether one class is a subclass of another.  
</para>
<para>
This callback is given two breve object pointers, and must return 1 if 
<replaceable>class1</replaceable> is a subclass of 
<replaceable>class2</replaceable>, and 0 otherwise.
</para>
</listitem>

</itemizedlist>

</para>

</sect2>

<sect2 id="breve_object_type"><title>Specifying a new breve object type, and 
registering objects</title>
<para>
Every object in a front-end language that will have instances in the breve engine 
must be registered with the breve engine.  Moreover, when an object is added 
to the breve engine, it must also tell the engine what "type" of object it is.  
Each object "type" corresponds to a different language front-end and a different 
set of callbacks, so for each language front-end one creates, one must also create 
a <function>brObjectType</function> structure which contains the proper callbacks.  
The structure is shown below.
<screen>
struct brObjectType {
	int (*callMethod)(brInstance *instancePointer, brMethod *method, brEval **arguments, brEval *result);
	brMethod *(*findMethod)(brInstance *objectPointer, char *name, int nargs);
	int (*isSubclass)(brObject *class1, brObject *class2);
};
</screen>
Only one <function>brObjectType</function> is required for each language front-end.
</para>
<para>
Once the language front-end is defined, objects can be registered with the breve engine.
For each object that will be used in breve, the following function should be called once:
<screen>
brObject *brEngineAddObject(brEngine *e, brObjectType *t, char *name, void *pointer);
</screen>
The final parameter, <replaceable>pointer</replaceable>, is a pointer to the native 
language representation of the object.  This pointer will likely be used as part of the
<function>findMethod</function> and <function>findMethod</function> callbacks.
</para>

</sect2>

<sect2 id="breve_object_api"><title>Adding instances to the breve engine</title>
<para>
Once objects are registered with the breve engine, instances can be added to the engine as well.
This is done with the function <function>brEngineAddInstance</function>.
<screen>
brInstance *brEngineAddInstance(brEngine *engine, brObject *object, void *pointer);
</screen>
The third argument, <replaceable>pointer</replaceable>, is a pointer to the native language 
instance representation.  This pointer will be stored in the returned <function>brInstance</function>
and will be needed when the <function>callMethod</function> callback is triggered.  Save the 
returned <function>brInstance</function> pointer&mdash; it will be required later to interface with 
the breve engine.
</para>
</sect2>

<sect2 id="breve_object_api_structs"><title>Structures used by the breve object API</title>
<para>
The following structures are used by the breve object API:
<screen>
struct brObject {
    void *pointer;

    brObjectType *type;

    char *name;

    slStack *collisionHandlers;
};

// NOTE: the "object" field was previously called "class".  This has been
// changed to avoid conflicts with C++ compilers.

struct brInstance {
    void *pointer;

    char status;

    brObject *object;
    brEngine *engine;
    brMenuList menu;

    slList *observers;
    slList *observees;

    slList *dependencies;
    slList *dependents;

};

// NOTE: the "object" field was previously called "class".  This has been
// changed to avoid conflicts with C++ compilers.

struct brMethod {
    void *pointer;

    char *name;
    brObject *object;
    int argumentCount;
};

</screen>
</para>
</sect2>
</sect1>

<sect1 id="application_frontend"><title>Linking With the Existing breve Application Frontend</title>
<para>
Once you've written a language frontend to interface with a new programming 
language, you'll need an <firstterm>application frontend</firstterm>.  The 
application frontend is the program that a user runs to start a breve 
simulation.  It can be either a standalone program, like the existing breve 
frontends, or it can be any other application which creates and uses a breve 
engine.  This section describes using the existing breve application 
frontends with your own custom language frontend.  If you instead wish to 
implement your own custom application frontend, you'll need to use the 
functions described in <xref linkend="custom_application_frontend">.
</para>

<para>
To use the existing breve application frontends, you'll need to implement the 
functions described below, and then link the breve executables against your 
own language frontend and application frontend functions.  
</para>

<sect2><title>The <function>brFrontend</function> structure</title>
<para>
The application frontend function you'll need to implement make use of a
<function>brFrontend</function> structure.  You'll use this structure 
to access the breve engine and to access your own custom data structure.
<screen>
struct brFrontend {
	brEngine *engine;
	void *data;
};
</screen>
</para>

<para>
If you wish to use the existing breve application frontends, you'll need 
to implement the methods listed below.  You'll then need to link breve 
against your language frontend library.
</para>
</sect2>

<sect2><title><function>breveFrontendInitData</function></title>
<para>
The language-frontend must provide a <function>breveFrontendInitData</function> function:
<screen>
void *breveFrontendInitData(brEngine *engine);
</screen>
This method initializes and returns a structure to be used by your language-frontend.
The data returned will be stored in the <function>brFrontend</function> field 
<function>data</function> and will be used in the functions below.
</para>
</sect2>

<sect2><title><function>breveFrontendLoadSimulation</function></title>
<para>
The language-frontend must provide a <function>breveFrontendLoadSimulation</function> function:
<screen>
int breveFrontendLoadSimulation(brFrontend *d, char *code, char *file);
</screen>
</para>
</sect2>

<sect2><title><function>breveFrontendLoadSavedSimulation</function></title>
<para>
The language-frontend must provide a <function>breveFrontendLoadSavedSimulation</function> function:
<screen>
int breveFrontendLoadSavedSimulation(brFrontend *d, char *code, char *file, char *xmlFile);
</screen>
This function uses the language frontend data (found in the brFrontend field data) to load 
an archived simulation.  The simulation archive is given as the xmlFile.  The file containing
the original simulation code is provided as the file argument, with the text of that file in 
the code argument.
</para>
</sect2>

<sect2><title><function>breveFrontendCleanupData</function></title>
<para>
The language-frontend must provide a <function>breveFrontendCleanupData</function> function:
<screen>
void breveFrontendCleanupData(void *data);
</screen>
This function should free all memory associated with the structure that was returned earlier
by <function>breveFrontendInitData</function>.
</para>
</sect2>

<sect2><title>Linking your language-frontend with the application frontend</title>
<para>
The last step in preparing the breve binaries with a custom language frontend
is to link the breve and breve_cli programs against your own language frontend
and application frontend functions.  To do so, edit the file 
<function>bin/Makefile</function> and change the variable 
<function>LANGUAGE_FRONTEND_LIBRARY</function> to the libraries containing your
own frontend functions.
<screen>
LANGUAGE_FRONTEND_LIBRARY   = -l<replaceable>myFrontendLibrary</replaceable>
</screen>
After running <function>make</function>, the binaries 
<function>bin/breve</function> and <function>bin/breve_cli</function> should
run your custom language frontend.
</para>
</sect2>

</sect1>

<sect1 id="custom_application_frontend"><title>Implementing a Custom Application Frontend</title>
<para>
To implement a custom application frontend, or to use breve 
simulations as part of another program, you'll need to familiarize 
yourself with functions relating to the breve engine structure
<function>brEngine</function>.
</para>
<para>
<itemizedlist>
<listitem><para>Create the breve engine</para></listitem>
<listitem><para>Setup the language frontend as outlined in <xref linkend="language_frontend"></para></listitem>
<listitem><para>Add objects to the breve engine (<function>brEngineAddObject</function>)</para></listitem>
<listitem><para>Add instances to the breve engine (<function>brEngineAddInstance</function>)</para></listitem>
<listitem><para>Iterate the breve engine (<function>brEngineAddInstance</function>)</para></listitem>
</itemizedlist>

</para>
</sect1>

</chapter>
