<!--
	The breve Simulation Environment documentation
	Copyright (C) 2003-2004 Jonathan Klein
-->

<chapter id="source">
<title>The breve Source Code</title>
<para>
This chapter describes the breve source implementation, and how it can be 
extended.  This documentation describes only key API features for extending
certain aspects of breve functionality.  For more detailed documentation of 
the source code, see the <ulink url="http://www.spiderland.org/breve/docs/source">full breve source code 
documentation</ulink>.
</para>

<sect1 id="source_structure"><title>The basic structure of the breve source code</title>
<para>
The following image shows the basic structure of the breve source code:
<mediaobject><imageobject><imagedata align="center" fileref="images/breve_structure.jpg"></imageobject></mediaobject>

The text in bold for each layer indicates the source code directory where the 
source code for that layer is found.
</para>
</sect1>

<sect1 id="language_frontend"><title>Adding a frontend language to the breve engine: the breve object API</title>

<para>
This section describes how to incorporate another frontend language with breve.  
Using this information, you'll be able to use the breve engine from any language 
which can interface a C library.
</para>

<para>
The following steps are required to set up a language frontend in breve.
<itemizedlist>
<listitem><para>Write special callbacks for the language frontend (<xref linkend="breve_object_callbacks">).</para></listitem>
<listitem><para>Construct a new breve object type, and add classes to the breve engine (<xref linkend="breve_object_type">).</para></listitem>
<listitem><para>Test the language frontend using the existing breve program (<xref linkend="object_frontend_testing">).</para></listitem>
<listitem><para>If desired, connect the language frontend to an application frontend (<xref linkend="application_frontend">) or write your own customized frontend (<xref linkend="custom_application_frontend">).</para></listitem>
</itemizedlist>
</para>

<sect2 id="breve_object_structs"><title>Structures used by the breve Object API</title>
<para>
The following structures are used by the breve Object API.  These structures are passed
to the frontend language callback functions.  See the file <function>kernel/breveObjectAPI.h</function> and its 
documentation for a full description of these structs.
<itemizedlist>
<listitem><para><function>brObjectType</function>: information and callbacks for a language frontend</para></listitem>
<listitem><para><function>brObject</function>: a class in any frontend language</para></listitem>
<listitem><para><function>brInstance</function>: an instance in any frontend language</para></listitem>
<listitem><para><function>brMethod</function>: information about a method in an object</para></listitem>
</itemizedlist>
</para>
<para>
You should also familiarize yourself with the <function>brEval</function> structure and 
types which are described in <xref linkend="c_wrappers">.
</para>
</sect2>

<sect2 id="breve_object_callbacks"><title>Callbacks required to add a new frontend language</title>
<para>

In order to provide a language frontend to breve, a set of callbacks must be defined.  

<itemizedlist>
<listitem>

<para>
<function>findObject</function>: locate a class by name.
	<screen>void *(*findObject)(brObjectType *type, char *name);</screen>
</para>
<para>
When breve encounters a class name that it does not recognize, it will use
this function to attempt to lookup the object.  The pointer that is returned 
will be placed in the <function>pointer</function> field of a 
<function>brObject</function>.  This pointer will likely be used later to 
instantiate objects or locate instance methods by your <function>instantiate</function> 
or <function>findMethod</function> callbacks.
</para>
</listitem>

<listitem>
<para>
<function>findMethod</function>: locate a method for a class by name and argument count.
	<screen>void *(*findMethod)(brObject *object, char *name, unsigned char *types, int nargs);</screen>
</para>
<para>
When breve needs to call a method in an object, it will be looke up using this callback.  
The <function>object</function> argument refers to the object in which the method can
be found&mdash;it contains the pointer returned by your <function>findObject</function>
callback in the pointer field.
</para>
<para>
The nargs argument gives the number of arguments that will be passed to the method,
and the types argument contains the argument types.  The types are described in 
<xref linkend="c_wrappers">
</para>
</listitem>

<listitem>
<para>
<function>callMethod</function>: trigger a method call in the frontend language.
	<screen>int (*callMethod)(brInstance *instancePointer, brMethod *method, brEval **arguments, brEval *result);</screen>
</para>
<para>
The breve engine will need to trigger method calls in the frontend language for a number
of events such as iteration and collision handling.  This callback is used to trigger such
events.
</para>
<para>
The callback is given the instance to be used, a <function>brInstance</function> instance structure 
(which contains a native language instance pointer in the "pointer" field); the method to 
be called, a <function>brMethod</function> structure (which contains a native language 
method pointer in the "pointer" field); an array of <function>brEval</function> argument pointers, 
and a pointer to an output <function>brEval</function> structure.
</para>
<para>
The callback should trigger the method call <replaceable>method</replaceable> for the instance
<replaceable>instancePointer</replaceable>.  It expects that the <replaceable>arguments</replaceable>
array contains the number of items specified by the <function>brMethod</function> structure's 
argumentCount field.
</para>
</listitem>

<listitem>
<para>
<function>instantiate</function>: create an instance of an object.
	<screen>void *(*instantiate)(brObject *object, brEval **constructorArgs, int argCount);</screen>
</para>
</listitem>

<listitem>
<para>
<function>isSubclass</function>: determine whether a class is a subclass of another.
	<screen>int (*isSubclass)(brObject *class1, brObject *class2);</screen>
</para>
<para>
In order to correctly handle certain interactions like collisions, the breve engine needs to
know whether one class is a subclass of another.  
</para>
<para>
This callback is given two breve object pointers, and must return 1 if 
<replaceable>class1</replaceable> is a subclass of 
<replaceable>class2</replaceable>, and 0 otherwise.
</para>
</listitem>

<listitem>
<para>
<function>destroyObject:</function> release memory allocated by your <function>findObject</function> callback.
	<screen>void (*destoryObject)(void *objectData);</screen>
If your <function>findObject</function> callback allocates memory, this callback should release that memory.
</para>
</listitem>

<listitem>
<para>
<function>destroyInstance:</function> release memory allocated by your <function>instantiate</function> callback.
	<screen>void (*destoryInstance)(void *instanceData);</screen>
If your <function>instantiate</function> callback allocates memory, this callback should release that memory.
</para>
</listitem>

<listitem>
<para>
<function>destroyMethod:</function> release memory allocated by your <function>findMethod</function> callback.
	<screen>void (*destoryMethod)(void *methodData);</screen>
If your <function>findMetho</function> callback allocates memory, this callback should release that memory.
</para>
</listitem>

<listitem>
<para>
<function>destroyObjectType:</function> release the memory associated with your <function>brObjectType</function>.
	<screen>void (*destroyData)(void *objectTypeData);</screen>
If you have allocate memory to be placed in the <function>data</function> field of the 
<function>brObjectType</function>, this callback should release that memory.
</para>
</listitem>

</itemizedlist>

</para>

</sect2>

<sect2 id="breve_object_type"><title>Specifying a new breve object type, and 
registering objects</title>
<para>
Every object in a frontend language that will have instances in the breve engine 
must be registered with the breve engine.  Moreover, when an object is added 
to the breve engine, it must also tell the engine what "type" of object it is.  
Each object "type" corresponds to a different language frontend and a different 
set of callbacks, so for each language frontend one creates, one must also create 
a <function>brObjectType</function> structure which contains the proper callbacks.  
The structure is shown below.
<screen>
struct brObjectType {
    void *(*findMethod)(brObject *object, char *name, unsigned char *types, int nargs);
    void *(*findObject)(brObjectType *type, char *name);
    void *(*instantiate)(brObject *object, brEval **constructorArgs, int argCount);

    int (*callMethod)(brInstance *instance, brMethod *method, brEval **arguments, brEval *result);

    int (*isSubclass)(brObject *class1, brObject *class2);

    void (*destroyObject)(brObject *object);
    void (*destoryMethod)(brMethod *method);
    void (*destroyInstance)(brInstance *instance);
    void (*destroyObjectType)(brObjectType *objectType);

    void *data;
};
</screen>
Only one <function>brObjectType</function> is required for each language frontend.
</para>
<para>
Once the language frontend is defined, you can add it to the engine with the following
function:
<screen>
void brEngineRegisterObjectType(brEngine *engine, brObjectType *type);
</screen>
</para>
</sect2>

<sect2 id="object_frontend_testing">
<title>Testing and using the object frontend</title>
<para>
Once you have written code to setup and register your new breve object type, you'll
want to test that breve can locate objects, instantiate them and call their methods.
To do so, you can add your frontend object type to the breve engine, and then 
instantiate an object from steve code.
</para>
<para>
To add your frontend object type to the breve engine, edit the file 
<function>kernel/frontendAPI.c</function>, and look at the function
<function>breveFrontendInit</function>.  The existing breve applications
call this function to create a breve engine.  At the bottom of this function,
you can create and register your custom language frontend.  
<screen>
brEngineRegisterObjectType(frontend->engine, <replaceable>functionToCreateLanguageFrontend</replaceable>());
</screen>
</para>
<para>
After recompiling breve with this change, it should be possible to instantiate 
an object from your new language frontend from directly within a steve simulation.
See the Java example <function>java/JavaTest.tz</function> for more information.
</para>

</sect2>

</sect1>

<sect1 id="application_frontend"><title>Linking With the Existing breve Application Frontend</title>
<para>
Once you've written a language frontend to interface with a new programming 
language, you'll need an <firstterm>application frontend</firstterm>.  The 
application frontend is the program that a user runs to start a breve 
simulation.  It can be either a standalone program, like the existing breve 
frontends, or it can be any other application which creates and uses a breve 
engine.  This section describes using the existing breve application 
frontends with your own custom language frontend.  If you instead wish to 
implement your own custom application frontend, you'll need to use the 
functions described in <xref linkend="custom_application_frontend">.
</para>

<para>
To use the existing breve application frontends, you'll need to implement the 
functions described below, and then link the breve executables against your 
own language frontend and application frontend functions.  
</para>

<sect2><title>The <function>brFrontend</function> structure</title>
<para>
The application frontend function you'll need to implement make use of a
<function>brFrontend</function> structure.  You'll use this structure 
to access the breve engine and to access your own custom data structure.
<screen>
struct brFrontend {
	brEngine *engine;
	void *data;
};
</screen>
</para>

<para>
If you wish to use the existing breve application frontends, you'll need 
to implement the methods listed below.  You'll then need to link breve 
against your language frontend library.
</para>
</sect2>

<sect2><title><function>breveFrontendInitData</function></title>
<para>
The language-frontend must provide a <function>breveFrontendInitData</function> function:
<screen>
void *breveFrontendInitData(brEngine *engine);
</screen>
This method initializes and returns a structure to be used by your language-frontend.
The data returned will be stored in the <function>brFrontend</function> field 
<function>data</function> and will be used in the functions below.
</para>
</sect2>

<sect2><title><function>breveFrontendLoadSimulation</function></title>
<para>
The language-frontend must provide a <function>breveFrontendLoadSimulation</function> function:
<screen>
int breveFrontendLoadSimulation(brFrontend *d, char *code, char *file);
</screen>
</para>
</sect2>

<sect2><title><function>breveFrontendLoadSavedSimulation</function></title>
<para>
The language-frontend must provide a <function>breveFrontendLoadSavedSimulation</function> function:
<screen>
int breveFrontendLoadSavedSimulation(brFrontend *d, char *code, char *file, char *xmlFile);
</screen>
This function uses the language frontend data (found in the brFrontend field data) to load 
an archived simulation.  The simulation archive is given as the xmlFile.  The file containing
the original simulation code is provided as the file argument, with the text of that file in 
the code argument.
</para>
</sect2>

<sect2><title><function>breveFrontendCleanupData</function></title>
<para>
The language-frontend must provide a <function>breveFrontendCleanupData</function> function:
<screen>
void breveFrontendCleanupData(void *data);
</screen>
This function should free all memory associated with the structure that was returned earlier
by <function>breveFrontendInitData</function>.
</para>
</sect2>

<sect2><title>Linking your language-frontend with the application frontend</title>
<para>
The last step in preparing the breve binaries with a custom language frontend
is to link the breve and breve_cli programs against your own language frontend
and application frontend functions.  To do so, edit the file 
<function>bin/Makefile</function> and change the variable 
<function>LANGUAGE_FRONTEND_LIBRARY</function> to the libraries containing your
own frontend functions.
<screen>
LANGUAGE_FRONTEND_LIBRARY   = -l<replaceable>myFrontendLibrary</replaceable>
</screen>
After running <function>make</function>, the binaries 
<function>bin/breve</function> and <function>bin/breve_cli</function> should
run your custom language frontend.
</para>
</sect2>

</sect1>

<sect1 id="custom_application_frontend"><title>Implementing a Custom Application Frontend</title>
<para>
To implement a custom application frontend, or to use breve 
simulations as part of another program, you'll need to familiarize 
yourself with functions relating to the breve engine structure
<function>brEngine</function>.
</para>
<para>

<itemizedlist>
<listitem><para>Create the breve engine (<function>brEngineNew</function>)</para>
<para>
Simply call <function>brEngineNew</function> to get a breve engine.
</para>
</listitem>

<listitem><para>Setup the language frontend as outlined in <xref linkend="language_frontend"></para></listitem>

<listitem><para>Locate objects in the breve engine (<function>brObjectFind</function>)</para>
<para>
<screen>
brObject *brObjectFind(brEngine *n, char *name);
</screen>
breve needs to have information about each object type used in a simulation.  The function 
<function>brObjectFind</function> uses the language frontends to locate and register objects
with the engine.  This function returns a <function>brObject</function> structure which can
be used to create instances or find methods.
</para>
</listitem>

<listitem><para>Add instances to the breve engine (<function>brEngineAddInstance</function> or <function>brObjectInstantiate</function>)</para>
<para>
<screen>
brInstance *brEngineAddInstance(brEngine *e, brObject *o, void *userData);
brInstance *brObjectInstantiate(brEngine *e, brObject *o, brEval **args, int argCount);
</screen>
There are two ways to add an instance to the breve engine.  If the instance already exists, it can be added with 
<function>brEngineAddInstance</function>.  This pointer that is passed to this function will become the 
<function>userData</function> of the <function>brInstance</function> struct that is returned.
</para>
<para>
If the instance does not already exist, it can be instantiated using <function>brObjectInstantiate</function>.
<function>brObjectInstantiate</function> will use the object's <function>instantiate</function> callback to 
create the object and add it to the engine.
</para>
<para>
The arguments passed to <function>brObjectInstantiate</function> are arguments
to be passed to the constructor, though THIS IS NOT CURRENTLY IMPLEMENTED.
</para>
</listitem>

<listitem><para>Iterate the breve engine (<function>brEngineIterate</function>)</para>
<para>
<screen>
int brEngineIterate(brEngine *e);
</screen>
</para>
</listitem>

</itemizedlist>

</para>
</sect1>

</chapter>
