<!--
    The breve Simulation Environment documentation
    Copyright (C) 2005 Jonathan Klein
-->

<chapter id="physics">
<title>Physical Simulation</title>
<para>

<indexterm><primary>physics</primary></indexterm>
<indexterm><primary>physical simulation</primary></indexterm>
<indexterm><primary>Open Dynamics Engine (ODE)</primary></indexterm>
Physical simulation allows simulated agents to behave in a physically realistic 
fashion.  This means that agents in the simulated world can be configured to 
behave just as real objects do, according to the laws of physics.  If a ball 
is placed in the air above a floor, for example, physical simulation can be 
used to make the ball realistically fall toward the floor and bounce.  Among 
other things, physical simulation can be used for realistic simulation of 
robots, vehicles and animals.  The current version of breve uses portions of 
the excellent ODE physical simulation engine.
</para>
<para>
Even though it is incredibly useful, physical simulation can add complexity 
and potential instabilities to a simulation.  This chapter begins by 
with the section When to Use Physical Simulation 
(<xref linkend="physics_vs_pseudo">), which discusses when it is appropriate 
to use physical simulation and possible alternatives to full physical 
simulation.  You should read this section first to help you decide whether
physical simulation is necessary for your simulation.
</para>

<sect1 id="physics_vs_pseudo">
<title>When to Use Physical Simulation</title>
<para>
<indexterm><primary>pseudo-physics</primary></indexterm>
In many circumstances, users wish to write simulations which use certain 
aspects of physics, but not others.  In these situations it is tempting to 
enable physical simulation, but this often opens the door to other sorts of 
complications.  Physical simulation is slower, more complicated and inherently 
less stable than non-physical simulation.  It is often far more effective to 
use "pseudo-physics" in which you implement some physical simulation features 
without enabling full physical simulation.
</para>
<para>
One example is a simulation which requires gravity for "ballistic" 
(non-Multibody Real) objects.  Though the effects of gravity can be enabled 
using physical simulation, a more robust and far more efficient approach is 
to simply set a constant acceleration of (0, -9.8, 0).  By disabling the 
physical simulation engine and setting a constant acceleration, a great 
deal of complexity can be avoided.
</para>
<para>
Another example is two objects which stick together and behave as a single 
entity.  Though this can be simulated as a 
<ulink url="../classes/MultiBody.html">MultiBody</ulink> object, 
if other aspects of physical simulation are <emphasis>not</emphasis> required, 
it may be better to enforce the relationship between the objects manually at 
each time-step by making one of the objects move itself to maintain a certain 
position relative to the other.
</para>
<para>
It's often unclear which technique should be used, but many users tend to err 
on the side of enabling physics which is the <emphasis>more</emphasis> 
complicated solution.  True physical simulation is typically necessary only 
when dealing with physically realistic jointed bodies, such as a simulated 
robot or simulated animal.  You should be aware of the pros and cons of 
true physical simulation and consider using your own "pseudo-physics" instead.  
</para>

</sect1>

<sect1 id="enabling_physics">
<title>Enabling Physical Simulation</title>
<para>
To write a simulation with physical simulation, your controller object
should be a subclass of the class 
<ulink url="../classes/PhysicalControl.html">PhysicalControl</ulink>.  
This class sets certain simulation parameters to values sensible for 
physical simulation, such as integration step, gravity, etc.
</para>

<para>
Physics must be enabled for <ulink url="../classes/Mobile.html">Mobile</ulink>
objects on an object by object basis using the method
<ulink url="../classes/Mobile.html#enable-physics">enable-physics</ulink>.  
When dealing with physical simulations, however, it is often preferable to 
use the Mobile subclass <ulink url="../classes/Link.html">Link</ulink> for
which physical simulation is automatically enabled.
</para>
</sect1>

<sect1 id="fast_physics">
<title>Fast Physical Simulation</title>
<para>
The ODE simulation library supports an accelerated physics simulation which 
offers great improvements in simulation speed and memory usage, at the expense 
of some accuracy.  The fast physics algorithm scales better than the normal 
physics algorithm as the number of interacting physical bodies increases.  With a 
small number of interacting physical bodies, there may not be a great difference 
between the two.  As the number increases, however, the benefits of fast physics
will become much greater.
</para>
<para>
Fast physics may be enabled using the method
<ulink url="../classes/PhysicalControl.html#enable-fast-physics">enable-fast-physics</ulink>.  
An additional iterations parameter can be set using the method 
<ulink url="../classes/PhysicalControl.html#set-fast-physics-iterations">set-fast-physics-iterations</ulink>.
The default value of 40 should give good results, but the number may be adjusted upwards for more 
accuracy, or downwards for better performance.
</para>
</sect1>

<sect1 id="stable_simulations">
<title>Writing Stable Physical Simulations</title>
<para>
<indexterm><primary>stability</primary></indexterm>
The physical simulation engine can be quite sensitive to the configuration
of bodies in a simulation.  This can lead to performance problems, instabilities
and unexpected results.  Because of the number of factors involved, it can be 
difficult to track down the exact reason for instabilities or unexpected results.
</para>
<para>
Below are some things to watch out for when dealing with physical simulation.
</para>
<para>
<itemizedlist>
<listitem><para>Instabilities may arise when dealing with very large (heavy) and very small (light) objects</para></listitem>
<listitem><para>Exerting very large joint pressures or velocities may cause unrealistic behaviors.</para></listitem>
<listitem><para>Beware of joints which force invalid or conflicting conformations on your objects.</para></listitem>
<listitem><para>Avoid forcing deep collisions between objects with either joints or manual movement.</para></listitem>
<listitem><para>Use of redundant or unnecessary joints will cause instabilities and performance problems.</para></listitem>
</itemizedlist>
</para>
</sect1>

<sect1 id="physical_simulation_parts"><title>The Components of Physically Simulated Bodies</title>
<para>
<note><title>Changed in breve 2.0</title>
<para>
The methods used for loading images have been changed from breve 1.x,
so pay close attention to this section if you're updating your
simulation from a previous version of breve.
</para>
</note>
</para>
<para>
In order to construct physically simulated agents, you'll need to be familiar with the 
components of physically simulated bodies.  There are three main components used in 
physical simulations:
<itemizedlist>
<listitem><para>Links, the basic building blocks of physically simulated objects</para></listitem>
<listitem><para>MultiBodies, physical bodies made up of one or more Link objects (<xref linkend="multibodies">)</para></listitem>
<listitem><para>Joints, rigid connections between Link objects (<xref linkend="joints">)</para></listitem>
<listitem><para>Springs, flexible connections between Link objects (<xref linkend="springs">)</para></listitem>
</itemizedlist>
</para>

<sect2 id="links"><title>The Link Class</title>
<para>
<indexterm><primary>Link class</primary></indexterm>
<indexterm><primary>orphaned link</primary></indexterm>
The Link class is the basic building block of physically simulated objects.  A link is 
simply a rigid body with a particular shape.  Once a Link is created and associated 
with a shape, it can be attached to other links via Joint objects, covered in the 
section The Joint Class and its Subclasses (<xref linkend="joints">) or brought into
the physical simulation by being associated with a MultiBody, as discussed in the 
section on using MultiBody objects (<xref linkend="multibodies">).  
</para>
<para>
Prior to breve 2.0, Link objects would not appear in the simulated world unless they
were associated with MultiBody objects (described below).  This is no longer the case.
</para>
</sect2>

<sect2 id="joints">
<title>The Joint Class and its Subclasses</title>
<para>
<indexterm><primary>Joint class</primary></indexterm>
<indexterm><primary>FixedJoint class</primary></indexterm>
<indexterm><primary>PrismaticJoint class</primary></indexterm>
<indexterm><primary>RevoluteJoint class</primary></indexterm>
<indexterm><primary>UniversalJoint class</primary></indexterm>
<indexterm><primary>BallJoint class</primary></indexterm>
As mentioned in the previous section (<xref linkend="multibodies">), 
<ulink url="../classes/Link.html">Links</ulink> are joined together using 
<ulink url="../classes/Joint.html">Joint</ulink> objects.  
</para>
<para>
There are several types of joints 
available&mdash;see each class' documentation for more details:
<itemizedlist>
<listitem><para><ulink url="../classes/FixedJoint.html">FixedJoint</ulink></para></listitem>
<listitem><para><ulink url="../classes/PrismaticJoint.html">PrismaticJoint</ulink></para></listitem>
<listitem><para><ulink url="../classes/RevoluteJoint.html">RevoluteJoint</ulink></para></listitem>
<listitem><para><ulink url="../classes/UniversalJoint.html">UniversalJoint</ulink></para></listitem>
<listitem><para><ulink url="../classes/BallJoint.html">BallJoint</ulink></para></listitem>
</itemizedlist>
</para>
</sect2>

<sect2 id="multibodies">
<title>The MultiBody class</title>
<para>
<indexterm><primary>MultiBody class</primary></indexterm>
A MultiBody is a single logical physically simulated agent, whether it is made up
of a single Link, or multiple Links joined together with Joint objects. 
</para>
<para>
<emphasis>The role of the MultiBody has changed drastically in breve 2.0 from 
previous versions of breve</emphasis>.  Previously, Link objects would not 
appear at all in the simulated world unless they were part of a MultiBody.  Now,
the use of MultiBodies is completely optional.
</para>
<para>
Keeping a set of Links bound together as a logical MultiBody unit allows the user to move or 
rotate the entire logical structure, as opposed to moving or rotating individual links.  
Imagine that suddenly your arm was moved across the room without the rest of your body
&mdash;in all likelihood, this would not make you very happy.  This is what it's like 
for the underlying physics engine to move a single link&mdash;confusing and painful things 
can happen.  By encompassing a set of connected Links within a MultiBody, the user has 
more logical control over the object.
<mediaobject><imageobject><imagedata align="center" fileref="images/MultiBody.jpg"></imageobject></mediaobject>
</para>
<para>
To create a MultiBody, you can simply associate it with any existing Link object.
The Link object you choose will be known as the <firstterm>root link</firstterm>,
and all other Links connected to the root link&mdash;directly or indirectly&mdash;will
become part of the MultiBody.  The MultiBody is automatically updated as joints are 
created and destroyed.
</para>
<para>
</para>
</sect2>
</sect1>

<sect1 id="dynamic_joints">
<title>Dynamically Creating and Destroying Joints</title>
<para>
<indexterm><primary>dynamic joints</primary></indexterm>
<indexterm><primary>breaking joints</primary></indexterm>
breve allows <ulink url="../classes/Joint.html">Joints</ulink> to 
be created and destroyed dynamically over the course of the simulation.  
</para>
<para>
Joining <ulink url="../classes/MultiBody.html">MultiBodies</ulink> dynamically is simple&mdash;you simply
link them as always using the various <ulink url="../classes/Joint.html">Joint</ulink> subclasses.
The joints can be made not only to modify the structure of a single MultiBody, but also
to join together distinct MultiBodies.
</para>
<para>
Breaking MultiBodies is accomplished using the <ulink url="../classes/Joint.html">Joint</ulink> 
method <ulink url="../classes/Joint.html#break">break</ulink>.  
</para>
<para>
Prior to <emphasis>breve</emphasis> version 2.0, when all Links had to be part of a MultiBody to appear 
in the simulated world, breaking joints were often accompanied by broken hearts: breaking a joint 
could cause entire subtrees of links to disappear into the ether because the links were orphaned.  
In <emphasis>breve</emphasis> 2.0, links will go on living happily even if they are not associated 
with a MultiBody.
</para>
</sect1>

<sect1 id="springs">
<title>Using Springs</title>
<para>
Documentation forthcoming.
</para>
</sect1>

<sect1 id="terrains">
<title>Using Terrains With Physical Simulation</title>
<para>
<indexterm><primary>terrain</primary></indexterm>
<indexterm><primary>fractal terrain</primary></indexterm>
The class <ulink url="../classes/Terrain.html">Terrain</ulink> allows fractal terrains to 
be created in breve.  These terrains provide a more realistic ground than simply using 
a flat plane.  The terrains can be automatically generated using the 
method <ulink url="../classes/Terrain.html#generate">generate</ulink>, or set 
manually by the user using the method 
<ulink url="../classes/Terrain.html#set-height">set-height</ulink>.  See 
the <ulink url="../classes/Terrain.html">Terrain</ulink> class documentation
for information on using terrains.
</para>
</sect1>

</chapter>
