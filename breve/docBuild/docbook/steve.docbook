<!--
    The breve Simulation Environment documentation
    Copyright (C) 2003 Jonathan Klein
-->

<chapter id="steve">
<title>"steve" Language Reference</title>
<para>
Simulations in breve are written using a language called "steve".  steve is a 
simple language which aims to allow rapid construction of advanced simulations
while avoiding a great deal of the programming overhead associated with 
constructing simulations in other languages.
</para>
<tip><title>Don't Be Overwhelmed!</title>
<para>
Writing simulations in steve is ultimately quite simple.  Due to the number of 
features provided by the simulation engine, however, this documentation may 
seem at times overwhelming.  Don't panic&mdash;make liberal use of the demo
simulations provided with the environment and don't be put off if some of 
the features discussed here are difficult to understand.  
</para>
</tip>
<para>
"steve" is an <firstterm>object-oriented</firstterm> 
<indexterm><primary>object-oriented programming</primary></indexterm>
language.  This means that
programming in "steve" involves working with components called 
<firstterm>objects</firstterm> which contain data 
(<firstterm>variables</firstterm>) and behaviors 
(<firstterm>methods</firstterm>).  In breve, objects can be either 
<firstterm>real</firstterm>, meaning they have a presence in the simulated 
world; or <firstterm>abstract</firstterm> meaning that they are used to store 
data or to perform computations, but do not appear in the simulated world.  
In order to define agents and their behaviors, one needs to construct these 
objects and behaviors using the "steve" language.  The language is described 
in this chapter.
</para>
<para>
First, the classic "Hello, World" program is constructed in steve 
(<xref linkend="hello-world">).  Then, a simple multiagent 3D simulation 
written in steve is presented (<xref linkend="simple-example">).  This 
sample should give the basic idea of what a breve simulation looks like.
</para>
<para>
As discussed above, all agents in the simulated world are represented by programming 
objects.  These objects are defined in terms of object templates called 
<firstterm>classes</firstterm>.  The most important object, called the 
<firstterm>Controller</firstterm> is described in the section The Controller Object 
(<xref linkend="controller-object">).  The section Building Classes 
(<xref linkend="building-classes">) describes how to construct basic classes in steve.
</para>
<para>
In order to define the data and behaviors of your classes, you'll need to be familiar
with types (<xref linkend="types">) and expressions (<xref linkend="expressions">).
The section Program Control Structures (<xref linkend="control-structures">) discusses
loops and conditional statements.
</para>

<sect1 id="hello-world">
<title>Hello, World</title>
<para>
<indexterm><primary>Hello, World!</primary></indexterm>
The traditional introduction to any programming language is a program 
which repeatedly prints out the text "Hello, World!".  Here it is written in steve:
<screen>
@include "Control.tz"           

Controller HelloWorld.

Control : HelloWorld {
	+ to iterate:
		print "Hello, world!".
}
</screen>
</para>
<para>
The specifics will be discussed in more detail through the rest of this 
chapter.  Briefly, we first declare the simulation's controller object to
be a class called <function>HelloWorld</function> (line 3).  Then we 
construct the <function>HelloWorld</function> class (lines 5-8), and 
as part of that class, we define a method called <function>iterate</function>
(line 6) which will print out the text "Hello, world!".  The "include"
line (line 1) simply tells breve to load in a file called "Control.tz", 
which is included with the breve distribution.  This built-in class file
contains the class control, which is the <firstterm>parent</firstterm>
class for our "HelloWorld" controller.
</para>
<para>
When this simulation is run, the controller object is created, and the 
method named <function>iterate</function> gets run automatically at every
step of the simulation.  Thus, "Hello, World!".  Ad nauseum.
</para>
</sect1>


<sect1 id="simple-example">
<title>A Simple Example</title>
<para>
"Hello, World" is a very simple example which can be used for any programming 
language.  It does not, however, give any insight into how 3D multiagent simulations 
are written in steve.  This section shows the code for a simple 3D multiagent 
simulation.  
<mediaobject><imageobject><imagedata align="center" fileref="images/random_walker.jpg"></imageobject>
<caption><para>In the <emphasis>RandomWalker</emphasis> demo, you can see 
a simple simulation containing hundreds of independent agents.</para></caption>
</mediaobject>
</para>
<para>
The simulation below is very heavily commented&mdash;all of the lines 
beginning with the # character are descriptive comments which do not effect 
the execution of the simulation, but clarify for the user what the simulation 
is doing.  Comments are described in more detail below.
</para>
<para>
The simple simulation below features a number of agents which perform a 
"random walk" through 3D space.  That is to say that at each time-step, 
the agents will move in a random direction.
</para>
<screen>
#
# RandomWalker is a simulation in which small spheres do
# a random walk.  This is a very simple simulation which
# can be used as a skeleton for more complex simulations.
#

# include some required breve class files
@use Control.
@use Mobile.

# First tell the breve engine the name of our controller class

Controller myControl.             

# Subclass "Control" and define our "myControl" object.

Control : myControl {
    # Here we define the class variables.  

    + variables:
        walkerShape (object).
        
    # Next we define a method called init.  The init method is called 
    # automatically when our class is created.  Since this is the controller
    # class, an instance gets created when we launch the simulation,
    # so this is the entry point for our simulation.
        
    + to init:
        print "Setting up the simulation.".

        self point-camera at (0, 0, 0) from (0, 60, 0).

        # set up a shape that all of the RandomWalker objects will use.
        
        walkerShape = (new Sphere init-with radius 1).
        
        # Create a bunch of RandomWalkers.  You can create as few or 
        # as many as you want... 

        200 new RandomWalker.

    # The get-walker-shape is a method that allows other objects 
    # to look at the walkerShape variable.  we do this so that 
    # each RandomWalker object can reuse the same Shape object.
    # This is not strictly required--each RandomWalker could create
    # it's own copy of the same Shape, but fewer objects means 
    # less memory used and more efficient simulations, so it's 
    # a good programming practice.
        
    + to get-walker-shape:
        return walkerShape.
}

# The "RandomWalker" object is the physical object in the simulation
# that does the random walk.  It is a subclass of "Mobile".

Mobile : RandomWalker {
    + to init:
        # During init, the object asks the controller for the shape 
        # it should use.  It then sets itself to a random color.

        self set-shape to (controller get-walker-shape).
        self set-color to random[(1.0, 1.0, 1.0)].
    
    + to iterate:
        # Set a new random velocity at every timestep.
        
        self set-velocity to random[(60, 60, 60)] - (30, 30, 30).
}
</screen>

<sect2>
<title>Comments</title>
<indexterm><primary>comments</primary></indexterm>
<indexterm><primary>#</primary></indexterm>
<indexterm><primary>#!</primary></indexterm>
<indexterm><primary>!#</primary></indexterm>
<para>
When writing code in any language, it is typically useful to include <firstterm>comments</firstterm> which clarify what the code is doing.  In steve, there are two ways to include comments in code.  A "single line" comment starts with a "#" is and continues to the end of the line; "multiline comments" are written starting with "#!" and ending with "!#".  Some example of both kinds of comments are shown below:  
<screen>
	# this is a simple one-line comment.

	print "this is not a comment..." 		# but this is.

	#!
		this
		is 
		a 
		multiline 
		comment
	!#
</screen>
</para>
</sect2>

</sect1>

<sect1 id="controller-object">
<title>The Controller Object</title>
<para>
<indexterm><primary>controller object</primary></indexterm>
The <firstterm>controller object</firstterm> is the foundation of a <emphasis>breve</emphasis>
simulation.  The controller object is a single instance which acts as the "boss" for the 
simulation.  When the simulation starts, it is the controller object which is responsible for 
creating and setting up the rest of the simulation.  <emphasis>The controller object is the 
only object which is automatically instantiated when the simulation begins</emphasis>.  
If you're used to programming in C or C++, the controller is like the <function>main</function>
function.
</para>
<para>
The first step in writing a <emphasis>breve</emphasis> simulation is to create a controller 
class which will setup and manage the simulation.  The controller class you create 
<emphasis>must be a subclass of the class <ulink url="../classes/Control.html">Control</ulink>
or one of its subclasses</emphasis>.  Details on how to do this is described in the rest of 
this chapter.
</para>
<para>
As shown in the previous section (<xref linkend="simple-example">), the controller object is
specified at the top of your simulation file using the word <emphasis>controller</emphasis>:
<screen>
Controller <replaceable>myControllerClass</replaceable>.
</screen>
This tells <emphasis>breve</emphasis> to create an instance of 
<replaceable>myControllerClass</replaceable> when the simulation begins.  This controller
object will create and setup the rest of the objects in the simulation.  The controller 
object does so by implementing the simulation setup code in the <function>init</function>
method.  Details on constructing classes and implementing an <function>init</function> method
are described in more detail in the rest of this chapter.
</para>
<para>
In addition to setting up the simulation, the controller object is also used as a liaison
between simulation objects, the <emphasis>breve</emphasis> engine and the user.  While
other instances may come and go, the controller object is forever.  The controller class
contains a great number of methods for controlling the behavior of simulations, the 
appearance of the graphical display and interactions with the user interface.  See the 
class documentation on <ulink url="../classes/Control.html">Control</ulink> for more 
information.  As with some of the other topics covered in this section, the significance 
of these concepts will become clearer in the rest of the documentation.
</para>
</sect1>

<sect1 id="building-classes">
<title>Building Classes</title>
<para>
<indexterm><primary>#</primary></indexterm>

All objects in the simulated world correspond to programming objects in steve.  
In order to define an agent in the simulated world, you'll start by 
constructing a programming object, or class.  This class will serve as a 
template which defines the agent's behaviors.  This section describes how to 
construct and use these classes.
</para>
<para>
The section Defining Classes (<xref linkend="defining-classes">) describes 
how to define an empty class.  
</para>
<para>
All classes have two major components: <firstterm>methods</firstterm>, which 
define a class's behavior and <firstterm>variables</firstterm> which define 
the data that the class can hold.  This data can be used both to store 
information about the state of the agent, or information required for 
computation.  The section Defining Instance Variables 
(<xref linkend="defining-instance-variables">) details how variables
can be added to objects, while the section Defining Class Methods 
(<xref linkend="defining-methods">) shows how method
are defined.  
</para>
<para>
Two special methods are critical for an agents behavior: one that 
gets called automatically when the agent is created, <function>init</function>, and another which is run automatically at every step of the simulation, 
<function>iterate</function>.  These methods, and a few other special methods 
are discussed in the section Special Method 
Names (<xref linkend="special-method-names">)
</para>
<para>
Even after the class is defined, it will still not be present in the 
simulation.  This is because a class is nothing more than a "template" for 
an agent.  In order to bring agents into the simulation, you must use the 
template to create <firstterm>instances</firstterm> 
<indexterm><primary>instance</primary></indexterm>
of the class.  The section on Creating and Destroying 
Instances (<xref linkend="creating-destroying-instances">) describes how 
instances of classes are created and destroyed.  
</para>
<sect2 id="defining-classes"><title>Defining Classes</title>
<para>
<indexterm><primary>subclass</primary></indexterm>
<indexterm><primary>aka</primary></indexterm>
<indexterm><primary>alias</primary></indexterm>
When building a class, you typically don't start from scratch&mdash;instead,
you make the new class the child of an existing class.  This is called 
creating a <firstterm>subclass</firstterm>.  By subclassing a class, the 
new class will inherit all of the parent's methods and variables.  This 
approach means that most of the difficult work will already be done
by an existing breve class, and we can simply override and customize the
behaviors that we need to.
</para>
<para>
For example, if we're building an object which will move through the 3D world,
we'd like to have an object that understands the relationship between 
position, velocity and acceleration.  Instead of implementing such a class
ourselves, we can subclass <ulink url="../classes/Mobile.html">Mobile.tz</ulink>
which is included with breve.  Our custom subclass will contain the custom
behaviors we desire, while the parent class takes care of the details.
</para>
<para>
When building a class, you must first decide the class name and its 
parent class.  The parent class is the class from which the new class will 
inherit its behaviors.  Classes which are to be used primarily for 
computation and do not require any special inherited behaviors, will typically 
use the generic root class <ulink url="../classes/Object.html">Object</ulink>.
Classes which move around the world will inherit behaviors from 
<ulink url="../classes/Mobile.html">Mobile</ulink>, while immobile objects
in the world will inherit behaviors from 
<ulink url="../classes/Stationary.html">Stationary</ulink>.  A full list
of classes is available in the appendix (<xref linkend="classes">).
</para>
<para>
An empty class is simply defined by the following steve code:
<screen>
<replaceable>parent_class_name</replaceable> : <replaceable>class_name</replaceable> {

}
</screen>
Because we often deal with classes in their plural form (like when creating multiple
instances of an object), it can be useful to give a class an alias which will allow
us to refer to the class in its plural form.  <emphasis>This is not required</emphasis>
but may make code easier to read.  This alias is defined by adding the text 
<function>(aka <replaceable>alias_name</replaceable>)</function> after the class name.
</para>
<para>
As an example of defining a class, both with and without an alias, consider a class
called <function>myMobile</function> which will be a child of the class 
<function>Mobile</function>:
<screen>
# first without the alias...

Mobile : myMobile {

}

# now with the alias...

Mobile : myMobile (aka myMobiles) {

}
</screen>
</para>
<para>
This code above defines an empty class with no variables and no methods.  This means 
that it will behave exactly as its parent class does.  The next step is to customize
the class' behavior by adding in methods and variables.
</para>
</sect2>

<sect2 id="defining-instance-variables"><title>Defining Instance Variables</title>
<para>
<indexterm><primary>instance variable</primary></indexterm>
An <firstterm>instance variable</firstterm> 
is a variable associated with a class.  Each
instance of the class will have it's own private copies of the class' instance variables.
</para>
<para>
Once the empty class declaration has been written, variables can be added using the 
heading <function>+ variables</function>, followed by the list of instance variables.
Variables are listed in the format 
<function><replaceable>variable_name</replaceable> (<replaceable>variable_type</replaceable>).</function>
</para>
<para>
The variable name must start with a letter, but afterwords may contain any alphanumeric characters, as well as the characters _ and -. 
</para>
<para>
Multiple variables of the same type can also be declared on the same line: 
<screen>
    <replaceable>variable1</replaceable>, <replaceable>variable2</replaceable>, <replaceable>variable3</replaceable>, ... (<replaceable>variableType</replaceable>). 
</screen>
Variable types are covered in detail in the section Types (<xref linkend="types">).
</para>
<para>
As an example, we'll add some variables to the simple class we created in the previous
section:
<screen>
Mobile : myMobile {
	+ variables:
		myInt, myOtherInt (int).
		myObject (object).
		myFloat (float).
}
</screen>
</para>
</sect2>

<sect2 id="defining-methods"><title>Defining Methods</title>
<para>
<indexterm><primary>keyword</primary></indexterm>
<indexterm><primary>method definition</primary></indexterm>
<indexterm><primary>+ to</primary></indexterm>
The most simple method call in steve is a call to a method which takes no arguments.  The definition of such an method is simple.  Inside the  definition of instanceName, we create a line: 
<screen>
+ to <replaceable>methodName</replaceable>:
</screen>
The statements which follow this line will be part of the newly defined method until either the end of the object definition, or until the next method definition. 
</para>
<para>
To define an method which takes arguments we will need the keyword, 
variable name and type of each argument.  The keyword identifies the variable 
when it is being called, while the variable name is how the variable will be 
referenced from within the method.   Finally, the type is simply the type of 
variable that will be passed in.  The layout of this information is 
<function><replaceable>keyword</replaceable> <replaceable>variable_name</replaceable> (<replaceable>type</replaceable>)</function>, such that a method which 
takes one 
variable could be defined by the following line: 
<screen>
+ to set-velocity to-value theValue (float):
</screen>
If the method takes two variables, we add another keyword/name/type triplet:   
<screen>
+ to set-rotation of-joint theJoint (Object) to-value theValue (float):
</screen>
</para>
<para>
The code associated with the second method would then use the variables 
<function>theJoint</function> and <function>theValue</function>: "of-joint" 
and "to-value" are not actual variables, but instead the keywords which 
indicate which variables follows. 
</para>
<para>
The calling convention of these methods is simple.  After the instance name 
and  method name, we give a list of keywords and values to be passed in.  
The order of the keyword/value pairs does not affect how the code is 
executed, though it may effect the readability of the code.  The following 
lines call the <function>set-rotation</function> method which we defined above: 
<screen>
# the following lines are equivalent

myObject set-rotation of-joint myJoint to-value 200.
myObject set-rotation to-value 200 of-joint myJoint.
</screen>
</para>
<para>
Methods may also have local variables associated with them.  These variable 
definitions look just like class variable definitions, except that they follow 
after the method definition line, and not after the variable definition line. 
Method variables are automatically initialized to zero every time the method 
is called.  Variable declarations in a method must precede all statements in 
the method. 
</para>
<para>
For example, here is a simple method which uses local variables: 
<screen>
+ to find-closest-creature in creatureList (list):
	item (object).
	closestItem (object).
	distance (float).

	# we start with a unreasonably high "closestDistance" so that 
	# we are sure to find something closer.

	closestDistance = 1000000.

	foreach item in creatureList: {
		distance = |(self get-location) - (item get-location)|.

		if distance < closestDistance: {
			closestItem = item.
			closestDistance = distance.
		}
	}

	return closestItem.
</screen>
</para>
<note><title>For developer use only</title>
<para>
When examining the internal classes included with the breve distribution, you might 
notice some methods defined using a minus sign instead of a plus sign: 
<screen>
- to methodName:
</screen>
This syntax simple means that the method should be treated as a non-public method 
and that the method should not be documented.  Though these methods function as all 
other methods, their use in user simulations is discouraged. 
</para>
</note>
</sect2>

<sect2 id="optional-arguments"><title>Optional Arguments in Methods</title>
<indexterm><primary>instance variable</primary></indexterm>
<para>
Methods definitions may also specify <firstterm>optional arguments</firstterm>.  Optional
arguments are arguments which are given default values, and therefore do not need to be 
provided when calling the method.  Optional arguments can greatly simplify writing code
in steve.
</para>
<para>
To make an argument optional, you need to provide it with a default value.  To do so,
you'll need to modify the argument definition to include the text <function>= <replaceable>value</replaceable></function>
after the argument name.  For example, a variable called <function>theHeight</function> with keyword
<function>with-height</function> could be given a default value like this: <function>with-height theHeight = 100 (int)</function>.
Default values for optional arguments must be literal values (and not expressions or variables).
</para>
<para>
Below is an example of a method defined with a set of optional arguments.
<screen>
	# Create a new agent, with some default values.

	+ to create-new-agent with-color color = (1, 0, 0) (vector) 
		with-energy energy = 100 (int)
		with-radius radius = 10 (int) 
		with-name name = "agent" (string):
</screen>
</para>
<para>
The method above could be called in a number of ways, optionally including or 
excluding each of the arguments:
<screen>
	# no arguments 
	self create-new-agent.

	# some of the arguments 
	self create-new-agent with-energy 10 with-name "Becky".

	# all of the arguments
	self create-new-agent with-color (1, 1, 1) 
		with-energy 100
		with-radius 20
		with-name "Robert".
</screen>
</para>
</sect2>

<sect2 id="special-method-names"><title>Special Method Names</title>
<para>
Certain method names have special meaning in steve, in that they are called automatically
by the simulation at special times.  These methods, in particular <function>init</function>
and <function>iterate</function> are critical, as they are the entry-point into how your
agents are initialized and how they will behave.  These special method names are outlined
below:
</para>
<itemizedlist>
<listitem>
<para>
<indexterm><primary>init (special method)</primary></indexterm>
<function>init</function>, if it exists, is called automatically when a class is instantiated.  The method is called not only for the class being instantiated, but also for its superclass and all other ancestors  up to the root object.  Though you should implement an init method for your class which will set up the instance when the class is instantiated, the init method should never be called manually.  
</para>
</listitem>
<listitem>
<para>
<indexterm><primary>iterate (special method)</primary></indexterm>
<function>iterate</function>, if it exists, is called automatically during every iteration of the breve engine.  If your class must perform a task during each iteration, then you may choose to implement an iterate method.  The order in which the objects in  the simulation are iterated cannot be controlled&mdash;if you need to control the order in which actions are performed, consider using iterate in conjunction with the post-iterate method described below. 
</para>
<para>
Unlike the <function>init</function> and <function>destroy</function> methods, <function>iterate</function> is not automatically called for the  superclasses of an instance.  This means that your iterate method must call super iterate if you wish to incorporate the parent's iterate method.  This is absolutely necessary for subclasses of Control. 
</para>
</listitem>
<listitem>
<para>
<indexterm><primary>post-iterate (special method)</primary></indexterm>
<function>post-iterate</function>, if it exists, is called automatically during every iteration of the breve engine after the iterate methods for all objects have been called.   It is occasionally desirable to perform an action during each iteration, which  requires data produced during that very same iteration from other objects.  If this action is to be performed in the iterate method, than object A cannot be certain that  object B has been iterated yet (and vice-versa).  To solve this problem, objects  may implement a post-iterate method which is automatically called after all  objects have been iterated.  The PatchLife demo uses this technique. 
</para>
</listitem>
<listitem>
<para>
<indexterm><primary>destroy (special method)</primary></indexterm>
<function>destroy</function>, if it exists, is called automatically when a class is being freed.  However, unlike init, and like iterate, you must explicitly call the super class destroy method if you need it to be called as well.  If your class needs to perform certain tasks before being destroyed, you should implement this method.  Be warned the you need to be carefull not to free an object referenced in the base class if it is needed for the base class destroy method.
</para>
</listitem>
</itemizedlist>
</sect2>

<sect2 id="creating-destroying-instances"><title>Creating and Destroying Instances</title>
<para>
Creating a new instance of an object is called instantiating the object. Instantiating in steve is done using the new command.  Instantiation  creates a single new instance if no number is given, or as many objects as you want by preceding the command with a number.  The syntax follows: 
<screen>
new object_type.
number new object_type.
</screen>
</para>
<para>
 If a single object is created, it is returned as an object type.  If several are created, they are returned as a list.  For example: 
</para>
<para>
<screen>
myBird (object).
myBugs (list).

myBird = new Bird.
myBugs = 100 new Bugs.
</screen>
</para>
<para>
The method init is called automatically for a class and all of its superclasses when the class is instantiated. 
</para>
<para>
Destroying instances is simply accomplished using the command <function>free</function>: 
<screen>
free instance.
</screen>
<function>free</function> accepts both single instances and lists of instances. 
</para>
<para>
If an instance frees itself, then execution of the code is stopped immediately, as though the <function>free</function> command
was followed by a <function>return</function>.
</para>
<para>
When an object is freed, the <function>destroy</function> method is automatically called for the 
instance.  Prior to version 1.9, <function>destroy</function> would automatically be called for 
all superclasses.  This is no longer the case&mdash;you must call "super destroy" if you wish for
the superclass destroy method to be run.
</para>
</sect2>

</sect1>

<sect1 id="types">
<title>Types in "steve"</title>
<indexterm><primary>types</primary></indexterm> 

<sect2 id="int"><title>The <function>int</function> type</title>
<para>
An <function>int</function>
<indexterm><primary>int (type)</primary></indexterm> 
is a whole number, identical to the <function>int</function> type in C. 
</para>
<sect3><title><function>int</function> operators</title>
<para>
ints can be operated on using the following mathematical operators, which operate just 
like their C counterparts:  +, -, *, /, % and ^ (power).  Divisions or mods by zero are 
treated as errors and will stop the execution of the simulation.  The absolute value of 
an integer is given by | <replaceable>integer expression</replaceable> |.
</para>
</sect3>
<sect3><title>Conversions to Other Types</title>
<para>
ints can be converted to floats automatically in expressions or during assignments, but
cannot be converted to any other type.
</para>
</sect3>
</sect2>


<sect2 id="float"><title>The <function>float</function> type</title>
<para>
<indexterm><primary>float (type)</primary></indexterm> 
<indexterm><primary>double (type)</primary></indexterm> 
A real number, also known as "double", identical to the <function>double</function> type in C.  Internally,
floats are represented by 8-byte doubles.
</para>
<sect3><title><function>float</function> Operators</title>
<para>
All of the operators used for ints&mdash;including %&mdash;can also be applied to floats. 
</para>
</sect3>

<sect3><title>Conversions to Other Types</title>
<para>
<function>floats</function> can be converted to (and from) <function>ints</function> automatically 
in expressions or assignments.  <function>floats</function> cannot be converted to any other type. 
</para>
</sect3>
</sect2>

<sect2 id="object"><title>The <function>object</function> Type</title>
<para>
<indexterm><primary>object (type)</primary></indexterm> 
An <function>object</function> is an <emphasis>instance</emphasis> of a steve class.  
</para>
<sect3><title><function>object</function> Operators</title>
<para>
<function>objects</function> cannot used in mathematical expressions as some of the other types can.
Instead, <function>objects</function> are mainly used for one type of expression: method calling.
Method calling is outlined in the section Method Calls (<xref linkend="method-calls">).
</para>
</sect3>
<sect3><title>Conversion to Other Types</title>
<para>
Objects cannot be explicitly converted to other types.  
They do, however, have meaning as "boolean" (true or false) expressions in control
structures (<xref linkend="control-structures">).  If used in the context of a 
boolean expression (like an <function>if</function> statement,
<xref linkend="if">), the expression is true only if the variable refers to an 
active object.  This means that an object variable which has not yet been 
associated with an instance in the simulation is false.
</para>
</sect3>
</sect2>

<sect2 id="vector"><title>The <function>vector</function> Type</title>
<para>
<indexterm><primary>vector (type)</primary></indexterm> 
 A vector is used to represent a point or vector in 3D space. A vector is expressed as three floating point numbers, such as (1.0, 2.0, 5.0). 
</para>
<sect3><title><function>vector</function> Operators</title>
<indexterm><primary>vector components, setting and extracting</primary></indexterm> 
<indexterm><primary>vector operators</primary></indexterm> 
<para>
Vectors may be added (+) to and subtracted (-) from other vectors, which yields another vector.
Vectors may be multiplied (*) or divided (/) by ints or floats, which also results in other vectors.
The length of the vector is given using the following construct: | <replaceable>vector expression</replaceable> |. 
</para>
<para>
Some examples of using vectors follow:
<screen>
v = (1, 2, 3).  # sets the vector to a constant vector.

v = v * 4.      # multiplies the vector by 4

v = v / |v|.    # normalizes the vector by dividing it by it's own 
				# length such that the new length is 1.
</screen>
</para>
<para>
Individual vector components can be extracted or set using the following notation:
<screen>
xValue = myVector::x.

myVector::y = 100.
</screen>
</para>

</sect3>

<sect3><title>Conversions to Other Types</title>
<para>
Vectors cannot be converted to any other types.  
They do, however, have meaning as "boolean" (true or false) expressions in control 
structures (<xref linkend="control-structures">).  If used in the 
context of a boolean expression (like an <function>if</function> statement,
<xref linkend="if">), the vector will be true if it's length is greater
than 0, and false if its length is equal to 0.  This is to say that only 
the vector (0, 0, 0) is false in a boolean context.
</para>
</sect3>


</sect2>

<sect2 id="matrix"><title><function>matrix</function></title>
<para>
<indexterm><primary>matrix (type)</primary></indexterm> 
A <firstterm>matrix</firstterm> in steve refers to a 3x3 matrix which 
describes a transformation in 3D space.  Using transformation matrices is somewhat advanced 
and they are not generally used in most simulations.  Still, they may be useful when dealing
with physical simulation.
</para>
<para>
Matrices may be written in steve as three comma-separated vectors, enclosed in braces ('[' and ']'), 
as in this example: 
<screen>
# the matrix m will be initialized to:
#
# [ 1 2 3 ]
# [ 4 5 6 ]
# [ 7 8 9 ]

m = [ (1, 2, 3), (4, 5, 6), (7, 8, 9) ].
</screen>
</para>
<sect3><title><function>matrix</function> Operators</title>
<para>
Matrices may be multiplied (*), divided (/), added (+) to and subtracted (-) from other matrices. 
The results of these operations are other matrices. 
</para>
<para>
Matrices may be multiplied (*) or divided (/) by scalars (ints and doubles).  The result of these 
operations are other matrices. 
</para>
<para>
Matrices may be used to transform vectors by multiplying the matrix times the vector (*).  The 
result of this operation is a vector. 
</para>
<para>
</para>
</sect3>

<sect3><title>Conversions to Other Types</title>
<para>
Matrices cannot be converted to any other types.
They do, however, have meaning as "boolean" (true or false) expressions in control 
structures (<xref linkend="control-structures">).  If used in the 
context of a boolean expression (like an <function>if</function> statement,
<xref linkend="if">), the expression will be true if there are any non-zero values 
in the matrix.  This means that a matrix of all zeros will be false, while all 
other matrices are true.
</para>
</sect3>
</sect2>

<sect2 id="list"><title>The <function>list</function> Type</title>
<para>
<indexterm><primary>list (type)</primary></indexterm> 
The <function>list</function> datatype allows you to keep a list of other variables.  
lists can contain any datatype, including other lists.  lists can even contain multiple 
datatypes simultaneously.   
</para>
<para>
<function>lists</function> are formed using the syntax 
<function>{ <replaceable>item1</replaceable>, <replaceable>item2</replaceable>, <function>...</function> }</function>.   
</para>
<para>
Some simple examples of constructing <function>lists</function> are shown below: 
<screen>
myList = { 1, 2, 3.0 }.                 # a list of numbers (both int and float)
myList = { "a", "b", "c" }.             # a list of strings
myList = { "a", 30, new Mobile }.       # a list of mixed types
myList = { 1, "a", { "dog", "cow" } }.  # a list with a nested list
</screen>
</para>

<sect3 id="list-operators"><title><function>list</function> Operators</title>
<indexterm><primary>operators</primary><secondary>list</secondary></indexterm> 
<indexterm><primary>list operators</primary><secondary>push</secondary></indexterm> 
<indexterm><primary>list operators</primary><secondary>pop</secondary></indexterm> 
<indexterm><primary>list operators</primary><secondary>insert</secondary></indexterm> 
<indexterm><primary>list operators</primary><secondary>remove</secondary></indexterm> 
<indexterm><primary>list operators</primary><secondary>prepend</secondary></indexterm> 
<indexterm><primary>list operators</primary><secondary>unprepend</secondary></indexterm> 
<indexterm><primary>list operators</primary><secondary>sort</secondary></indexterm> 
<indexterm><primary>list operators</primary><secondary>copylist</secondary></indexterm> 
<indexterm><primary>list operators</primary><secondary>length</secondary></indexterm> 
<para>
The following operations can be used with <function>list</function> expressions:
<itemizedlist>

<listitem>
<para><function>insert <replaceable>expression</replaceable> at <replaceable>list</replaceable>{ <replaceable>index</replaceable> }</function>: inserts <replaceable>expression</replaceable> at the specified index in the list, shifting up other list elements with higher indices</para>
</listitem>

<listitem>
<para><function>remove <replaceable>list</replaceable>{ <replaceable>index</replaceable> }</function>: removes the element of <replaceable>list</replaceable> at the specified index and returns it, shifting down other list elements with higher indices</para>
</listitem>

<listitem>
<para><function>push <replaceable>expression</replaceable> onto <replaceable>list</replaceable></function>: appends <replaceable>expression</replaceable> onto the end of list</para>
</listitem>

<listitem>
<para><function>pop <replaceable>list</replaceable></function>: removes the last element of <replaceable>list</replaceable> and returns it</para>
</listitem>

<listitem>
<para><function>prepend <replaceable>expression</replaceable> onto <replaceable>list</replaceable></function>: prepends <replaceable>expression</replaceable> onto the start of <replaceable>list</replaceable></para>
</listitem>

<listitem>
<para><function>unprepend <replaceable>list</replaceable></function>: removes the first element of <replaceable>list</replaceable> and returns it</para>
</listitem>

<listitem>
<para>
<function><replaceable>list</replaceable>{ <replaceable>expression</replaceable> }</function>: returns the element of the list at offset  expression.  The expression index is zero based, as in C, such that 0 refers  to the first element, 1 to the second, and so forth.  If the offset expression is  less than zero, or greater than the length of the list minus one (because the access  is zero based), an error is triggered and the simulation is stopped. 
</para>
</listitem>

<listitem>
<para>
<function><replaceable>list</replaceable>{ <replaceable>expression</replaceable> } = <replaceable>value</replaceable></function>: sets an element of the list at  offset expression to value.  The offset index is again zero based.  If the  offset expression is less than zero or greater than the size of the list an error is  triggered and the simulation is stopped.  If the offset expression is equal to the size  of the list, the list is extended by one element; the operation has the same effect as  pushing a value on to the end. 
</para>
</listitem>

<listitem>
<para>
<function>sort <replaceable>list</replaceable> with <replaceable>method-name</replaceable></function>: sorts <replaceable>list</replaceable> using the method specified with <replaceable>method-name</replaceable>.  <replaceable>method-name</replaceable> must be a method which takes two list elements (the keywords are unimportant) and compares them, returning a negative number if the first list element belongs before the second in the sorted list, a positive number if the second  belongs before the first, and 0 if the two entries are equal.  In most cases, this confusing sounding method returns a certain value associated with one argument minus the same value in the other. 
</para>
<para>
Unlike the perl sort operator, <function>sort</function> operates on the list it is given and does  not return a copy of it.  This means that the original list is modified during the  sort operation. 
</para>
</listitem>

<listitem>
<para>
<function>copylist <replaceable>list</replaceable></function>: copies the entire list.  Normally, assigning 
a list to a variable will <emphasis>not</emphasis> copy the list but instead will yield two variables pointing 
to the <emphasis>same</emphasis> list. 
</para>
</listitem>

<listitem>
<para>
<function>| <replaceable>list</replaceable> |</function>: gives the length of a list.  Lists are automatically 
converted to integers when use in mathematical expressions, but this construct can be used too force the 
conversion.
</para>
</listitem>

</itemizedlist>
</para>
</sect3>

<sect3><title>Conversions to Other Types</title>
<para>
<function>lists</function> can be converted to <function>ints</function> simply by 
using them in the context of integers.  They can thus also be used as 
<function>floats</function>.  In the event that the context of the expression does
not force the list to become an integer, you can force it yourself 
by using it in a mathematical context:
<screen>
myInt = (myList + 0).
</screen>
</para>
</sect3>
</sect2>
<sect2 id="string"><title>The <function>string</function> Type</title>
<indexterm><primary>string (type)</primary></indexterm> 
<para>
The string type holds a character string.  A string is written in code (as in C) as
a quoted string.  For example, the built-in print operator is capable of printing strings:
<screen>
print "this is a string".
</screen>
</para>

<sect3><title><function>string</function> Operators</title>
<para>
<itemizedlist>
<listitem>
<para>
<function><replaceable>string</replaceable> { <replaceable>index</replaceable> }</function>: returns, as a string, the letter at the specified index.
</para>
</listitem>

<listitem>
<para>
<function><replaceable>string</replaceable> { <replaceable>index</replaceable> } = <replaceable>otherString</replaceable></function>: replaces the letter at the specified location with the string <replaceable>otherString</replaceable>.
</para>
</listitem>

<listitem>
<para>
<function>| <replaceable>string</replaceable> |</function>: returns the length of the string.
</para>
</listitem>
</itemizedlist>

In addition to the operators listed above, simple variables can be embedded 
strings so that the strings are interpreted dynamically, as in language 
like Perl.  To indicate a variable embedded in a string, use the "$" 
character.  The following, for example, will use the variable "self" in order 
to build a string to be printed:
<screen>
print "my value is $self.".
</screen>
</para>
</sect3>

<sect3><title>Conversions to Other Types</title>
<para>
strings can be converted to <function>ints</function> and <function>floats</function>, 
but not to any other types.
types.
</para>
<para>
In the context of an int or a float, the string becomes the appropriate
type by taking the numerical component of the string. For more information
on this conversion, consult the man pages for the ANSI C 
<function>atoi()</function> (for <function>ints</function>) or 
<function>atof()</function> (for <function>doubles</function>) functions.
</para>
</sect3>

</sect2>

<sect2 id="hash"><title>The <function>hash</function> Type</title>
<para>
<indexterm><primary>hash (type)</primary></indexterm> 
A hash is a type which works like a dictionary: it allows expressions ("values") to be 
stored and looked-up using other expressions as the "keys".  The following example shows a 
steve hash being used like a dictionary:
<screen>
dictionary (hash).

dictionary{ "dog" } = "a four-legged pet".
dictionary{ "fish" } = "a zero-legged pet".

# this will print the definition we stored above.

print "the definition of dog is: ", dictionary{ "dog" }.
</screen>
</para>
<para>
As shown in this example, we're able to store data using strings as the keys.  When
data is later retrieved from the hash table using the same key, the value stored 
previously is returned.
</para>
<para>
hashes are not limited to using strings as keys.  They can use any valid
type.  The most useful application is a hash table which uses objects as keys.  In
this way, relationships between objects can be stored in a hash.  Consider an object
which wants to keep track of neighbors it has encountered previously:
<screen>
# let's say that this method gets called when a neighbor is seen...
# if the neighbor has already been seen, print a message &mdash; otherwise,
# just add it to the hash for next time!

+ to meet with neighbor (object):
	if seenHash{ neighbor }: print "i've seen this neighbor before!"
	else seenHash{ neighbor } = 1.
</screen>
</para>
<para>
The example above also shows that the syntax of hashes is the same as the syntax
for lists when storing or retrieving data.  Unlike lists, however, hashes do not
hold ordered data, and none of the other list operators work with hashes.
</para>
<para>
When using hashes with ints, floats, vectors, matrices and strings, then steve
will test the equivalence of the key when looking up or storing the data.  This 
means that two equivalent strings, even if they are stored in different variables,
will refer to the same value in the hash.  For the other types (objects, pointers, 
data, lists and hashes themselves), the hash will only return the same value for 
the same exact variable key.  This means that two different lists, even if they 
contain "equal" data, will access different values in the hash.
</para>

<sect3><title><function>hash</function> Operators</title>
<para>
A list of the keys in a hash may be retrieved using the built-in function <function>keys</function>.
This key list is often used to iterate through the items in a hash:
<screen>
foreach key in keys( myHash ): {
	print myHash{ key }.
}
</screen>
</para>
</sect3>

<sect3><title>Conversion to Other Types</title>
<para>
hashes cannot be converted to any other types.  
</para>
</sect3>
</sect2>

<sect2><title>The <function>pointer</function> Type</title>
<note><title>For developer use only</title>
<para>
<indexterm><primary>pointer (type)</primary></indexterm> 
The <function>pointer</function> type is for use by breve and plugin developers only.
</para>
</note>
<para>
pointer variables store C-style pointers to internal data.  They are 
not used for writing simulations in steve and are only used by breve
developers and plugin authors.  
</para>
<para>
pointer variables are only useful in the context of interacting with 
internal C-style function calls: they do not contain methods, variables 
or any other meaning in the context of most steve code.  Like objects, 
however, pointers can be tested to see if they are NULL (0), 
but cannot be used in mathematical expressions.  That is to say that
pointers have a meaning in a boolean context of control structures 
such as <emphasis>if</emphasis> and <emphasis>while</emphasis> (as well as the logical operators
<emphasis>&&</emphasis> and <emphasis>||</emphasis>).
</para>
<para>
Copying a pointer (assigning it to another variable), as in C, will not copy the data is points to.
</para>

<sect3><title>Conversion to Other Types</title>
<para>
pointers cannot be converted to any other types.
</para>
</sect3>

</sect2>

<sect2 id="data"><title>The <function>data</function> Type</title>
<note><title>For developer use only</title>
<para>
The <function>data</function> type is for use by breve and plugin developers only.
</para>
</note>
<para>
<indexterm><primary>data</primary></indexterm> 
<function>data</function> variables are similar to pointer variables 
in that they contain a reference to internal data.  Also like 
pointer variables, they are not to be used in regular simulation
code&mdash;they are only to be used by breve developers and custom plugins.
</para>
<para>
The different between <function>data</function> and <function>pointer</function> is that 
<function>data</function> refers to a linear block of internal data of known size.  This 
means that <function>data</function> variables can be successfully archived, while pointers
cannot.  <emphasis>The only use for <function>data</function> variables is archiving 
and dearchiving internal data</emphasis>.  For more information on using the 
<function>data</function> type with plugins, see the section on 
Archiving Plugin Data With The <function>data</function> Type (<xref linkend="archiving-data">).
</para>
</sect2>

<sect2 id="array"><title>Arrays of other types</title>
<para>
<indexterm><primary>arrays</primary></indexterm>
Arrays can be used to group several variables of the same type.  Use of arrays is now 
deprecated: use lists (<xref linkend="list">) instead.
</para>
</sect2>
</sect1>

<sect1 id="expressions">
<title>Expressions</title>

<sect2>
<title>Special variables and values</title>
<para>
Certain variables have special meanings in steve.  Their values are managed
automatically by the breve engine and should not be assigned manually.
</para>

<itemizedlist>
<listitem>
<para>
<function>self (object)</function>.
</para>
<para>
<indexterm><primary>self</primary></indexterm>
This variable always contains the value of the instantiation in which the  current method is being run.  The variable is used most frequently to call other methods within the same instantiation.  For example, an object of  class Mobile could move itself with the call: 
<screen>
    self move to (10, 10, 10).
</screen>
</para>
</listitem>

<listitem>
<para>
<function>super (object)</function>.
</para>
<para>
<indexterm><primary>super</primary></indexterm>
This special value refers to the parent, or super-instance.  This is used to invoke a parent class
implementation of a method, instead of the current class implementation.
</para>
<para>
For example, in the Controller's iterate method, the superclass iterate method is often called: super iterate.  This is because custom subclasses of Control typically preform simulation specific tasks, but must then call on the superclass implementation (Control) to actually step the physical simulation forward and update the state of the world.  Anytime you wish to implement a custom object behavior <emphasis>in addition</emphasis> a parent class behavior, you should invoke the parent class method as well.
</para>
</listitem>

<listitem>
<para>
<function>controller (object)</function>.
</para>
<para>
<indexterm><primary>controller variable</primary></indexterm>
The controller variable is defined for all instances.  It always refers to the simulation's 
controller instance.  
</para>
</listitem>

</itemizedlist>

</sect2>

<sect2>
<title>Assignments</title>
<para>
<indexterm><primary>operators</primary><secondary>assignment (=)</secondary></indexterm>
<indexterm><primary>assignment</primary></indexterm>
The most simple expressions are simple assignments of literal values to variables. It may help to refer to the documentation on steve types before continuing. 
</para>
<para>
Below are a few examples of this type of expression.  In each case, the variable on the  left will take the value of the expression on the right.  If the expression on the right is not the correct type, it will be automatically converted if possible.  If  the conversion is not possible, an error will occur. 
</para>
<para>
<screen>
myInt = 4.
myDouble = 12.345.
myString = "Hello!".
    
# If we assign a double to an int, it will be automatically converted by 
# truncating the decimal portion.  In this example, myInt will take the value 
# 4:  
    
myInt = 4.8.
    
# Likewise if we assign a string to a double or int.  The variable will take 
# the number value of the string, according to the atoi() or atof() ANSI C 
# functions.  Here the double will get the value 10000: 
     
myDouble = "10000 miles away.".
</screen>
</para>
</sect2>

<sect2>
<title>Mathematical Expressions</title>
<para>
Mathematical operators in steve function almost exactly the same as they do 
in C, although there are some additions to account for vector and matrix 
types. 
</para>
<para>
The following binary operators are valid for <function>int</function> and 
<function>double</function> types (the descriptions refer to x and y, as 
though they were used in an expression: 
<function>x <replaceable>operator</replaceable> y</function>): 
<indexterm><primary>operators</primary><secondary>mathematical</secondary></indexterm>
<indexterm><primary>mathematical operators</primary><secondary>addition (+)</secondary></indexterm>
<indexterm><primary>mathematical operators</primary><secondary>subtraction (-)</secondary></indexterm>
<indexterm><primary>mathematical operators</primary><secondary>multiplication (*)</secondary></indexterm>
<indexterm><primary>mathematical operators</primary><secondary>division (/)</secondary></indexterm>
<indexterm><primary>mathematical operators</primary><secondary>modulus (%)</secondary></indexterm>
<indexterm><primary>mathematical operators</primary><secondary>power (^)</secondary></indexterm>
<itemizedlist>
<listitem><para><function>+</function>, addition</para></listitem>
<listitem><para><function>-</function>, subtraction</para></listitem>
<listitem><para><function>*</function>, multiplication</para></listitem>
<listitem><para><function>/</function>, division</para></listitem>
<listitem><para><function>%</function>, modulus (the remainder of x when divided by y)</para></listitem>
<listitem><para>^, power (x raised to the power of y)</para></listitem>
</itemizedlist>
</para>
<para>
Their functions should be self-explanatory, with the possible exception of modulus, which cannot be used with double types in C.  When used with doubles, the result is calculated using the ANSI <function>fmod()</function> function. 
</para>
<para>
The following operators are valid for use with two vectors:  
<itemizedlist>
<listitem><para><function>+</function>, vector addition</para></listitem>
<listitem><para><function>-</function>, vector subtraction</para></listitem>
</itemizedlist>
</para>
<para>
The following operators are valid for a vector and a double (although an 
<function>int</function> is automatically promoted to a double in this case):  
<itemizedlist>
<listitem><para><function>*</function>, vector times scalar multiplication</para></listitem>
<listitem><para><function>/</function>, vector divided by scalar division</para></listitem>
</itemizedlist>
</para>
<para>
As in many languages, parenthesis are used to group expressions when the 
default order of operations does not compute the desired result: 
<screen>
# this is the default order, but we can make it explicit with parens
x = x + (4 / y).                    # computes 4 / y first...

# this is NOT the default order -- we need to force it
x = (x + 4) / y.                    # computes x + 4 first
</screen>
</para>
<para>
Mathematical expressions are often used in conjunction with assignments in 
order to modify the value of a variable.  A few examples of using 
mathematical expressions in conjunction with assignments follow: 
<screen>
    x = x + 4.

    y = (1, 2, 3) / x.                  # assumes x is an int or double

    z = z + x^2.
</screen>
</para>

</sect2>

<sect2>
<title>Mathematical Assignment Expressions</title>
<para>
<indexterm><primary>operators</primary><secondary>mathematical assignment operators</secondary></indexterm>
<indexterm><primary>mathematical assignment operators</primary><secondary>add-assign (+=)</secondary></indexterm>
<indexterm><primary>mathematical assignment operators</primary><secondary>subtract-assign (-=)</secondary></indexterm>
<indexterm><primary>mathematical assignment operators</primary><secondary>multiply-assign (*=)</secondary></indexterm>
<indexterm><primary>mathematical assignment operators</primary><secondary>divide-assign (/=)</secondary></indexterm>
<indexterm><primary>mathematical assignment operators</primary><secondary>modulus-assign (%=)</secondary></indexterm>
<indexterm><primary>mathematical assignment operators</primary><secondary>power-assign (^=)</secondary></indexterm>
<indexterm><primary>mathematical assignment operators</primary><secondary>increment (++)</secondary></indexterm>
<indexterm><primary>mathematical assignment operators</primary><secondary>decrement (--)</secondary></indexterm>

In addition to the mathematical assignment operators above, steve also
support <emphasis>mathematical assignment operators</emphasis>. 
Mathematical assignment operators are used as shortcuts to perform
a calculation and update the value of a variable simultaneously, instead
of as two separate steps.  These expressions are useful, but since they 
are only shortcuts for other expressions, understanding them is not critical.
</para>
<para>
The following mathematical assignment operators are available: 
<itemizedlist>
<listitem><para><function>+=</function></para></listitem>
<listitem><para><function>-=</function></para></listitem>
<listitem><para><function>*=</function></para></listitem>
<listitem><para><function>/=</function></para></listitem>
<listitem><para><function>%=</function></para></listitem>
<listitem><para><function>^=</function></para></listitem>
</itemizedlist>
</para>
<para>
 These operators are simply shortcuts for cases in which the left operand of the mathematical expression is also the location where the output of  the expression will be stored.  For example, the following expression pairs are equivalent: 
<screen>
a = a + b.               # "a equals a plus b" can also be written as...
a += b.                  # "a plus equals b"

a = a - (2, 2, 2).
a -= (2, 2, 2).
</screen>
</para>

<para>
steve also has "increment" and "decrement" assignment operators:
<itemizedlist>
<listitem><para>++</para></listitem>
<listitem><para>--</para></listitem>
</itemizedlist>
</para>
<para>
As in languages like C and Perl, these operators increment and decrement 
a variable by one, respectively.  Unlike C and Perl, these operators 
may <emphasis>only</emphasis> be placed after the variable.  As an example, 
the following expression pairs are equivalent: 
<screen>
x = x + 1.          # updates the variable x by adding 1
x++.

x += 1.             # does the same...
x++.

y = (x += 1).       # a little confusing, but sets both x and y to (x + 1)
y = x++.            # as does this.
</screen>
</para>
</sect2>

<sect2>
<title>Mathematical Functions</title>
<para>
<indexterm><primary>mathematical functions</primary></indexterm>
<indexterm><primary>sin() function</primary></indexterm>
<indexterm><primary>transpose() function</primary></indexterm>
<indexterm><primary>cos() function</primary></indexterm>
<indexterm><primary>tan() function</primary></indexterm>
<indexterm><primary>asin() function</primary></indexterm>
<indexterm><primary>acos() function</primary></indexterm>
<indexterm><primary>sqrt() function</primary></indexterm>
<indexterm><primary>angle() function</primary></indexterm>
<indexterm><primary>max() function</primary></indexterm>
<indexterm><primary>min() function</primary></indexterm>
<indexterm><primary>cross() function (cross product)</primary></indexterm>
<indexterm><primary>dot() function (dot product)</primary></indexterm>
<indexterm><primary>log() function</primary></indexterm>
<indexterm><primary>randomGauss() function</primary></indexterm>
<indexterm><primary>Gaussian distribution</primary></indexterm>

<indexterm><primary>isnan() function</primary></indexterm>
<indexterm><primary>isinf() function</primary></indexterm>
<indexterm><primary>infinity</primary></indexterm>
<indexterm><primary>NaN (not-a-number)</primary></indexterm>

A number of internal functions (which are otherwise typically not used in breve simulations) are available for math-related expressions.  Internal functions are called just like C functions: <function><replaceable>functionName</replaceable>(<replaceable>arguments</replaceable>)</function>. 
<itemizedlist>
<listitem><para><function>sin(<replaceable>input</replaceable>)</function> 
gives the sine of the radian angle <replaceable>input</replaceable>.</para></listitem>

<listitem><para><function>cos(<replaceable>input</replaceable>)</function> 
gives the cosine of the radian angle <replaceable>input</replaceable>.</para></listitem>

<listitem><para><function>tan(<replaceable>input</replaceable>)</function> 
gives the tangent of the radian angle <replaceable>input</replaceable>.</para></listitem>

<listitem><para><function>asin(<replaceable>input</replaceable>)</function> 
gives the radian angle arc sine of <replaceable>input</replaceable>.</para></listitem>

<listitem><para><function>acos(<replaceable>input</replaceable>)</function> 
gives the radian angle arc cosine of the <replaceable>input</replaceable>.</para></listitem>

<listitem><para><function>atan(input)</function> 
gives the radian angle arc tangent of <replaceable>input</replaceable>.</para></listitem>

<listitem><para><function>sqrt(<replaceable>input</replaceable>)</function> 
gives the <function>float</function> square root of <replaceable>input</replaceable>.</para></listitem>

<listitem><para><function>angle(<replaceable>a</replaceable>, <replaceable>b</replaceable>)</function> 
gives the <function>float</function> angle in radians between vectors <replaceable>a</replaceable> and <replaceable>b</replaceable>.</para></listitem>

<listitem><para><function>max(<replaceable>a</replaceable>, <replaceable>b</replaceable>)</function> 
gives the maximum of <function>floats</function> <replaceable>a</replaceable> and <replaceable>b</replaceable>.</para></listitem>

<listitem><para><function>min(<replaceable>a</replaceable>, <replaceable>b</replaceable>)</function> 
gives the minimum of <function>floats</function> <replaceable>a</replaceable> and <replaceable>b</replaceable>.</para></listitem>

<listitem><para><function>cross(<replaceable>v1</replaceable>, <replaceable>v2</replaceable>)</function> 
gives the vector cross product of vectors <replaceable>v1</replaceable> and <replaceable>v2</replaceable>.</para></listitem>

<listitem><para><function>dot(<replaceable>v1</replaceable>, <replaceable>v2</replaceable>)</function> 
gives the float dot product of vectors <replaceable>v1</replaceable> and <replaceable>v2</replaceable>.</para></listitem>

<listitem><para><function>log(<replaceable>input</replaceable>)</function> 
gives the <function>float</function> natural log of <replaceable>input</replaceable>.</para></listitem>

<listitem><para><function>randomGauss()</function> 
gives a <function>float</function> random number with a Gaussian distribution.</para></listitem>

<listitem><para><function>transpose(<replaceable>input</replaceable>)</function> 
gives the transpose of the matrix <replaceable>input</replaceable>.</para></listitem>

</itemizedlist>
</para>
<para>
The following internal functions are used for testing float variables for special values 
which have meaning primarily to developers and plugin authors.
<itemizedlist>
<listitem><para><function>isnan(<replaceable>input</replaceable>)</function> 
returns 1 if the input is a "not-a-number" float value, 0 otherwise.</para></listitem>

<listitem><para><function>isinf(<replaceable>input</replaceable>)</function> 
returns 1 if the input is a float value representing infinity, 0 otherwise.</para></listitem>
</itemizedlist>
</para>

</sect2>

<sect2>
<title>Random Numbers</title>
<para>
<indexterm><primary>random numbers</primary></indexterm>
Random numbers are available in steve using the command <function>random</function>. The syntax is <function>random[ <replaceable>expression</replaceable> ]</function>, where expression is an expression of either 
<function>int</function> (<xref linkend="int">), <function>float</function> (<xref linkend="float">) or <function>vector</function> (<xref linkend="vector">).  The value returned is always the same type as the expression.  In the case of <function>int</function> or <function>float</function>, the returned value is a random value between 0 and the expression.  In the case of a <function>vector</function> expression, the returned value is a <function>vector</function> in which each element is between 0 and the corresponding value of the expression.  For example, a  call to <function>random[(10, 10, 20)]</function> returns a <function>vector</function> with X and Y elements between 0 and 10, and the Z element between 0 and 20. 
</para>
<para>
Note that <function>random[<replaceable>intValue</replaceable>]</function> returns a value between 0 and <replaceable>intValue</replaceable>, inclusive, as opposed to the behavior that many C programmers expect in which the  returned value is between 0 and <replaceable>intValue</replaceable> - 1. 
</para>
<para>
Because many simulations use the origin (0, 0, 0) as the "center" of their world, it is often useful to obtain a random vector centered around (0, 0, 0). For example, if we want to move agents somewhere within an imaginary box  surrounding the origin, we might use the expression <function>random[(40, 40, 40)] - (20, 20, 20)</function>. This convention gives us a <function>vector</function> with each element between -20 and 20.  This type of expression appears frequently in simulations. 
</para>
<para>
The values are produced using the standard C library <function>random()</function> routine.  The library is seeded with the current time when the breve application is launched.  To explicitly set the random seed, you may call the internal function <function>randomSeed( <replaceable>value</replaceable> )</function>, where value is an integer. 
</para>
<para>
<indexterm><primary>/dev/random</primary></indexterm>
In the event that multiple breve simulations are launched simultaneously (typically only relevant in 
cluster environments), it may be necessary to pick unique random seeds for each simulation to prevent
each of the simulations from giving the same results.  Refer to the 
<ulink url="../classes/Control.html">Controller</ulink> method 
<ulink url="../classes/Control.html#set-random-seed-from-dev-random">set-random-seed-from-dev-random</ulink>
for more information on automatically picking unique random seeds on systems which support it.
</para>
</sect2>

<sect2 id="method-calls">
<title>Method Calls</title>
<para>
<indexterm><primary>method calls</primary></indexterm>
As discussed in the section on defining class methods, each method is identified by a name and may have any number of input arguments.  The most simple method call to a method with no arguments is simply: 
<screen>
<replaceable>instance</replaceable> <replaceable>methodName</replaceable>.
</screen>
</para>
<para>
If the method takes arguments, each argument is associated with a keyword: the keyword identifies which argument will follow and what it's type is.  This is somewhat different from C where the argument's type and meaning is specified by its order relative to other arguments.  The steve method is more similar to Objective C and allows a more natural language structure to method calls and protects against arguments being passed in the wrong order. 
</para>
<para>
To pass arguments to the method, simply precede the argument value with the keyword name.  Consider a method move-object which takes a keyword to:
</para>
<para>
<screen>
myObject move-object to (1, 2, 3). 
</screen>
</para>
<para>
If the method takes more than a single argument, the convention is the same&mdash;just add the next argument afterwards.  Note that the order in which the arguments are passed does not  affect the method call, though it may affect the readability of the code.  For example, the Control object implements a method to point the camera at a certain vector location from a vector offset&mdash;first we'll see the method definition, then how it's called: 
<screen>
# if the method is defined using:
    
+ to point-camera at location (vector) from offset (vector):
    ...

# then from another method, we can call point-camera using the code below.
# these two method calls are equivalent, though the first reads more 
# naturally.

+ to do-something-else:
    self point-camera at (0, 0, 0) from (100, 100, 100).
    self point-camera from (100, 100, 100) at (0, 0, 0). 

</screen>
</para>
<para>
If you wish to call a method for multiple objects, you can use the method call syntax with a list of objects.
Note, however, that the arguments to the list are computed for item in the list  separately.  This makes a difference in the following example: 
</para>
<para>
<screen>
# assume that mobileList is of type list

mobileList = 10 new Mobile.

# The random statement is evaluated for each instance, meaning that all the 
# instance go to different random locations, not to a single random location.

mobileList move to random[(20, 20, 20)].
</screen>
</para>
</sect2>

<sect2>
<title>The <function>all</function> Expression</title>
<para>
You can find all instances of a given class using the 
<function>all</function> expression.  <function>all</function> is given 
the name of a class, and returns a list containing all objects of that
type.
<screen>
# get a list of all mobile objects in the simulation

myMobile = all Mobiles
</screen>
</para>
</sect2>

<sect2>
<title>
Printing information with <function>print</function> and <function>printf</function></title>
<para>
<indexterm><primary>print</primary></indexterm>
<indexterm><primary>printf</primary></indexterm>
The <function>print</function> and <function>printf</function> statements are
used to print output from a simulation to the output log.  Both of these 
statements accept any type of expression, as well as multiple expressions
separated by commas.  Also, since <function>strings</function> may contain 
embedded variables, you can format the output of variables however you'd like.
See the section on <function>strings</function> (<xref linkend="string">)
for more information.
</para>
<para>
The only difference between <function>print</function> and 
<function>printf</function> is that <function>printf</function> does 
<emphasis>not</emphasis> automatically print a newline character.  This 
means that subsequent prints will continue on the same line (as though
the "return" key was never hit).  This can be useful if you're trying 
to produce output in a specific format, but is typically not desirable.
If in doubt, stick to <function>print</function>
</para>
<para>
Here are some examples of <function>print</function> and 
<function>printf</function>:
<screen>
# print two variables, side by side.

print (self get-time), populationSize.

# use a variable embedded in a string.

print "the population size is $populationSize".

# the following statements would produce the text:
# A B C
# D E F

print "A B C ".
print "D E F"

# the following statements would produce the text:
# A B C D E F

printf "A B C ".
printf "D E F"
</screen>
</para>
</sect2>


<sect2>
<title>Using Subexpressions</title>
<para>
<indexterm><primary>subexpressions</primary></indexterm>
As in C, of course, users can use subexpressions as part of larger expressions. For example, you can use a mathematical expression as part of a method call, or  a method call as part of a mathematical expression. 

Because of the syntax of steve , however, subexpressions frequently need to be parenthesized in situations where it would not be required in C.  The following important rules apply to using subexpressions: 
If a method call is not the entire statement, it must be parenthesized. 

If you wish to assign the result of a method call, use it in a mathematical expression or use it as an argument for another method, for example: 
</para>
<para>
<screen>
myInt = self get-speed.                   # incorrect
myInt = (self get-speed).                 # correct

myInt = self get-speed + 5.               # incorrect
myInt = (self get-speed) + 5.             # correct

self set-speed to neighbor get-speed.     # incorrect 
self set-speed to (neighbor get-speed).   # correct
</screen>
</para>
<para>
All method arguments must be a single "unit"&mdash;arguments  which are not simply a  variable or literal value must be parenthesized. 
</para>
<para>
This means that if you use mathematical expressions, instantiations or  other method calls as input arguments to a method, they must be parenthesized. The first rule about method calls, of course, still applies: 
<screen>
self set-location to ((neighbor get-location) + (10, 10, 10)). # correct
self set-location to (neighbor get-location) + (10, 10, 10).   # incorrect
</screen>
</para>
</sect2>

<sect2>
<title>Internal Function Calls</title>
<note><title>For developer use only</title>
<para>
<indexterm><primary>internal function calls</primary></indexterm>
Internal function calls are for use by breve and plugin developers only.
</para>
</note>
<para>
A final expression type not discussed above is an internal functions. Internal function calls 
look just like C calls: 
<screen>
<replaceable>methodName</replaceable>(<replaceable>arg1</replaceable>,<replaceable>arg2</replaceable>, <replaceable>... argN</replaceable>)
</screen>
</para>
<para>
Though internal function calls are the most direct access to the breve libraries and features, 
the included class hierarchy provides a formal interface to the internal functions such that
user simulations should never use these internal functions.  The only exception to this 
is for certain mathematical functions.
</para>
</sect2>

</sect1>

<sect1 id="control-structures">
<title>Program Control Structures</title>
<para>
<indexterm><primary>control structures</primary></indexterm>
<emphasis>Control structures</emphasis> effect the flow of simulation code.
Though many of these structures function the same as their counterparts in 
C, the syntax is slightly different in each case.  The main difference
is that the statement being tested is not (necessarily) surrounded by parenthesis, 
but is followed by a colon (':') character.
</para>
<para>
Control statements evaluate test statements and then execute code according to 
the result.  In the case of <function>for</function> (<xref linkend="for">),
<function>foreach</function> (<xref linkend="foreach">) and
<function>while</function> (<xref linkend="for">), these structures are used
as loops to repeat execution of a piece of code a certain number of times 
or while a certain condition is met.  The <function>if</function> statement
is used to execute a block of code if a certain condition is true and,
optionally, a different piece of code if the statement is false.  A call to
<function>return</function> will exit any control structure's block immediately 
and exit the method.
</para>
<para>
The conditional statements are be comprised of C-style comparison operators.  The following comparison operators are available: 
<itemizedlist>
<listitem><para><function>==</function>, Equals</para></listitem>
<listitem><para><function>!=</function>, Not equals</para></listitem>
<listitem><para><function>\>=</function>, Greater than or Equals</para></listitem>
<listitem><para><function>\<=</function>, Less than or Equals</para></listitem>
<listitem><para><function>\></function>, Greater than</para></listitem>
<listitem><para><function>\<</function>, Less than</para></listitem>
<listitem><para><function>&&</function>, And (short circuit operator)</para></listitem>
<listitem><para><function>||</function>, Or (short circuit operator)</para></listitem>
<listitem><para><function>!</function>, Negation</para></listitem>
</itemizedlist>
</para>
<para>
For all of these structures, the code to be executed may be either a single
statement, or several statements enclosed in braces ('{' and '}').
</para>
<sect2 id="if">
<title>The <function>if</function> Statement</title>
<para>
<indexterm><primary>if</primary></indexterm>
<indexterm><primary>else</primary></indexterm>
The <function>if</function> statement is used to execute one piece of code
if a test statement is true, and (optionally) another if the statement is
false:
<screen>
if <replaceable>test_statement</replaceable>: <replaceable>true_code</replaceable>
[ else <replaceable>false_code</replaceable> ]
</screen>
Examples of the <function>if</function> statement are shown below.
<screen>
# here we execute a single statement

if x > 5: x = 20.
else x = 0.

# here we execute many...

if x > 5: {
	x = 20.
	y = 40.
} 

# here we execute many in the if, but only one in the else...

if x > 5: {
	x = 20.
	y = 40.
} else x = 200.
</screen>
</para>
</sect2>

<sect2 id="while">
<title>The <function>while</function> Loop</title>
<para>
<indexterm><primary>while</primary></indexterm>
The <function>while</function> structure works just like the while statement in C.  
If executes a block of code repeatedly, as long as the condition statement is true:
<screen>
while <replaceable>condition</replaceable>: <replaceable>code</replaceable>
</screen>
Examples of the <function>while</function> loop are shown below.
<screen>
# for example...

while x < 10: {
	print "x = $x".
	x++.
}
</screen>
</para>
</sect2>

<sect2 id="foreach">
<title>The <function>foreach</function> Loop</title>
<para>
<indexterm><primary>foreach</primary></indexterm>
The <function>foreach</function> structure is similar to the foreach loop in Perl.  The
loop iterates through a list, and executes the associated code each time.
The current item in the list is stored in a temporary variable as supplied by 
the user:
<screen>
foreach <replaceable>temporary_variable</replaceable> in <replaceable>list_variable</replaceable>: <replaceable>code</replaceable>.
</screen>
Examples of the <function>foreach</function> loop are shown below.
<screen>
# so, for example, if we have a variable called agent and a list
# of objects stored in agentList:

foreach agent in agentList: {
	print (agent get-location).
}
</screen>
</para>
</sect2>

<sect2 id="for">
<title>The <function>for</function> Loop</title>
<para>
<indexterm><primary>for</primary></indexterm>
The <function>for</function> loop (similar to the <function>for</function> loop in C) 
repeatedly executes a block of code.  Though it can function more generally like the
<function>while</function> loop, it is typically used to run a block of code for 
each value of a "counter" variable.
</para>
<para>
The loop is separated into three statements&mdash;an initializer, a test statement, and an increment statement.
<screen>
for <replaceable>expression</replaceable>, <replaceable>test_expression</replaceable>, <replaceable>increment_expression</replaceable>: <replaceable>code</replaceable>.
</screen>
The <emphasis>initializer</emphasis> is executed once when the loop starts.  It is typically used to set 
the iteration variable before proceeding.  The <emphasis>test statement</emphasis> is run at every 
iteration to determine whether the loop will continue to execute (similar to the <function>while</function>
loop).  Finally, the <emphasis>increment statement</emphasis> is run at every iteration of the loop, 
typically to update a counter variable.  Examples of the <function>for</function> loop
are shown below.
<screen>
# so, for example, if we have a variable called n (int), this loop will
# print the numbers from 1 to 30.

for n=0, n<30, n+=1: {
	print n.
}

# we can also use a different increment statement in order to run the 
# loop a bit differently&mdash;let's print only even numbers between 1 and 30

for n=2, n<30, n+=2: {
	print n.
}
</screen>

</para>
</sect2>

</sect1>

<sect1 id="garbage-collection"><title>Garbage Collection and Memory Management</title>
<indexterm><primary>garbage collection</primary></indexterm>
<indexterm><primary>memory management</primary></indexterm>

<para>
breve includes built-in <emphasis>garbage collection</emphasis> 
(sometimes called <emphasis>GC</emphasis>).  Garbage collection is a form 
of memory management in which the system detects when an object is no 
longer referenced by any other variable.  When an object is no longer referenced 
by any other variable, it is an indication that the memory is no longer in use and 
can thus be safely deallocated. 
</para>
<para>
</para>

<sect2>
<title>Memory Management and Garbage Collection of Basic Types</title>
<para>
Memory management and garbage collection of basic types happens 
automatically and requires no user interaction.  ints, floats, matrices
and vectors are passed by reference and do not require garbage collection.
lists, hashes and data are automatically garbage collected when appropriate.
</para>
</sect2>

<sect2>
<title>Memory Management and Garbage Collection of Objects</title>
<para>
breve's garbage collection is slightly complicated by the fact that objects 
do not need to be referenced in memory to be "in use".  An unreferened object
may, for example, "come back to life" because of an all (<xref linkend="all">) 
expression.  Furthermore, objects in the simulated world (members of subclasses 
of the class "Real") may physically interact even without referencing each other
in their variables.  Because of these complications, garbage collection cannot be 
automatically enabled for all objects in a simulation.
</para>
<para>
Garbage collection for objects is thus enabled on a per-object basis and the 
programmer must decide when its use is appropriate.  The following guidelines
should generally help to decide when garbage collection is appropriate for 
an object:

<itemizedlist>
  <listitem><para>the object is not a member of a subclass of Real.</para></listitem>
  <listitem><para>the object does not have it's own iterate or post-iterate methods.</para></listitem>
  <listitem><para>the object is not a dependency of any object that does not hold a reference to it.</para></listitem>
</itemizedlist> 

</para>
</sect2>

<sect2>
<title>A Garbage Collection Caveat: Circular References</title>
<para>
One important caveat applies to garbage collection of both basic types and 
objects.  The steve garbage collection scheme does not correctly deallocate 
memory when there are <emphasis>circular references</emphasis>.  A circular
reference occurs when two (or more) objects refer to each other in a circular
fashion.  An example of a circular reference between three objects is shown
below:
<mediaobject><imageobject><imagedata align="center" fileref="images/circular_reference.jpg"></imageobject></mediaobject>
</para>
<para>
When a circular reference occurs, the objects are never recognized as "unused"
and are thus never deleted as they should be.  Circular references thus lead
to "islands" of unused memory which do not get released.  This type of circular
reference is rare, but if your simulation design makes use of these types of 
structures, you may have to explicitly overwrite variables in order to ensure
that no circular references exist.
</para>
</sect2>


</sect1>


<sect1 id="at-directives"><title>@-Directives</title>
<para>
Before getting started with the code for a simulation or class, there are 
often a few special lines at the top of a steve file which begin with an
@-character.  These lines are called @-directives ("at directives") and 
they specify information that can help breve to locate classes or other
files, or to define some constants that will be used in your simulation.
These directives are described below.
</para>

<sect2><title><function>@include</function> and <function>@use</function>: Load Another Source File</title>
<indexterm><primary>@include</primary></indexterm>
<indexterm><primary>include directive</primary></indexterm>
<indexterm><primary>@use </primary></indexterm>
<indexterm><primary>use directive</primary></indexterm>
<para>
breve includes a rich hierarchy of classes which are used to construct 
simulations.  To use a class which comes with breve (or another file which
you have created yourself), you must tell breve
to load in the associated file.  You need to load the class before you 
instantiate it or subclass it.
</para>
<para>
Classes are loaded using the <function>@include</function> directive.
It is used simply by specifying the name of the file to include:
<screen>
@include "Control.tz".
</screen>
</para>
<para>
<function>@use</function> works the same way, but with a slightly 
different syntax, leaving out the quotes and the ".tz" from the file
name:
<screen>
@use Control.
</screen>
There is no different between <function>@include</function> and 
<function>@use</function> in terms of how the file is actually loaded.
</para>
<para>
<function>@include</function> directives are not only used to include 
classes which come with the breve distribution, but also potentially classes 
that you construct yourself.  It is often used in conjunction with the 
<function>@path</function> directive (<xref linkend="at-path">) to specify 
the location of classes before loading them.
</para>
</sect2>

<sect2 id="at-path">
<title><function>@path</function>: Specify a Search Path</title>
<para>
<indexterm><primary>@path</primary></indexterm>
<indexterm><primary>search path</primary></indexterm>
<indexterm><primary>path directive</primary></indexterm>
The <function>@path</function> directive specifies a directory that breve
should search in to find files.  These directories apply to finding 
class files, image files, sound files, archives and any other type of 
resource that breve might be looking for.  It should go at the top of 
the file, before you try to include any other files.
</para>
<para>
Here's an example of <function>@path</function> line that searches a 
folder in my home directory for class files:
<screen>
@path "/Users/jk/breve_classes".
</screen>
</para>
<para>
You may specify as many directories with <function>@path</function>
directives as necessary.
</para>
</sect2>

<sect2><title><function>@define</function>: Define a Global Constant</title>
<para>
<indexterm><primary>@define</primary></indexterm>
<indexterm><primary>global constants</primary></indexterm>
<indexterm><primary>define directive</primary></indexterm>
A <firstterm>global constant</firstterm> lets you associate a name with a 
constant value in your simulation.  The <function>@define</function> directive
allows you to associate names with <function>ints</function>, 
<function>floats</function> and <function>strings</function>.  
</para>
<para>
These constants can be very useful when you have the same value used several
times in a simulation&mdash;if you want to change the value, then instead
of making the change several times, you can make it once in the 
<function>@define</function> directive.  It can also be useful to assign
meaningful symbols to numbers in your simulation.  For example, if your 
cellular automata is arbitrarily chosen to be 50x50, then instead of 
<emphasis>hardcoding</emphasis> the number 50, it is more flexible and 
more descriptive to use a global constant.
</para>
<para>
Global constants are defined with the following form:
<screen>
@define <replaceable>constant-name</replaceable> <replaceable>constant-value</replaceable> .
</screen>
Here are some examples:
<screen>
@define CA_SIZE                 50.
@define PI_VALUE                3.14159.
@define STRING_CONSTANT         "Hello".
</screen>
By setting these constants at the top of the source file, you can use them
later on.  For example:
<screen>
+ to print-pi:
	print "pi is approximately: ", PI_VALUE.
</screen>
</para>
<para>
It is not required, but, by convention, global constants are typically
written with all capital letters, to distinguish them from variables.
</para>

</sect2>

</sect1>

</chapter>
