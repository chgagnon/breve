<?xml version='1.0'?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD Docbook XML V4.1.2//EN" "http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd">
<book id="node-2601">
<title>The breve Simulation Environment Documentation</title>
<preface>
<title>Preface</title>
<para>
      This is the documentation for <ulink url="http://www.spiderland.org">The
      breve Simulation Envionment</ulink>.
    </para><mediaobject><imageobject><imagedata align="center" fileref="images/breve_icon.jpg"/></imageobject></mediaobject><para>
      You can also <ulink url="http://www.spiderland.org/download/breve_docs.tar.gz">download</ulink> the
      breve 2.5.1 documentation in HTML format [808K tar/gz file].
    </para><para>
      To report bugs in breve, you can either <ulink url="mailto:jk%20[at]%20spiderland.org">email the author</ulink>, or post your
      bug in the <ulink url="http://www.spiderland.org/forums">bugs section of the
      breve discussion forum</ulink>.
    </para><bridgehead>
      Further questions
    </bridgehead><para>
      If you have further questions about breve that aren't answered in the
      documentation:
    </para><itemizedlist><listitem><para>Try asking your questions in <ulink url="http://www.spiderland.org/forums">the breve discussion forums</ulink></para></listitem><listitem><para>Send mail to the <ulink url="mailto:jk%20[at]%20spiderland.org">author
      of breve</ulink></para></listitem></itemizedlist>
</preface>
<chapter id="node-2602"><?dbhtml dir="docs" ?>
<title>The Origin of breve</title>
<para>
        The simulation software described in this document, breve, was
        initiated by <ulink url="mailto:jk%20%5Bat%5D%20spiderland.org">jon klein</ulink> as a thesis project at <ulink url="http://www.hampshire.edu">Hampshire College</ulink> and was
        developed further into a Master's thesis at <ulink url="http://www.chalmers.se">Chalmers University</ulink>. The
        software is actively being developed as a platform for a project
        building large scale simulations of evolutionary dynamics, but is also
        used for many other applications.
      </para>
</chapter>
<chapter id="node-2603"><?dbhtml dir="docs" ?>
<title>About This Documentation</title>
<para>
        As of breve version 2.5, this documentation is generated from the
        online-edited documentation found on <ulink url="http://www.spiderland.org/breve/documentation.php">the breve web
        site</ulink>. The copy of this documentation included in the source
        distribution should not be edited. The documentation can be edited by
        the breve community online.
      </para><para>
        This document is a work in progress. See the section on "Getting Help
        With breve" (<xref linkend="node-2604"/>) if this document fails to
        adequately describe any features or techniques.
      </para>
</chapter>
<chapter id="node-2604"><?dbhtml dir="docs" ?>
<title>Getting Help With breve</title>
<para>
        There are several ways to get help using breve:
      </para><itemizedlist><listitem><para>
              Read the class documentation for more detailed information about
              each class. These class files are listed in ???.
            </para></listitem><listitem><para>
              Visit the breve discussion forums at <ulink url="http://www.spiderland.org/forums/">http://www.spiderland.org/forums/</ulink>.
            </para></listitem><listitem><para>
              Mail the author at <ulink url="mailto:jk%20%5Bat%5D%20spiderland.org">jk [at]
              spiderland.org</ulink></para></listitem></itemizedlist>
</chapter>
<chapter id="node-2605"><?dbhtml dir="docs" ?>
<title>Thanks and Acknowledgments</title>
<para>
        Thanks are due to (in no particular order):
      </para><itemizedlist><listitem><para>
              Lee Spector and Kristian Lindgren.
            </para></listitem><listitem><para>
              Martin Martin, Ignacio Garcia, Eric DeWitt, Ian Lindsay, Gabriel
              Tarasuk-Levin, Michael Larson and Marc Szymansk for programming
              contributions.
            </para></listitem><listitem><para>
              Poornima, Seth and William for contributions to the NetworkServer
              features.
            </para></listitem><listitem><para>
              Laurie, for contributions to the breve-object and frontend APIs.
            </para></listitem><listitem><para>
              Jeff for design, testing and icons.
            </para></listitem><listitem><para>
              TiVo.
            </para></listitem><listitem><para>
              Irina, f&#xF6;r att hon &#xE4;lskar mig som jag &#xE4;r.
            </para></listitem></itemizedlist><para>
        breve development is supported in part by an NSF Director's Award for
        Distinguished Teaching Scholars (PI: Lee Spector), by NSF grant
        EIA-0216344, and by the Defense Advanced Research Projects Agency
        (DARPA) and Air Force Research Laboratory, Air Force Materiel Command,
        USAF, under agreement number F30502-00-2-0611.
      </para>
</chapter>
<chapter id="node-2606"><?dbhtml dir="docs" ?>
<title>What's New in Version 2.5.1</title>
<para>
        breve version 2.5.1 introduces several new features and changes.
      </para>
<section id="node-2607">
<title>New Features in Version 2.5.1</title>
<para>
        breve 2.5.1 is a bug-fix release that introduces one major new feature
        (currently experimental):
      </para><itemizedlist><listitem><para>
              Experimental new <xref linkend="node-3246"/> allows Python code to be called from breve simulations
            </para></listitem></itemizedlist><para>
        Below are some of the major new features found in breve 2.5 . For a
        full list of new features, see the "Changes" file that is included with
        the breve distribution.
      </para><itemizedlist><listitem><para>
              Network connections may now return objects to the client which
              initiated the connection [<xref linkend="node-2780"/>]
            </para></listitem><listitem><para>
              Updated plugin and language frontend API [<xref linkend="node-2755"/>]
            </para></listitem><listitem><para>
              Major bug fixes and stability improvements
            </para></listitem></itemizedlist>
</section>
<section id="node-2608">
<title>Important Notes on Plugins in Version 2.5
</title>
<para>
        The inner workings of the breve plugin API have changed as of breve
        version 2.5. Plugins compiled for earlier versions of breve will not
        work with breve 2.5 or later.
      </para><para>
        In most cases, plugins simply need to be recompiled, but should
        generally not require any changes to code. Additionally, plugins must
        now be compiled using a C++ compiler (though code written in C will
        continue to function). See the updated documentation on Plugins
        <xref linkend="node-2765"/> for
        more information.
      </para>
</section>
<section id="node-2609">
<title>Upgrading Simulations From Version 1.x</title>
<para>
        A number of changes introduced in breve 2.0 may require small changes
        to simulations written in previous versions of breve (1.x). These
        changes and instructions on upgrading simulations are discussed below.
      </para><itemizedlist><listitem><para>
              MultiBody functionality has been changed <xref linkend="node-2610"/></para></listitem><listitem><para>
              Arrays are now deprecated <xref linkend="node-2611"/></para></listitem><listitem><para>
              The Data class has been removed <xref linkend="node-2612"/></para></listitem><listitem><para>
              The Vision class has been removed <xref linkend="node-2613"/></para></listitem><listitem><para>
              Texture loading has been changed <xref linkend="node-2614"/></para></listitem></itemizedlist>
<section id="node-2610">
<title>Changes to MultiBody Functionality</title>
<para>
        MultiBodies are now optional. Some MultiBody functionality has changed,
        and some MultiBody methods have been removed.
      </para><para>
        The MultiBody class is used to manage a logical collection of connected
        links. Prior to version 2.0, all physically connected objects were
        required to be part of a MultiBody. This lead to complications when
        multiple MultiBodies would merge to form a single body, or when a
        single MultiBody would split to become two bodies.
      </para><para>
        In version 2.0, MultiBody objects are now optional. The Link class is
        now a subclass of Mobile, so Links can be created as real objects in
        the simulated world, and can be connected or disconnected from other
        links as desired. The MultiBody object is now a distinct class. It can
        be used, if desired, to move or rotate a group of connected link
        objects, but it is otherwise not required for physically simulated
        bodies.
      </para><para>
        Some of the methods which MultiBody previously inherited from the Real
        class are now no longer available (since MultiBody is no longer a
        subclass of Real or Mobile). You must now call these methods directly
        on the link objects associated with the MultiBody. The method
        get-all-connected-links will help you
      </para><para>
        Freeing a MultiBody will also no longer free all of the connected Link
        and Joint objects, and the associated bodies will remain in the
        simulation. If you want to destroy the simulated objects, you should
        call the method free-all-connected-objects before freeing the
        MultiBody.
      </para><para>
        If your simulation made use of MultiBodies prior to version 2.0, you
        may need to modify your simulation to account for the changes described
        above.
      </para>
</section>
<section id="node-2611">
<title>Arrays Are Now
Decprecated</title>
<para>
        The use of arrays has now been deprecated and will be removed from a
        future release of breve: use lists instead
      </para><para>
        Lists have all of the functionality of arrays and more. Arrays existed
        for a short time before lists had been implemented, and have been
        around ever since, though they are only rarely used.
      </para><para>
        As of version 1.9, lists are indexed for fast access so that repeated
        list accesses are as fast as array accesses.
      </para><para>
        If your simulation uses arrays, you should convert them to lists to
        ensure compatibility in the future.
      </para>
</section>
<section id="node-2612">
<title>The Data Class is Now Obsolete</title>
<para>
        The Data class has been deprecated and will be removed from a future
        release of breve.
      </para><para>
        Because archiving and networking has been improved and allows for
        archiving of complex types such as objects and lists, the Data class is
        now obsolete. It will be removed from a future version of breve.
      </para>
</section>
<section id="node-2613">
<title>The "Visions" class has been removed</title>
<para>
        The same functionality can be reproduced using the new "Camera" class
        and the updated "Image" class.
      </para><para>
        The "Visions" class was used to provide the user with pixel buffers of
        rendered perspectives in the simulated world. This allowed multiple
        rendered perspectives in the main viewing window, but it also required
        reading pixels from the graphics card at each time step, an operation
        which is somewhat slow.
      </para><para>
        The new Camera class allows multiple perspectives to be rendered to the
        main output window without the slow pixel reading step. The updated
        Image class now allows pixels to be read from the main output window as
        desired. The Image class provides all of the functionality of the
        Vision class, and more: its pixels can be read or modified, it can be
        written to disk or used to texture another object in the simulation,
        and it can provide a pointer to raw pixel data.
      </para><para>
        One important note regarding differences between the Vision class and
        the Image class: Visions stored three separate pixel buffers for red,
        green, blue data. The Image class stores a single buffer containing
        interleaved red, green, blue and alpha pixels.
      </para><para>
        If your simulation used the Vision class in a prior version of breve,
        it will need to use the Camera and Image objects to preform the same
        functionality in the current version of breve.
      </para>
</section>
<section id="node-2614">
<title>Loading Textures From the Controller Class is Now Deprecated</title>
<para>
        Obtaining a "texture number" by loading an image from the Control class
        is now deprecated, as is using a texture number to set a texture,
        bitmap or lightmap. You should now load an image using the Image class,
        and use the Real object methods set-texture-image, set-bitmap-image and
        set-lightmap-image to apply textures, bitmaps and images.
      </para><para>
        The Image class provides much better control over textures than the
        previous method.
      </para>
</section>
</section>
</chapter>
<chapter id="node-2615"><?dbhtml dir="docs" ?>
<title>Introduction to breve</title>
<para>
        breve is a free environment designed for simulation of realistic, 3D,
        multi-agent systems.
      </para><para>
        This document describes breve and outlines how simulations are
        constructed. This chapter contains a brief overview on how to get
        started using breve to run simulations and how to get started on
        constructing your own.
      </para>
<section id="node-2616">
<title>What is breve?</title>
<para>
        breve is a free simulation environment designed for multi-agent
        simulation. breve allows users to define the behaviors of autonomous
        agents in a continuous 3D world, then observe how they interact. breve
        includes support for a rich visualization engine, realistic physical
        simulation and an easy-to-use scripting language.
      </para><para>
        breve can be used as a tool to explore any type of simulated world.
        breve has been used for a wide variety of simulation applications:
        simulated virtual creatures, artificial ecosystems, simulations of
        molecular biology, visualization and much more. breve facilitates the
        construction of complex agent-based simulations by automatically
        handling agent communication, representation in 3D space, graphical
        rendering, physical simulation and a number of other features which are
        useful to agent-based simulations.
      </para>
<section id="node-2617">
<title>Multi-Agent Simulation</title>
<para> The term <emphasis>agent</emphasis> refers to any object in a simulated world, but
        in particular, an object with autonomous behaviors which interacts with
        its environment and other agents. A <emphasis>multi-agent
        simulation</emphasis> is a simulation in which multiple agents exist and
        interact in the simulated world. An example of a multi-agent simulation
        is an ecosystem simulation: a large number of autonomous agents
        (animals) interacting with each other (eating and breeding) and the
        environment.
      </para><mediaobject><imageobject><imagedata align="center" fileref="images/particle_fountain.jpg"/></imageobject></mediaobject><para>
            In the <emphasis>ParticleFountain</emphasis>
            demo, you can see a particle system made up of hundreds of
            independent agents.
          </para>
</section>
<section id="node-2618">
<title>3D Spatial Simulation</title>
<para> breve is a simulation
        environment which is used primarily for 3D <emphasis>spatial simulations</emphasis>. This means that breve simulates
        3D physical space and that simulated agents occupy and interact in this
        physical space. Because of this, breve can be used for realistic
        simulations involving space, such as physical simulations. This is in
        contrast to simulation environments which model space in 2D or which
        treat "space" only as an abstract concept.
      </para><mediaobject><imageobject><imagedata align="center" fileref="images/DLA.jpg"/></imageobject></mediaobject><para>
            In the <emphasis>DLA</emphasis> demo, a fractal
            structure forms in 3D space.
          </para>
</section>
<section id="node-2619">
<title>Physical Simulation</title>
<para> breve is
        capable of realistic <emphasis>physical simulation</emphasis>.
        This means that agents in the simulated world can be configured to
        behave just as real objects do, according to the laws of physics. If a
        ball is placed in the air above a floor, for example, physical
        simulation can be used to make the ball realistically fall toward the
        floor and bounce. Among other things, physical simulation can be used
        for realistic simulation of robots, vehicles and animals.
      </para><mediaobject><imageobject><imagedata align="center" fileref="images/walker.jpg"/></imageobject></mediaobject><para>
            In the <emphasis>Walker</emphasis> demo, a
            physically simulated creature learns to walk.
          </para>
</section>
</section>
<section id="node-2620">
<title>Installing and Running the breve Application on Mac OS X</title>
<para> To install
        the breve application under Mac OS X, simply drag the application
        (<literal>breve.app</literal>) into your <literal>/Applications</literal> folder (or to any other folder where
        you wish to put the program).
      </para><para>
        To get started with breve, simply double-click the breve application.
      </para>
<section id="node-2621">
<title>Running the Demo Simulations</title>
<para>
        If you're new to breve, the first thing to do is run one of the demo
        simulations provided with the application. To open a demo file, use the
        <literal>Demo</literal> menu in the breve application.
      </para><para>
        After selecting a demo, a window is opened showing the simulation code.
        By pushing the play button, you start the simulation. The simulation
        can then be paused or stop by using the corresponding buttons below the
        simulation display.
      </para><para>
        If multiple code windows are open, you can select the simulation to
        start by using the popup menu located at the bottom of the simulation
        window.
      </para><mediaobject><imageobject><imagedata align="center" fileref="images/simulation_popup.jpg"/></imageobject></mediaobject>
</section>
<section id="node-2622">
<title>The Tool Palette</title>
<para> On the bottom of the simulation window
        is a small palette of tools.
      </para><mediaobject><imageobject><imagedata align="center" fileref="images/tools.jpg"/></imageobject></mediaobject><para>
        The first tool is the rotation tool. Use it to rotate the simulation
        view. The focal point of the simulation will remain the same, while the
        viewing angle is changed.
      </para><para>
        The next tool is the zoom tool. Use this tool to zoom in and out. As
        with the rotation tool, the focal point of the simulation stays the
        same.
      </para><para>
        The third tool is the motion tool, used to change the focal point of
        the simulation.
      </para><para>
        The final tool, the selection and motion tool, is used to select
        objects in the simulation. Once selected, an object can be inspected
        using the selection inspector window (described in <xref linkend="node-2623"/>), or dragged
        around the simulation.
      </para>
</section>
<section id="node-2623">
<title>The Selection Inspector</title>
<para>
        The "selection inspector" allows simulation objects to be inspected in
        real-time, as simulations run. If no object is selected in the
        simulation display, the controller object is shown in the selection
        window&#x2014;when an object is selected, its state is shown in the
        inspector.
      </para><para>
        The inspector automatically updates every few seconds so that the
        current state of simulation variables is always shown.
      </para><mediaobject><imageobject><imagedata align="center" fileref="images/selection_inspector.jpg"/></imageobject></mediaobject>
</section>
<section id="node-2624">
<title>The Log Window and Command-Input Field</title>
<para>
        Text messages and output from the simulation are printed to the log
        window.
      </para><para>
        The log window also contains a command-input field. This field allows
        you to execute commands in running simulations. "steve" commands can be
        written directly into this field, and will be executed in the
        simulation's controller object. The steve language (and the controller
        object) are described in the next chapter (<xref linkend="node-2632"/>).
      </para><mediaobject><imageobject><imagedata align="center" fileref="images/log_window.jpg"/></imageobject></mediaobject>
</section>
<section id="node-2625">
<title>The Simulation Menu and Object Contextual Menus</title>
<para>
        Users can also interact with a running simulation via the <emphasis>simulation menu</emphasis>, located in the menu bar, or by
        accessing contextual menus associated with objects in a simulation. To
        access a contextual menu for an object in the simulation, control-click
        on the object in the simulation display.
      </para><para>
        By default, the simulation menu and contextual menus are mostly empty.
        As you begin to customize simulations and construct your own, however,
        you will be able to add your own custom options to the simulation and
        contextual menus.
      </para>
</section>
</section>
<section id="node-2626">
<title>Installing and Running Command-Line breve on Mac OS X, Linux and Windows</title>
<para> The command-line version of breve allows you to run
        breve simulations on the command-line both with and without graphical
        display. The command-line version of breve is available for Mac OS X,
        Linux and Windows.
      </para><note><title>
              For Windows and Linux Users
            </title><para>
                In order to run the command-line breve on Windows or Linux,
                you'll need to have OpenGL and GLUT libraries installed on your
                system. If you encounter problems running breve, you may need
                to install these libraries. They are freely available from the
                internet.
              </para></note>
<section id="node-2627">
<title>Setting Up Your Environment</title>
<para>
        Before running breve, you'll need to set up the environment variable
        <literal>BREVE_CLASS_PATH</literal>. This variable must
        contain the location of the "lib/classes" directory included in the
        distribution. Setting this environment is done differently for
        different shells and platforms. Some examples are shown below.
        <emphasis><function>path to breve</function></emphasis> is the location
        of the breve distribution folder that you downloaded.
      </para><programlisting>
# tcsh users (Linux &amp; OSX):
        setenv BREVE_CLASS_PATH /<emphasis><function>&lt;path to breve&gt;</function></emphasis>/lib/classes

# bash users (Linux &amp; OSX):
        export BREVE_CLASS_PATH=/<emphasis><function>&lt;path to breve&gt;</function></emphasis>/lib/classes

# Windows console users:
        SET BREVE_CLASS_PATH=C:\<emphasis><function>&lt;path to breve&gt;</function></emphasis>\LIB\CLASSES
</programlisting><para>
        You may freely move around the files in the breve distribution (to
        install them in <literal>/usr/local</literal> on a UNIX
        system, for example), but be sure to set your <literal>BREVE_CLASS_PATH</literal> accordingly.
      </para>
</section>
<section id="node-2628">
<title>Running the Demo Simulations</title>
<para>
        Once your <literal>BREVE_CLASS_PATH</literal> environment
        variable is configured, you can get started by running breve with one
        of the included simulation files. Assuming that you are in the breve
        distribution directory, you can try out the "ArrowSwarm" demo by
        typing:
      </para><programlisting>
# Linux &amp; OSX
        % ./bin/breve ./demos/Swarm/ArrowSwarm.tz

# Windows
        &gt; bin\breve.exe demos\Swarm\ArrowSwarm.tz
</programlisting><para>
        This command will open a graphical display window containing the
        simulation, which is initially paused. To unpause the simulation, hit
        the space bar. When the simulation is running, the following controls
        can be useful:
      </para><itemizedlist><listitem><para>
              Space bar: pause/unpause the simulation
            </para></listitem><listitem><para>
              F1: run simulation forward one iteration step
            </para></listitem><listitem><para>
              Left mouse: rotate simulation and select objects (described
              below)
            </para></listitem><listitem><para>
              Right mouse click: display the simulation menu (described below)
            </para></listitem><listitem><para>
              Right mouse click (when an object is selected): display a
              contextual menu for the object (described below)
            </para></listitem><listitem><para>
              Control (or F2) + left mouse: zoom in and out of the simulation
            </para></listitem><listitem><para>
              Alt (or F3) + left mouse: move the camera
            </para></listitem><listitem><para>
              Shift (or F4) + left mouse: select and drag objects in the
              simulation
            </para></listitem><listitem><para>
              Escape: to quit the simulation, or access the breve command
              prompt
            </para></listitem></itemizedlist><para>
        The keys F2, F3 and F4 can be used instead of control, alt and shift,
        respectively, to allow for easier use on platforms which emulate middle
        and right mouse buttons using the control, alt or shift keys.
      </para><para>
        The breve command prompt (which can be accessed using the escape key)
        can be used to execute commands in running simulations. "steve"
        commands are typed in at this prompt, and will be executed in the
        simulation's controller object. The steve language (and the controller
        object) are described in the next chapter (<xref linkend="node-2632"/>).
      </para>
</section>
<section id="node-2629">
<title>The Simulation Menu and Object Contextual Menus</title>
<para>
        Users can also interact with a running simulation via the <emphasis>simulation menu</emphasis> and through the contextual menus
        associated with specific objects, both accessed via the right mouse
        button. To access the simulation menu, be certain that no object in the
        simulation is selected, and click the right mouse button. To access a
        contextual menu for an object in the simulation, use the right mouse
        button while an object is selected.
      </para><para>
        By default, the simulation menu and contextual menus are mostly empty.
        As you begin to customize simulations and construct your own, however,
        you will be able to add your own custom options to the simulation and
        contextual menus.
      </para>
</section>
<section id="node-2630">
<title>Viewing the Simulation Code</title>
<para>
        Simulations written in breve use the suffix ".tz" and are regular text
        files. You can open up the file in your favorite editor to see how it
        works:
      </para><programlisting>
% pico ./demos/Swarm/ArrowSwarm.tz 
</programlisting><para>
        If this is your first time running breve, it is recommended that you
        take the time to explore the demos and their code. By exploring the
        demos, you'll see how a number of breve's features are used and gain a
        basic understanding of how simulations are written.
      </para>
</section>
<section id="node-2631">
<title>Command-Line breve Without Graphical Display</title>
<para>
        If you wish to run a simulation without graphical display, you can use
        the program <literal>breve_cli</literal>. Follow the same
        setup directions described above (<xref linkend="node-2627"/>) in order to setup
        your environment, and then run the simulation:
      </para><programlisting>
% ./bin/breve_cli ./demos/Push/PushRegression.tz
</programlisting><para>
        Textual output will be printed as usual, but no graphical window is
        shown. This feature is most useful for collecting data when user
        interaction and observation is unimportant.
      </para>
</section>
</section>
</chapter>
<chapter id="node-2632"><?dbhtml dir="docs" ?>
<title>"steve" Language Reference</title>
<para>
        Simulations in breve are written using a language called "steve". steve
        is a simple language which aims to allow rapid construction of advanced
        simulations while avoiding a great deal of the programming overhead
        associated with constructing simulations in other languages.
      </para><tip><title>
              Don't Be Overwhelmed!
            </title><para>
                Writing simulations in steve is ultimately quite simple. Due to
                the number of features provided by the simulation engine,
                however, this documentation may seem at times overwhelming.
                Don't panic&#x2014;make liberal use of the demo simulations
                provided with the environment and don't be put off if some of
                the features discussed here are difficult to understand.
              </para></tip><para>
        "steve" is an <emphasis>object-oriented</emphasis> language. This means
        that programming in "steve" involves working with components called
        <emphasis>objects</emphasis> which contain data (<emphasis>variables</emphasis>) and behaviors (<emphasis>methods</emphasis>). In breve, objects can be either <emphasis>real</emphasis>, meaning they have a presence in the simulated
        world; or <emphasis>abstract</emphasis> meaning that they are
        used to store data or to perform computations, but do not appear in the
        simulated world. In order to define agents and their behaviors, one
        needs to construct these objects and behaviors using the "steve"
        language. The language is described in this chapter.
      </para><para>
        First, the classic "Hello, World" program is constructed in steve
        (<xref linkend="node-2633"/>). Then, a
        simple multiagent 3D simulation written in steve is presented (<xref linkend="node-2634"/>). This sample
        should give the basic idea of what a breve simulation looks like.
      </para><para>
        As discussed above, all agents in the simulated world are represented
        by programming objects. These objects are defined in terms of object
        templates called <emphasis>classes</emphasis>. The most important
        object, called the <emphasis>Controller</emphasis> is described
        in the section The Controller Object (<xref linkend="node-2636"/>). The section Building
        Classes (<xref linkend="node-2637"/>)
        describes how to construct basic classes in steve.
      </para><para>
        In order to define the data and behaviors of your classes, you'll need
        to be familiar with types (<xref linkend="node-2644"/>) and expressions (<xref linkend="node-2673"/>). The section Program
        Control Structures (<xref linkend="node-2685"/>) discusses loops and
        conditional statements.
      </para>
<section id="node-2633">
<title>Hello, World</title>
<para> The
        traditional introduction to any programming language is a program which
        repeatedly prints out the text "Hello, World!". Here it is written in
        steve:
      </para><programlisting>
@include "Control.tz"           

Controller HelloWorld.

Control : HelloWorld {
        + to iterate:
                print "Hello, world!".
}
</programlisting><para>
        The specifics will be discussed in more detail through the rest of this
        chapter. Briefly, we first declare the simulation's controller object
        to be a class called <literal>HelloWorld</literal> (line 3).
        Then we construct the <literal>HelloWorld</literal> class
        (lines 5-8), and as part of that class, we define a method called
        <literal>iterate</literal> (line 6) which will print out the
        text "Hello, world!". The "include" line (line 1) simply tells breve to
        load in a file called "Control.tz", which is included with the breve
        distribution. This built-in class file contains the class control,
        which is the <emphasis>parent</emphasis> class for our
        "HelloWorld" controller.
      </para><para>
        When this simulation is run, the controller object is created, and the
        method named <literal>iterate</literal> gets run
        automatically at every step of the simulation. Thus, "Hello, World!".
        Ad nauseum.
      </para>
</section>
<section id="node-2634">
<title>A Simple Example</title>
<para>
        "Hello, World" is a very simple example which can be used for any
        programming language. It does not, however, give any insight into how
        3D multiagent simulations are written in steve. This section shows the
        code for a simple 3D multiagent simulation.
      </para><mediaobject><imageobject><imagedata align="center" fileref="images/random_walker.jpg"/></imageobject></mediaobject><para>
            In the <emphasis>RandomWalker</emphasis> demo,
            you can see a simple simulation containing hundreds of independent
            agents.
          </para><para>
        The simulation below is very heavily commented&#x2014;all of the lines
        beginning with the # character are descriptive comments which do not
        effect the execution of the simulation, but clarify for the user what
        the simulation is doing. Comments are described in more detail below.
      </para><para>
        The simple simulation below features a number of agents which perform a
        "random walk" through 3D space. That is to say that at each time-step,
        the agents will move in a random direction.
      </para><programlisting>
#
# RandomWalker is a simulation in which small spheres do
# a random walk.  This is a very simple simulation which
# can be used as a skeleton for more complex simulations.
#

# include some required breve class files
@use Control.
@use Mobile.

# First tell the breve engine the name of our controller class

Controller myControl.             

# Subclass "Control" and define our "myControl" object.

Control : myControl {
    # Here we define the class variables.  

    + variables:
        walkerShape (object).
        
    # Next we define a method called init.  The init method is called 
    # automatically when our class is created.  Since this is the controller
    # class, an instance gets created when we launch the simulation,
    # so this is the entry point for our simulation.
        
    + to init:
        print "Setting up the simulation.".

        self point-camera at (0, 0, 0) from (0, 60, 0).

        # set up a shape that all of the RandomWalker objects will use.
        
        walkerShape = (new Sphere init-with radius 1).
        
        # Create a bunch of RandomWalkers.  You can create as few or 
        # as many as you want... 

        200 new RandomWalker.

    # The get-walker-shape is a method that allows other objects 
    # to look at the walkerShape variable.  we do this so that 
    # each RandomWalker object can reuse the same Shape object.
    # This is not strictly required--each RandomWalker could create
    # it's own copy of the same Shape, but fewer objects means 
    # less memory used and more efficient simulations, so it's 
    # a good programming practice.
        
    + to get-walker-shape:
        return walkerShape.
}

# The "RandomWalker" object is the physical object in the simulation
# that does the random walk.  It is a subclass of "Mobile".

Mobile : RandomWalker {
    + to init:
        # During init, the object asks the controller for the shape 
        # it should use.  It then sets itself to a random color.

        self set-shape to (controller get-walker-shape).
        self set-color to random[(1.0, 1.0, 1.0)].
    
    + to iterate:
        # Set a new random velocity at every timestep.
        
        self set-velocity to random[(60, 60, 60)] - (30, 30, 30).
}
</programlisting>
<section id="node-2635">
<title>Comments</title>
<para>
        When writing code in any language, it is typically useful to include
        <emphasis>comments</emphasis> which clarify what the code is
        doing. In steve, there are two ways to include comments in code. A
        "single line" comment starts with a "#" is and continues to the end of
        the line; "multiline comments" are written starting with "#!" and
        ending with "!#". Some example of both kinds of comments are shown
        below:
      </para><programlisting>
        # this is a simple one-line comment.

        print "this is not a comment..."                # but this is.

        #!
                this
                is 
                a 
                multiline 
                comment
        !#
</programlisting>
</section>
</section>
<section id="node-2636">
<title>The Controller Object</title>
<para> The
        <emphasis>controller object</emphasis> is the foundation of a
        <emphasis>breve</emphasis> simulation. The controller
        object is a single instance which acts as the "boss" for the
        simulation. When the simulation starts, it is the controller object
        which is responsible for creating and setting up the rest of the
        simulation. <emphasis>The controller object is the
        only object which is automatically instantiated when the simulation
        begins</emphasis>. If you're used to programming in C or C++, the
        controller is like the <literal>main</literal> function.
      </para><para>
        The first step in writing a <emphasis>breve</emphasis> simulation is to create a controller
        class which will setup and manage the simulation. The controller class
        you create <emphasis>must be a subclass of the class
        <ulink url="http://www.spiderland.org/documentation/classes/Control.html">Control</ulink> or one of its subclasses</emphasis>. Details
        on how to do this is described in the rest of this chapter.
      </para><para>
        As shown in the previous section (<xref linkend="node-2634"/>), the controller object is
        specified at the top of your simulation file using the word
        <emphasis>controller</emphasis>:
      </para><programlisting>
Controller <emphasis><function>myControllerClass</function></emphasis>.
</programlisting><para>
        This tells <emphasis>breve</emphasis> to create an
        instance of <emphasis><function>myControllerClass</function></emphasis>
        when the simulation begins. This controller object will create and
        setup the rest of the objects in the simulation. The controller object
        does so by implementing the simulation setup code in the <literal>init</literal> method. Details on constructing classes and
        implementing an <literal>init</literal> method are described
        in more detail in the rest of this chapter.
      </para><para>
        In addition to setting up the simulation, the controller object is also
        used as a liaison between simulation objects, the <emphasis>breve</emphasis> engine and the user. While other
        instances may come and go, the controller object is forever. The
        controller class contains a great number of methods for controlling the
        behavior of simulations, the appearance of the graphical display and
        interactions with the user interface. See the class documentation on
        <ulink url="http://www.spiderland.org/documentation/classes/Control.html">Control</ulink> for more information. As with some of the
        other topics covered in this section, the significance of these
        concepts will become clearer in the rest of the documentation.
      </para>
</section>
<section id="node-2637">
<title>Building Classes</title>
<para> All objects
        in the simulated world correspond to programming objects in steve. In
        order to define an agent in the simulated world, you'll start by
        constructing a programming object, or class. This class will serve as a
        template which defines the agent's behaviors. This section describes
        how to construct and use these classes.
      </para><para>
        The section Defining Classes (<xref linkend="node-2638"/>) describes how to define an
        empty class.
      </para><para>
        All classes have two major components: <emphasis>methods</emphasis>, which define a class's behavior and
        <emphasis>variables</emphasis> which define the data that the
        class can hold. This data can be used both to store information about
        the state of the agent, or information required for computation. The
        section Defining Instance Variables (<xref linkend="node-2639"/>) details how
        variables can be added to objects, while the section Defining Class
        Methods (<xref linkend="node-2640"/>) shows how method are
        defined.
      </para><para>
        Two special methods are critical for an agents behavior: one that gets
        called automatically when the agent is created, <literal>init</literal>, and another which is run automatically at every
        step of the simulation, <literal>iterate</literal>. These
        methods, and a few other special methods are discussed in the section
        Special Method Names (<xref linkend="node-2642"/>)
      </para><para>
        Even after the class is defined, it will still not be present in the
        simulation. This is because a class is nothing more than a "template"
        for an agent. In order to bring agents into the simulation, you must
        use the template to create <emphasis>instances</emphasis> of the class.
        The section on Creating and Destroying Instances (<xref linkend="node-2643"/>) describes
        how instances of classes are created and destroyed.
      </para>
<section id="node-2638">
<title>Defining Classes</title>
<para> When building a class, you
        typically don't start from scratch&#x2014;instead, you make the new
        class the child of an existing class. This is called creating a
        <emphasis>subclass</emphasis>. By subclassing a class, the new
        class will inherit all of the parent's methods and variables. This
        approach means that most of the difficult work will already be done by
        an existing breve class, and we can simply override and customize the
        behaviors that we need to.
      </para><para>
        For example, if we're building an object which will move through the 3D
        world, we'd like to have an object that understands the relationship
        between position, velocity and acceleration. Instead of implementing
        such a class ourselves, we can subclass <ulink url="http://www.spiderland.org/documentation/classes/Mobile.html">Mobile.tz</ulink> which is included with breve. Our custom subclass
        will contain the custom behaviors we desire, while the parent class
        takes care of the details.
      </para><para>
        When building a class, you must first decide the class name and its
        parent class. The parent class is the class from which the new class
        will inherit its behaviors. Classes which are to be used primarily for
        computation and do not require any special inherited behaviors, will
        typically use the generic root class <ulink url="http://www.spiderland.org/documentation/classes/Object.html">Object</ulink>. Classes which move around the world will inherit
        behaviors from <ulink url="http://www.spiderland.org/documentation/classes/Mobile.html">Mobile</ulink>, while immobile objects in the world will inherit
        behaviors from <ulink url="http://www.spiderland.org/documentation/classes/Stationary.html">Stationary</ulink>. A full list of classes is available in
        the appendix (???).
      </para><para>
        An empty class is simply defined by the following steve code:
      </para><programlisting><emphasis><function>parent_class_name</function></emphasis> : <emphasis><function>class_name</function></emphasis> {

}
</programlisting><para>
        Because we often deal with classes in their plural form (like when
        creating multiple instances of an object), it can be useful to give a
        class an alias which will allow us to refer to the class in its plural
        form. <emphasis>This is not required</emphasis> but
        may make code easier to read. This alias is defined by adding the text
        <literal>(aka <emphasis><function>alias_name</function></emphasis>)</literal> after the class
        name.
      </para><para>
        As an example of defining a class, both with and without an alias,
        consider a class called <literal>myMobile</literal> which
        will be a child of the class <literal>Mobile</literal>:
      </para><programlisting>
# first without the alias...

Mobile : myMobile {

}

# now with the alias...

Mobile : myMobile (aka myMobiles) {

}
</programlisting><para>
        This code above defines an empty class with no variables and no
        methods. This means that it will behave exactly as its parent class
        does. The next step is to customize the class' behavior by adding in
        methods and variables.
      </para>
</section>
<section id="node-2639">
<title>Defining Instance Variables</title>
<para> An <emphasis>instance variable</emphasis> is a variable associated with a
        class. Each instance of the class will have it's own private copies of
        the class' instance variables.
      </para><para>
        Once the empty class declaration has been written, variables can be
        added using the heading <literal>+ variables</literal>,
        followed by the list of instance variables. Variables are listed in the
        format <literal><emphasis><function>variable_name</function></emphasis>, (<emphasis><function>variable_type</function></emphasis>).</literal></para><para>
        The variable name must start with a letter, but afterwords may contain
        any alphanumeric characters, as well as the characters _ and -.
      </para><para>
        Multiple variables of the same type can also be declared on the same
        line:
      </para><programlisting><emphasis><function>variable1</function></emphasis>, <emphasis><function>variable2</function></emphasis>, <emphasis><function>variable3</function></emphasis>, ... (<emphasis><function>variableType</function></emphasis>). 
</programlisting><para>
        Variable types are covered in detail in the section Types (<xref linkend="node-2644"/>).
      </para><para>
        As an example, we'll add some variables to the simple class we created
        in the previous section:
      </para><programlisting>
Mobile : myMobile {
        + variables:
                myInt, myOtherInt (int).
                myObject (object).
                myFloat (float).
}
</programlisting>
</section>
<section id="node-2640">
<title>Defining Methods</title>
<para> The most simple method call in
        steve is a call to a method which takes no arguments. The definition of
        such an method is simple. Inside the definition of instanceName, we
        create a line:
      </para><programlisting>
+ to <emphasis><function>methodName</function></emphasis>:
</programlisting><para>
        The statements which follow this line will be part of the newly defined
        method until either the end of the object definition, or until the next
        method definition.
      </para><para>
        To define an method which takes arguments we will need the keyword,
        variable name and type of each argument. The keyword identifies the
        variable when it is being called, while the variable name is how the
        variable will be referenced from within the method. Finally, the type
        is simply the type of variable that will be passed in. The layout of
        this information is <literal><emphasis><function>keyword</function></emphasis>, <emphasis><function>variable_name</function></emphasis>, (<emphasis><function>type</function></emphasis>)</literal>, such that a method which
        takes one variable could be defined by the following line:
      </para><programlisting>
+ to set-velocity to-value theValue (float):
</programlisting><para>
        If the method takes two variables, we add another keyword/name/type
        triplet:
      </para><programlisting>
+ to set-rotation of-joint theJoint (Object) to-value theValue (float):
</programlisting><para>
        The code associated with the second method would then use the variables
        <literal>theJoint</literal> and <literal>theValue</literal>: "of-joint" and "to-value" are not actual
        variables, but instead the keywords which indicate which variables
        follows.
      </para><para>
        The calling convention of these methods is simple. After the instance
        name and method name, we give a list of keywords and values to be
        passed in. The order of the keyword/value pairs does not affect how the
        code is executed, though it may effect the readability of the code. The
        following lines call the <literal>set-rotation</literal>
        method which we defined above:
      </para><programlisting>
# the following lines are equivalent

myObject set-rotation of-joint myJoint to-value 200.
myObject set-rotation to-value 200 of-joint myJoint.
</programlisting><para>
        Methods may also have local variables associated with them. These
        variable definitions look just like class variable definitions, except
        that they follow after the method definition line, and not after the
        variable definition line. Method variables are automatically
        initialized to zero every time the method is called. Variable
        declarations in a method must precede all statements in the method.
      </para><para>
        For example, here is a simple method which uses local variables:
      </para><programlisting>
+ to find-closest-creature in creatureList (list):
        item (object).
        closestItem (object).
        distance (float).

        # we start with a unreasonably high "closestDistance" so that 
        # we are sure to find something closer.

        closestDistance = 1000000.

        foreach item in creatureList: {
                distance = |(self get-location) - (item get-location)|.

                if distance &lt; closestDistance: {
                        closestItem = item.
                        closestDistance = distance.
                }
        }

        return closestItem.
</programlisting><note><title>
              For developer use only
            </title><para>
                When examining the internal classes included with the breve
                distribution, you might notice some methods defined using a
                minus sign instead of a plus sign:
              </para><programlisting>
- to methodName:
</programlisting><para>
                This syntax simple means that the method should be treated as a
                non-public method and that the method should not be documented.
                Though these methods function as all other methods, their use
                in user simulations is discouraged.
              </para></note>
</section>
<section id="node-2641">
<title>Optional Arguments in Methods</title>
<para>
        Methods definitions may also specify <emphasis>optional
        arguments</emphasis>. Optional arguments are arguments which are given
        default values, and therefore do not need to be provided when calling
        the method. Optional arguments can greatly simplify writing code in
        steve.
      </para><para>
        To make an argument optional, you need to provide it with a default
        value. To do so, you'll need to modify the argument definition to
        include the text <literal>= <emphasis><function>value</function></emphasis></literal> after the argument name.
        For example, a variable called <literal>theHeight</literal>
        with keyword <literal>with-height</literal> could be given a
        default value like this: <literal>with-height theHeight =
        100 (int)</literal>. Default values for optional arguments must be literal
        values (and not expressions or variables).
      </para><para>
        Below is an example of a method defined with a set of optional
        arguments.
      </para><programlisting>
        # Create a new agent, with some default values.

        + to create-new-agent with-color color = (1, 0, 0) (vector) 
                with-energy energy = 100 (int)
                with-radius radius = 10 (int) 
                with-name name = "agent" (string):
</programlisting><para>
        The method above could be called in a number of ways, optionally
        including or excluding each of the arguments:
      </para><programlisting>
        # no arguments 
        self create-new-agent.

        # some of the arguments 
        self create-new-agent with-energy 10 with-name "Becky".

        # all of the arguments
        self create-new-agent with-color (1, 1, 1) 
                with-energy 100
                with-radius 20
                with-name "Robert".
</programlisting>
</section>
<section id="node-2642">
<title>Special Method Names</title>
<para>
        Certain method names have special meaning in steve, in that they are
        called automatically by the simulation at special times. These methods,
        in particular <literal>init</literal> and <literal>iterate</literal> are critical, as they are the entry-point
        into how your agents are initialized and how they will behave. These
        special method names are outlined below:
      </para><itemizedlist><listitem><para><literal>init</literal>, if it exists, is called
              automatically when a class is instantiated. The method is called
              not only for the class being instantiated, but also for its
              superclass and all other ancestors up to the root object. Though
              you should implement an init method for your class which will set
              up the instance when the class is instantiated, the init method
              should never be called manually.
            </para></listitem><listitem><para><literal>iterate</literal>, if it exists, is called
              automatically during every iteration of the breve engine. If your
              class must perform a task during each iteration, then you may
              choose to implement an iterate method. The order in which the
              objects in the simulation are iterated cannot be
              controlled&#x2014;if you need to control the order in which
              actions are performed, consider using iterate in conjunction with
              the post-iterate method described below.
            </para><para>
              Unlike the <literal>init</literal> and <literal>destroy</literal> methods, <literal>iterate</literal> is not automatically called for the
              superclasses of an instance. This means that your iterate method
              must call super iterate if you wish to incorporate the parent's
              iterate method. This is absolutely necessary for subclasses of
              Control.
            </para></listitem><listitem><para><literal>post-iterate</literal>, if it exists, is
              called automatically during every iteration of the breve engine
              after the iterate methods for all objects have been called. It is
              occasionally desirable to perform an action during each
              iteration, which requires data produced during that very same
              iteration from other objects. If this action is to be performed
              in the iterate method, than object A cannot be certain that
              object B has been iterated yet (and vice-versa). To solve this
              problem, objects may implement a post-iterate method which is
              automatically called after all objects have been iterated. The
              PatchLife demo uses this technique.
            </para></listitem><listitem><para><literal>destroy</literal>, if it exists, is called
              automatically when a class is being freed. However, unlike init,
              and like iterate, you must explicitly call the super class
              destroy method if you need it to be called as well. If your class
              needs to perform certain tasks before being destroyed, you should
              implement this method. Be warned the you need to be carefull not
              to free an object referenced in the base class if it is needed
              for the base class destroy method.
            </para></listitem></itemizedlist>
</section>
<section id="node-2643">
<title>Creating and Destroying Instances</title>
<para>
        Creating a new instance of an object is called instantiating the
        object. Instantiating in steve is done using the new command.
        Instantiation creates a single new instance if no number is given, or
        as many objects as you want by preceding the command with a number. The
        syntax follows:
      </para><programlisting>
new object_type.
number new object_type.
</programlisting><para>
        If a single object is created, it is returned as an object type. If
        several are created, they are returned as a list. For example:
      </para><programlisting>
myBird (object).
myBugs (list).

myBird = new Bird.
myBugs = 100 new Bugs.
</programlisting><para>
        The method init is called automatically for a class and all of its
        superclasses when the class is instantiated.
      </para><para>
        Destroying instances is simply accomplished using the command
        <literal>free</literal>:
      </para><programlisting>
free instance.
</programlisting><para><literal>free</literal> accepts both single instances and
        lists of instances.
      </para><para>
        If an instance frees itself, then execution of the code is stopped
        immediately, as though the <literal>free</literal> command
        was followed by a <literal>return</literal>.
      </para><para>
        When an object is freed, the <literal>destroy</literal>
        method is automatically called for the instance. Prior to version 1.9,
        <literal>destroy</literal> would automatically be called for
        all superclasses. This is no longer the case&#x2014;you must call "super
        destroy" if you wish for the superclass destroy method to be run.
      </para>
</section>
</section>
<section id="node-2644">
<title>Types in "steve"</title>
<section id="node-2645">
<title>The int type</title>
<para>
        An <literal>int</literal> is a whole number, identical to the
        <literal>int</literal> type in C.
      </para>
<section id="node-2646">
<title>int operators</title>
<para>
        ints can be operated on using the following mathematical operators,
        which operate just like their C counterparts: +, -, *, /, % and ^
        (power). Divisions or mods by zero are treated as errors and will stop
        the execution of the simulation. The absolute value of an integer is
        given by | <emphasis><function>integer expression</function></emphasis>
        |.
      </para>
</section>
<section id="node-2647">
<title>Conversions to Other Types</title>
<para>
        ints can be converted to floats automatically in expressions or during
        assignments, but cannot be converted to any other type.
      </para>
</section>
</section>
<section id="node-2648">
<title>The float type</title>
<para> A real number, also
        known as "double", identical to the <literal>double</literal> type in C. Internally, floats are represented
        by 8-byte doubles.
      </para>
<section id="node-2649">
<title>float Operators</title>
<para>
        All of the operators used for ints&#x2014;including %&#x2014;can also be
        applied to floats.
      </para>
</section>
<section id="node-2650">
<title>Conversions to Other Types</title>
<para><literal>floats</literal> can be converted to (and from)
        <literal>ints</literal> automatically in expressions or
        assignments. <literal>floats</literal> cannot be converted
        to any other type.
      </para>
</section>
</section>
<section id="node-2651">
<title>The object Type</title>
<para> An
        <literal>object</literal> is an <emphasis>instance</emphasis> of a steve class.
      </para>
<section id="node-2652">
<title>object Operators</title>
<para><literal>objects</literal> cannot used in mathematical
        expressions as some of the other types can. Instead, <literal>objects</literal> are mainly used for one type of expression:
        method calling. Method calling is outlined in the section Method Calls
        (<xref linkend="node-2680"/>).
      </para>
</section>
<section id="node-2653">
<title>Conversion to Other Types</title>
<para>
        Objects cannot be explicitly converted to other types. They do,
        however, have meaning as "boolean" (true or false) expressions in
        control structures (<xref linkend="node-2685"/>). If used in the
        context of a boolean expression (like an <literal>if</literal> statement, <xref linkend="node-2686"/>), the expression is true only
        if the variable refers to an active object. This means that an object
        variable which has not yet been associated with an instance in the
        simulation is false.
      </para>
</section>
</section>
<section id="node-2654">
<title>The vector Type</title>
<para> A vector is
        used to represent a point or vector in 3D space. A vector is expressed
        as three floating point numbers, such as (1.0, 2.0, 5.0).
      </para>
<section id="node-2655">
<title>vector Operators</title>
<para>
        Vectors may be added (+) to and subtracted (-) from other vectors,
        which yields another vector. Vectors may be multiplied (*) or divided
        (/) by ints or floats, which also results in other vectors. The length
        of the vector is given using the following construct: | <emphasis><function>vector expression</function></emphasis> |.
      </para><para>
        Some examples of using vectors follow:
      </para><programlisting>
v = (1, 2, 3).  # sets the vector to a constant vector.

v = v * 4.      # multiplies the vector by 4

v = v / |v|.    # normalizes the vector by dividing it by it's own 
                                # length such that the new length is 1.
</programlisting><para>
        Individual vector components can be extracted or set using the "::"
        notation:
      </para><programlisting>
xValue = myVector::x.

myVector::y = 100.
</programlisting><para>
        Starting in breve 2.5, the standard list index syntax may also be used
        with indices 0, 1, and 2:
      </para><programlisting>
xValue = myVector{ 0 }.

myVector{ 1 } = 100.
</programlisting>
</section>
<section id="node-2656">
<title>Conversions to Other Types</title>
<para>
        Vectors cannot be converted to any other types. They do, however, have
        meaning as "boolean" (true or false) expressions in control structures
        (<xref linkend="node-2685"/>). If used in the
        context of a boolean expression (like an <literal>if</literal> statement, <xref linkend="node-2686"/>), the vector will be true if
        it's length is greater than 0, and false if its length is equal to 0.
        This is to say that only the vector (0, 0, 0) is false in a boolean
        context.
      </para>
</section>
</section>
<section id="node-2657">
<title>The matrix type</title>
<para> A <emphasis>matrix</emphasis> in steve refers to a 3x3 matrix which describes
        a transformation in 3D space. Using transformation matrices is somewhat
        advanced and they are not generally used in most simulations. Still,
        they may be useful when dealing with physical simulation.
      </para><para>
        Matrices may be written in steve as three comma-separated vectors,
        enclosed in braces ('[' and ']'), as in this example:
      </para><programlisting>
# the matrix m will be initialized to:
#
# [ 1 2 3 ]
# [ 4 5 6 ]
# [ 7 8 9 ]

m = [ (1, 2, 3), (4, 5, 6), (7, 8, 9) ].
</programlisting><para>
        Matrix component can be extracted using the list index syntax. Each row
        of the matrix is a vector:
      </para><programlisting>
myVector = myMatrix{ 0 }.

myMatrix{ 1 } = ( 1, 2, 3 ).
</programlisting><para>
        Individual numbers can be extracted by the matrix as a two-dimensional
        list:
      </para><programlisting>
myNumber = myMatrix{ 0 }{ 0 }.

myMatrix{ 1 }{ 1 } = 100.
</programlisting>
<section id="node-2658">
<title>matrix Operators</title>
<para>
        Matrices may be multiplied (*), divided (/), added (+) to and
        subtracted (-) from other matrices. The results of these operations are
        other matrices.
      </para><para>
        Matrices may be multiplied (*) or divided (/) by scalars (ints and
        doubles). The result of these operations are other matrices.
      </para><para>
        Matrices may be used to transform vectors by multiplying the matrix
        times the vector (*). The result of this operation is a vector.
      </para>
</section>
<section id="node-2659">
<title>Conversions to Other Types</title>
<para>
        Matrices cannot be converted to any other types. They do, however, have
        meaning as "boolean" (true or false) expressions in control structures
        (<xref linkend="node-2685"/>). If used in the
        context of a boolean expression (like an <literal>if</literal> statement, <xref linkend="node-2686"/>), the expression will be true
        if there are any non-zero values in the matrix. This means that a
        matrix of all zeros will be false, while all other matrices are true.
      </para>
</section>
</section>
<section id="node-2660">
<title>The list Type</title>
<para> The
        <literal>list</literal> datatype allows you to keep a list
        of other variables. lists can contain any datatype, including other
        lists. lists can even contain multiple datatypes simultaneously.
      </para><para><literal>lists</literal> are formed using the syntax
        <literal>{ <emphasis><function>item1</function></emphasis>, , <emphasis><function>item2</function></emphasis>, , <function>...</function> }</literal>.
      </para><para>
        Some simple examples of constructing <literal>lists</literal> are shown below:
      </para><programlisting>
myList = { 1, 2, 3.0 }.                 # a list of numbers (both int and float)
myList = { "a", "b", "c" }.             # a list of strings
myList = { "a", 30, new Mobile }.       # a list of mixed types
myList = { 1, "a", { "dog", "cow" } }.  # a list with a nested list
</programlisting><para>
        An important feature of lists in steve is that they are always passed
        by reference and are not copied. This means that if you pass a list to
        a function, then any modifications done to the list inside the function
        will modify the original list.
      </para>
<section id="node-2661">
<title>list Operators</title>
<para>
        The following operations can be used with <literal>list</literal> expressions:
      </para><itemizedlist><listitem><para><literal>insert <emphasis><function>expression</function></emphasis>, at <emphasis><function>list</function></emphasis>, { <emphasis><function>index</function></emphasis> }</literal>: inserts
              <emphasis><function>expression</function></emphasis> at the
              specified index in the list, shifting up other list elements with
              higher indices
            </para></listitem><listitem><para><literal>remove <emphasis><function>list</function></emphasis>, { <emphasis><function>index</function></emphasis> }</literal>: removes the
              element of <emphasis><function>list</function></emphasis> at the
              specified index and returns it, shifting down other list elements
              with higher indices
            </para></listitem><listitem><para><literal>push <emphasis><function>expression</function></emphasis>, onto <emphasis><function>list</function></emphasis></literal>: appends <emphasis><function>expression</function></emphasis> onto the end of list
            </para></listitem><listitem><para><literal>pop <emphasis><function>list</function></emphasis></literal>: removes the last
              element of <emphasis><function>list</function></emphasis> and
              returns it
            </para></listitem><listitem><para><literal>prepend <emphasis><function>expression</function></emphasis>, onto <emphasis><function>list</function></emphasis></literal>: prepends <emphasis><function>expression</function></emphasis> onto the start of
              <emphasis><function>list</function></emphasis></para></listitem><listitem><para><literal>unprepend <emphasis><function>list</function></emphasis></literal>: removes the first
              element of <emphasis><function>list</function></emphasis> and
              returns it
            </para></listitem><listitem><para><literal><emphasis><function>list</function></emphasis>, { <emphasis><function>expression</function></emphasis> }</literal>: returns the
              element of the list at offset expression. The expression index is
              zero based, as in C, such that 0 refers to the first element, 1
              to the second, and so forth. If the offset expression is less
              than zero, or greater than the length of the list minus one
              (because the access is zero based), an error is triggered and the
              simulation is stopped.
            </para></listitem><listitem><para><literal><emphasis><function>list</function></emphasis>, { <emphasis><function>expression</function></emphasis>, } = <emphasis><function>value</function></emphasis></literal>: sets an element of
              the list at offset expression to value. The offset index is again
              zero based. If the offset expression is less than zero or greater
              than the size of the list an error is triggered and the
              simulation is stopped. If the offset expression is equal to the
              size of the list, the list is extended by one element; the
              operation has the same effect as pushing a value on to the end.
            </para></listitem><listitem><para><literal>sort <emphasis><function>list</function></emphasis>, with <emphasis><function>method-name</function></emphasis></literal>: sorts
              <emphasis><function>list</function></emphasis> using the method
              specified with <emphasis><function>method-name</function></emphasis>. <emphasis><function>method-name</function></emphasis> must be a method
              which takes two list elements (the keywords are unimportant) and
              compares them, returning a negative number if the first list
              element belongs before the second in the sorted list, a positive
              number if the second belongs before the first, and 0 if the two
              entries are equal. In most cases, this confusing sounding method
              returns a certain value associated with one argument minus the
              same value in the other.
            </para><para>
              Unlike the perl sort operator, <literal>sort</literal>
              operates on the list it is given and does not return a copy of
              it. This means that the original list is modified during the sort
              operation.
            </para></listitem><listitem><para><literal>copylist <emphasis><function>list</function></emphasis></literal>: copies the entire
              list. Normally, assigning a list to a variable will <emphasis>not</emphasis> copy the list but instead will
              yield two variables pointing to the <emphasis>same</emphasis> list.
            </para></listitem><listitem><para><literal>| <emphasis><function>list</function></emphasis> |</literal>: gives the length
              of a list. Lists are automatically converted to integers when use
              in mathematical expressions, but this construct can be used too
              force the conversion.
            </para></listitem></itemizedlist>
</section>
<section id="node-2662">
<title>Conversions to Other Types</title>
<para><literal>lists</literal> can be converted to <literal>ints</literal> simply by using them in the context of integers.
        They can thus also be used as <literal>floats</literal>. In
        the event that the context of the expression does not force the list to
        become an integer, you can force it yourself by using it in a
        mathematical context:
      </para><programlisting>
myInt = (myList + 0).
</programlisting>
</section>
</section>
<section id="node-2663">
<title>The string Type</title>
<para>
        The string type holds a character string. A string is written in code
        (as in C) as a quoted string. For example, the built-in print operator
        is capable of printing strings:
      </para><programlisting>
print "this is a string".
</programlisting>
<section id="node-2664">
<title>string Operators</title>
<para>
          The following operations can be done one strings:
        </para><itemizedlist><listitem><para><literal><emphasis><function>string</function></emphasis> { <emphasis><function>index</function></emphasis> }</literal>: returns, as a
              string, the letter at the specified index.
            </para></listitem><listitem><para><literal><emphasis><function>string</function></emphasis> { <emphasis><function>index</function></emphasis> } = <emphasis><function>otherString</function></emphasis></literal>: replaces the
              letter at the specified location with the string <emphasis><function>otherString</function></emphasis>.
            </para></listitem><listitem><para><literal>| <emphasis><function>string</function></emphasis> |</literal>: returns the
              length of the string.
            </para></listitem></itemizedlist><para>
        In addition to the operators listed above, strings can be formatted
        using embedded variables. Variables can be embedded in strings so that
        the strings are interpreted dynamically, as in Perl. To indicate a
        variable embedded in a string, use the "$" character. The following,
        for example, will use the variable "self" in order to build a string to
        be printed:
      </para><programlisting>
print "my value is $self.".
</programlisting><para>
        This technique can be used to performing string concatenations as well:
      </para><programlisting>
$longstring = "$string1$string2".
</programlisting>
</section>
<section id="node-2665">
<title>Conversions to Other Types</title>
<para>
        strings can be converted to <literal>ints</literal> and
        <literal>floats</literal>, but not to any other types.
        types.
      </para><para>
        In the context of an int or a float, the string becomes the appropriate
        type by taking the numerical component of the string. For more
        information on this conversion, consult the man pages for the ANSI C
        <literal>atoi()</literal> (for <literal>ints</literal>) or <literal>atof()</literal> (for
        <literal>doubles</literal>) functions.
      </para>
</section>
</section>
<section id="node-2666">
<title>The hash Type</title>
<para> A hash is a
        type which works like a dictionary: it allows expressions ("values") to
        be stored and looked-up using other expressions as the "keys". The
        following example shows a steve hash being used like a dictionary:
      </para><programlisting>
dictionary (hash).

dictionary{ "dog" } = "a four-legged pet".
dictionary{ "fish" } = "a zero-legged pet".

# this will print the definition we stored above.

print "the definition of dog is: ", dictionary{ "dog" }.
</programlisting><para>
        As shown in this example, we're able to store data using strings as the
        keys. When data is later retrieved from the hash table using the same
        key, the value stored previously is returned.
      </para><para>
        hashes are not limited to using strings as keys. They can use any valid
        type. The most useful application is a hash table which uses objects as
        keys. In this way, relationships between objects can be stored in a
        hash. Consider an object which wants to keep track of neighbors it has
        encountered previously:
      </para><programlisting>
# let's say that this method gets called when a neighbor is seen...
# if the neighbor has already been seen, print a message &#x2014; otherwise,
# just add it to the hash for next time!

+ to meet with neighbor (object):
        if seenHash{ neighbor }: print "i've seen this neighbor before!"
        else seenHash{ neighbor } = 1.
</programlisting><para>
        The example above also shows that the syntax of hashes is the same as
        the syntax for lists when storing or retrieving data. Unlike lists,
        however, hashes do not hold ordered data, and none of the other list
        operators work with hashes.
      </para><para>
        When using hashes with ints, floats, vectors, matrices and strings,
        then steve will test the equivalence of the key when looking up or
        storing the data. This means that two equivalent strings, even if they
        are stored in different variables, will refer to the same value in the
        hash. For the other types (objects, pointers, data, lists and hashes
        themselves), the hash will only return the same value for the same
        exact variable key. This means that two different lists, even if they
        contain "equal" data, will access different values in the hash.
      </para><para>
        An important feature of hashes in steve is that they are always passed
        by reference and are not copied. This means that if you pass a hash to
        a function, then any modifications done to the hash inside the function
        will modify the original hash.
      </para>
<section id="node-2667">
<title>hash Operators</title>
<para>
        A list of the keys in a hash may be retrieved using the built-in
        function <literal>keys</literal>. This key list is often
        used to iterate through the items in a hash:
      </para><programlisting>
foreach key in keys( myHash ): {
        print myHash{ key }.
}
</programlisting>
</section>
<section id="node-2668">
<title>Conversion to Other Types</title>
<para>
        hashes cannot be converted to any other types.
      </para>
</section>
</section>
<section id="node-2669">
<title>The pointer Type</title>
<note><title>
              For developer use only
            </title><para> The
                <literal>pointer</literal> type is for use by breve
                and plugin developers only.
              </para></note><para>
        pointer variables store C-style pointers to internal data. They are not
        used for writing simulations in steve and are only used by breve
        developers and plugin authors.
      </para><para>
        pointer variables are only useful in the context of interacting with
        internal C-style function calls: they do not contain methods, variables
        or any other meaning in the context of most steve code. Like objects,
        however, pointers can be tested to see if they are NULL (0), but cannot
        be used in mathematical expressions. That is to say that pointers have
        a meaning in a boolean context of control structures such as
        <emphasis>if</emphasis> and <emphasis>while</emphasis> (as well as the logical operators
        <emphasis>&amp;&amp;</emphasis> and <emphasis>||</emphasis>).
      </para><para>
        Copying a pointer (assigning it to another variable), as in C, will not
        copy the data is points to.
      </para>
<section id="node-2670">
<title>Conversion to Other Types</title>
<para>
        pointers cannot be converted to any other types.
      </para>
</section>
</section>
<section id="node-2671">
<title>The data Type</title>
<note><title>
              For developer use only
            </title><para>
                The <literal>data</literal> type is for use by breve
                and plugin developers only.
              </para></note><para><literal>data</literal> variables are similar to pointer variables in
        that they contain a reference to internal data. Also like pointer
        variables, they are not to be used in regular simulation
        code&#x2014;they are only to be used by breve developers and custom
        plugins.
      </para><para>
        The different between <literal>data</literal> and
        <literal>pointer</literal> is that <literal>data</literal> refers to a linear block of internal data of
        known size. This means that <literal>data</literal>
        variables can be successfully archived, while pointers cannot.
        <emphasis>The only use for <function>data</function> variables is archiving and dearchiving internal
        data</emphasis>. For more information on using the <literal>data</literal> type with plugins, see the section on Archiving
        Plugin Data With The <literal>data</literal> Type (<xref linkend="node-2778"/>).
      </para>
</section>
</section>
<section id="node-2673">
<title>Expressions</title>
<section id="node-2674">
<title>Special variables and values</title>
<para>
        Certain variables have special meanings in steve. Their values are
        managed automatically by the breve engine and should not be assigned
        manually.
      </para><itemizedlist><listitem><para><literal>self (object)</literal>.
            </para><para> This
              variable always contains the value of the instantiation in which
              the current method is being run. The variable is used most
              frequently to call other methods within the same instantiation.
              For example, an object of class Mobile could move itself with the
              call:
            </para><programlisting>
    self move to (10, 10, 10).
</programlisting></listitem><listitem><para><literal>super (object)</literal>.
            </para><para> This
              special value refers to the parent, or super-instance. This is
              used to invoke a parent class implementation of a method, instead
              of the current class implementation.
            </para><para>
              For example, in the Controller's iterate method, the superclass
              iterate method is often called: super iterate. This is because
              custom subclasses of Control typically preform simulation
              specific tasks, but must then call on the superclass
              implementation (Control) to actually step the physical simulation
              forward and update the state of the world. Anytime you wish to
              implement a custom object behavior <emphasis>in
              addition</emphasis> a parent class behavior, you should invoke
              the parent class method as well.
            </para></listitem><listitem><para><literal>controller (object)</literal>.
            </para><para> The
              controller variable is defined for all instances. It always
              refers to the simulation's controller instance.
            </para></listitem></itemizedlist>
</section>
<section id="node-2675">
<title>Assignments</title>
<para> The most simple
        expressions are simple assignments of literal values to variables. It
        may help to refer to the documentation on steve types before
        continuing.
      </para><para>
        Below are a few examples of this type of expression. In each case, the
        variable on the left will take the value of the expression on the
        right. If the expression on the right is not the correct type, it will
        be automatically converted if possible. If the conversion is not
        possible, an error will occur.
      </para><programlisting>
myInt = 4.
myDouble = 12.345.
myString = "Hello!".
    
# If we assign a double to an int, it will be automatically converted by 
# truncating the decimal portion.  In this example, myInt will take the value 
# 4:  
    
myInt = 4.8.
    
# Likewise if we assign a string to a double or int.  The variable will take 
# the number value of the string, according to the atoi() or atof() ANSI C 
# functions.  Here the double will get the value 10000: 
     
myDouble = "10000 miles away.".
</programlisting>
</section>
<section id="node-2676">
<title>Mathematical Expressions</title>
<para>
        Mathematical operators in steve function almost exactly the same as
        they do in C, although there are some additions to account for vector
        and matrix types.
      </para><para>
        The following binary operators are valid for <literal>int</literal> and <literal>double</literal> types
        (the descriptions refer to x and y, as though they were used in an
        expression: <literal>x <emphasis><function>operator</function></emphasis> y</literal>): </para><itemizedlist><listitem><para><literal>+</literal>, addition
            </para></listitem><listitem><para><literal>-</literal>, subtraction
            </para></listitem><listitem><para><literal>*</literal>, multiplication
            </para></listitem><listitem><para><literal>/</literal>, division
            </para></listitem><listitem><para><literal>%</literal>, modulus (the remainder of x when
              divided by y)
            </para></listitem><listitem><para>
              ^, power (x raised to the power of y)
            </para></listitem></itemizedlist><para>
        Their functions should be self-explanatory, with the possible exception
        of modulus, which cannot be used with double types in C. When used with
        doubles, the result is calculated using the ANSI <literal>fmod()</literal> function.
      </para><para>
        The following operators are valid for use with two vectors:
      </para><itemizedlist><listitem><para><literal>+</literal>, vector addition
            </para></listitem><listitem><para><literal>-</literal>, vector subtraction
            </para></listitem></itemizedlist><para>
        The following operators are valid for a vector and a double (although
        an <literal>int</literal> is automatically promoted to a
        double in this case):
      </para><itemizedlist><listitem><para><literal>*</literal>, vector times scalar
              multiplication
            </para></listitem><listitem><para><literal>/</literal>, vector divided by scalar
              division
            </para></listitem></itemizedlist><para>
        As in many languages, parenthesis are used to group expressions when
        the default order of operations does not compute the desired result:
      </para><programlisting>
# this is the default order, but we can make it explicit with parens
x = x + (4 / y).                    # computes 4 / y first...

# this is NOT the default order -- we need to force it
x = (x + 4) / y.                    # computes x + 4 first
</programlisting><para>
        Mathematical expressions are often used in conjunction with assignments
        in order to modify the value of a variable. A few examples of using
        mathematical expressions in conjunction with assignments follow:
      </para><programlisting>
    x = x + 4.

    y = (1, 2, 3) / x.                  # assumes x is an int or double

    z = z + x^2.
</programlisting>
</section>
<section id="node-2677">
<title>Mathematical Assignment Expressions</title>
<para> In addition to the mathematical assignment operators
        above, steve also support <emphasis>mathematical
        assignment operators</emphasis>. Mathematical assignment operators are
        used as shortcuts to perform a calculation and update the value of a
        variable simultaneously, instead of as two separate steps. These
        expressions are useful, but since they are only shortcuts for other
        expressions, understanding them is not critical.
      </para><para>
        The following mathematical assignment operators are available:
      </para><itemizedlist><listitem><para><literal>+=</literal></para></listitem><listitem><para><literal>-=</literal></para></listitem><listitem><para><literal>*=</literal></para></listitem><listitem><para><literal>/=</literal></para></listitem><listitem><para><literal>%=</literal></para></listitem><listitem><para><literal>^=</literal></para></listitem></itemizedlist><para>
        These operators are simply shortcuts for cases in which the left
        operand of the mathematical expression is also the location where the
        output of the expression will be stored. For example, the following
        expression pairs are equivalent:
      </para><programlisting>
a = a + b.               # "a equals a plus b" can also be written as...
a += b.                  # "a plus equals b"

a = a - (2, 2, 2).
a -= (2, 2, 2).
</programlisting><para>
        steve also has "increment" and "decrement" assignment operators:
      </para><itemizedlist><listitem><para>
              ++
            </para></listitem><listitem><para>
              --
            </para></listitem></itemizedlist><para>
        As in languages like C and Perl, these operators increment and
        decrement a variable by one, respectively. Unlike C and Perl, these
        operators may <emphasis>only</emphasis> be placed
        after the variable. As an example, the following expression pairs are
        equivalent:
      </para><programlisting>
x = x + 1.          # updates the variable x by adding 1
x++.

x += 1.             # does the same...
x++.

y = (x += 1).       # a little confusing, but sets both x and y to (x + 1)
y = x++.            # as does this.
</programlisting>
</section>
<section id="node-2678">
<title>Mathematical Functions</title>
<para> A number of internal functions (which are otherwise
        typically not used in breve simulations) are available for math-related
        expressions. Internal functions are called just like C functions:
        <literal><emphasis><function>functionName</function></emphasis>, (<emphasis><function>arguments</function></emphasis>)</literal>.
      </para><itemizedlist><listitem><para><literal>sin(<emphasis><function>input</function></emphasis>)</literal> gives the sine of
              the radian angle <emphasis><function>input</function></emphasis>.
            </para></listitem><listitem><para><literal>cos(<emphasis><function>input</function></emphasis>)</literal> gives the cosine of
              the radian angle <emphasis><function>input</function></emphasis>.
            </para></listitem><listitem><para><literal>tan(<emphasis><function>input</function></emphasis>)</literal> gives the tangent
              of the radian angle <emphasis><function>input</function></emphasis>.
            </para></listitem><listitem><para><literal>asin(<emphasis><function>input</function></emphasis>)</literal> gives the radian
              angle arc sine of <emphasis><function>input</function></emphasis>.
            </para></listitem><listitem><para><literal>acos(<emphasis><function>input</function></emphasis>)</literal> gives the radian
              angle arc cosine of the <emphasis><function>input</function></emphasis>.
            </para></listitem><listitem><para><literal>atan(input)</literal> gives the radian angle
              arc tangent of <emphasis><function>input</function></emphasis>.
            </para></listitem><listitem><para><literal>sqrt(<emphasis><function>input</function></emphasis>)</literal> gives the
              <literal>float</literal> square root of <emphasis><function>input</function></emphasis>.
            </para></listitem><listitem><para><literal>angle(<emphasis><function>a</function></emphasis>, , <emphasis><function>b</function></emphasis>)</literal> gives the <literal>float</literal> angle in radians between vectors
              <emphasis><function>a</function></emphasis> and <emphasis><function>b</function></emphasis>.
            </para></listitem><listitem><para><literal>max(<emphasis><function>a</function></emphasis>, , <emphasis><function>b</function></emphasis>)</literal> gives the maximum of
              <literal>floats</literal><emphasis><function>a</function></emphasis> and <emphasis><function>b</function></emphasis>.
            </para></listitem><listitem><para><literal>min(<emphasis><function>a</function></emphasis>, , <emphasis><function>b</function></emphasis>)</literal> gives the minimum of
              <literal>floats</literal><emphasis><function>a</function></emphasis> and <emphasis><function>b</function></emphasis>.
            </para></listitem><listitem><para><literal>cross(<emphasis><function>v1</function></emphasis>, , <emphasis><function>v2</function></emphasis>)</literal> gives the vector cross
              product of vectors <emphasis><function>v1</function></emphasis>
              and <emphasis><function>v2</function></emphasis>.
            </para></listitem><listitem><para><literal>dot(<emphasis><function>v1</function></emphasis>, , <emphasis><function>v2</function></emphasis>)</literal> gives the float dot
              product of vectors <emphasis><function>v1</function></emphasis>
              and <emphasis><function>v2</function></emphasis>.
            </para></listitem><listitem><para><literal>log(<emphasis><function>input</function></emphasis>)</literal> gives the
              <literal>float</literal> natural log of <emphasis><function>input</function></emphasis>.
            </para></listitem><listitem><para><literal>randomGauss()</literal> gives a <literal>float</literal> random number with a Gaussian
              distribution.
            </para></listitem><listitem><para><literal>transpose(<emphasis><function>input</function></emphasis>)</literal> gives the transpose
              of the matrix <emphasis><function>input</function></emphasis>.
            </para></listitem></itemizedlist><para>
        The following internal functions are used for testing float variables
        for special values which have meaning primarily to developers and
        plugin authors.
      </para><itemizedlist><listitem><para><literal>isnan(<emphasis><function>input</function></emphasis>)</literal> returns 1 if the
              input is a "not-a-number" float value, 0 otherwise.
            </para></listitem><listitem><para><literal>isinf(<emphasis><function>input</function></emphasis>)</literal> returns 1 if the
              input is a float value representing infinity, 0 otherwise.
            </para></listitem></itemizedlist>
</section>
<section id="node-2679">
<title>Random Numbers</title>
<para> Random
        numbers are available in steve using the command <literal>random</literal>. The syntax is <literal>random[
        <emphasis><function>expression</function></emphasis> ]</literal>, where
        expression is an expression of either <literal>int</literal>
        (<xref linkend="node-2645"/>),
        <literal>float</literal> (<xref linkend="node-2648"/>) or <literal>vector</literal> (<xref linkend="node-2654"/>). The value returned is always
        the same type as the expression. In the case of <literal>int</literal> or <literal>float</literal>, the
        returned value is a random value between 0 and the expression. In the
        case of a <literal>vector</literal> expression, the returned
        value is a <literal>vector</literal> in which each element
        is between 0 and the corresponding value of the expression. For
        example, a call to <literal>random[(10, 10, 20)]</literal>
        returns a <literal>vector</literal> with X and Y elements
        between 0 and 10, and the Z element between 0 and 20.
      </para><para>
        Note that <literal>random[<emphasis><function>intValue</function></emphasis>]</literal> returns a value
        between 0 and <emphasis><function>intValue</function></emphasis>,
        inclusive, as opposed to the behavior that many C programmers expect in
        which the returned value is between 0 and <emphasis><function>intValue</function></emphasis> - 1.
      </para><para>
        Because many simulations use the origin (0, 0, 0) as the "center" of
        their world, it is often useful to obtain a random vector centered
        around (0, 0, 0). For example, if we want to move agents somewhere
        within an imaginary box surrounding the origin, we might use the
        expression <literal>random[(40, 40, 40)] - (20, 20,
        20)</literal>. This convention gives us a <literal>vector</literal> with each element between -20 and 20. This
        type of expression appears frequently in simulations.
      </para><para>
        The values are produced using the standard C library <literal>random()</literal> routine. The library is seeded with the
        current time when the breve application is launched. To explicitly set
        the random seed, you may call the internal function <literal>randomSeed( <emphasis><function>value</function></emphasis>
        )</literal>, where value is an integer.
      </para><para> In the event
        that multiple breve simulations are launched simultaneously (typically
        only relevant in cluster environments), it may be necessary to pick
        unique random seeds for each simulation to prevent each of the
        simulations from giving the same results. Refer to the <ulink url="http://www.spiderland.org/documentation/classes/Control.html">Controller</ulink> method <ulink url="http://www.spiderland.org/documentation/classes/Control.html#set-random-seed-from-dev-random">set-random-seed-from-dev-random</ulink> for more information
        on automatically picking unique random seeds on systems which support
        it.
      </para>
</section>
<section id="node-2680">
<title>Method Calls</title>
<para> As discussed
        in the section on defining class methods, each method is identified by
        a name and may have any number of input arguments. The most simple
        method call to a method with no arguments is simply:
      </para><programlisting><emphasis><function>instance</function></emphasis><emphasis><function>methodName</function></emphasis>.
</programlisting><para>
        If the method takes arguments, each argument is associated with a
        keyword: the keyword identifies which argument will follow and what
        it's type is. This is somewhat different from C where the argument's
        type and meaning is specified by its order relative to other arguments.
        The steve method is more similar to Objective C and allows a more
        natural language structure to method calls and protects against
        arguments being passed in the wrong order.
      </para><para>
        To pass arguments to the method, simply precede the argument value with
        the keyword name. Consider a method move-object which takes a keyword
        to:
      </para><programlisting>
myObject move-object to (1, 2, 3). 
</programlisting><para>
        If the method takes more than a single argument, the convention is the
        same&#x2014;just add the next argument afterwards. Note that the order
        in which the arguments are passed does not affect the method call,
        though it may affect the readability of the code. For example, the
        Control object implements a method to point the camera at a certain
        vector location from a vector offset&#x2014;first we'll see the method
        definition, then how it's called:
      </para><programlisting>
# if the method is defined using:
    
+ to point-camera at location (vector) from offset (vector):
    ...

# then from another method, we can call point-camera using the code below.
# these two method calls are equivalent, though the first reads more 
# naturally.

+ to do-something-else:
    self point-camera at (0, 0, 0) from (100, 100, 100).
    self point-camera from (100, 100, 100) at (0, 0, 0). 

</programlisting><para>
        If you wish to call a method for multiple objects, you can use the
        method call syntax with a list of objects. Note, however, that the
        arguments to the list are computed for item in the list separately.
        This makes a difference in the following example:
      </para><programlisting>
# assume that mobileList is of type list

mobileList = 10 new Mobile.

# The random statement is evaluated for each instance, meaning that all the 
# instance go to different random locations, not to a single random location.

mobileList move to random[(20, 20, 20)].
</programlisting>
</section>
<section id="node-2681">
<title>The all Expression</title>
<para>
        You can find all instances of a given class using the <literal>all</literal> expression. <literal>all</literal> is
        given the name of a class, and returns a list containing all objects of
        that type.
      </para><programlisting>
# get a list of all mobile objects in the simulation

myMobile = all Mobiles
</programlisting>
</section>
<section id="node-2682">
<title>Printing information with print and printf</title>
<para> The <literal>print</literal> and <literal>printf</literal>
        statements are used to print output from a simulation to the output
        log. Both of these statements accept any type of expression, as well as
        multiple expressions separated by commas. Also, since <literal>strings</literal> may contain embedded variables, you can
        format the output of variables however you'd like. See the section on
        <literal>strings</literal> (<xref linkend="node-2663"/>) for more information.
      </para><para>
        The only difference between <literal>print</literal> and
        <literal>printf</literal> is that <literal>printf</literal> does <emphasis>not</emphasis> automatically print a newline character.
        This means that subsequent prints will continue on the same line (as
        though the "return" key was never hit). This can be useful if you're
        trying to produce output in a specific format, but is typically not
        desirable. If in doubt, stick to <literal>print</literal></para><para>
        Here are some examples of <literal>print</literal> and
        <literal>printf</literal>:
      </para><programlisting>
# print two variables, side by side.

print (self get-time), populationSize.

# use a variable embedded in a string.

print "the population size is $populationSize".

# the following statements would produce the text:
# A B C
# D E F

print "A B C ".
print "D E F"

# the following statements would produce the text:
# A B C D E F

printf "A B C ".
printf "D E F"
</programlisting>
</section>
<section id="node-2683">
<title>Using Subexpressions</title>
<para> As in C, of
        course, users can use subexpressions as part of larger expressions. For
        example, you can use a mathematical expression as part of a method
        call, or a method call as part of a mathematical expression. Because of
        the syntax of steve , however, subexpressions frequently need to be
        parenthesized in situations where it would not be required in C. The
        following important rules apply to using subexpressions: If a method
        call is not the entire statement, it must be parenthesized. If you wish
        to assign the result of a method call, use it in a mathematical
        expression or use it as an argument for another method, for example:
      </para><programlisting>
myInt = self get-speed.                   # incorrect
myInt = (self get-speed).                 # correct

myInt = self get-speed + 5.               # incorrect
myInt = (self get-speed) + 5.             # correct

self set-speed to neighbor get-speed.     # incorrect 
self set-speed to (neighbor get-speed).   # correct
</programlisting><para>
        All method arguments must be a single "unit"&#x2014;arguments which are
        not simply a variable or literal value must be parenthesized.
      </para><para>
        This means that if you use mathematical expressions, instantiations or
        other method calls as input arguments to a method, they must be
        parenthesized. The first rule about method calls, of course, still
        applies:
      </para><programlisting>
self set-location to ((neighbor get-location) + (10, 10, 10)). # correct
self set-location to (neighbor get-location) + (10, 10, 10).   # incorrect
</programlisting>
</section>
<section id="node-2684">
<title>Internal Function Calls</title>
<note><title>
              For developer use only
            </title><para>
                Internal function calls are for use by breve and plugin
                developers only.
              </para></note><para>
        A final expression type not discussed above is an internal functions.
        Internal function calls look just like C calls:
      </para><programlisting><emphasis><function>methodName</function></emphasis>(<emphasis><function>arg1</function></emphasis>,<emphasis><function>arg2</function></emphasis>, <emphasis><function>... argN</function></emphasis>)
</programlisting><para>
        Though internal function calls are the most direct access to the breve
        libraries and features, the included class hierarchy provides a formal
        interface to the internal functions such that user simulations should
        never use these internal functions. The only exception to this is for
        certain mathematical functions.
      </para>
</section>
</section>
<section id="node-2685">
<title>Program Control Structures</title>
<para><emphasis>Control structures</emphasis> effect the flow of
        simulation code. Though many of these structures function the same as
        their counterparts in C, the syntax is slightly different in each case.
        The main difference is that the statement being tested is not
        (necessarily) surrounded by parenthesis, but is followed by a colon
        (':') character.
      </para><para>
        Control statements evaluate test statements and then execute code
        according to the result. In the case of <literal>for</literal> (<xref linkend="node-2689"/>), <literal>foreach</literal> (<xref linkend="node-2688"/>) and <literal>while</literal> (<xref linkend="node-2689"/>), these structures are used as
        loops to repeat execution of a piece of code a certain number of times
        or while a certain condition is met. The <literal>if</literal> statement is used to execute a block of code if a
        certain condition is true and, optionally, a different piece of code if
        the statement is false. A call to <literal>return</literal>
        will exit any control structure's block immediately and exit the
        method.
      </para><para>
        The conditional statements are be comprised of C-style comparison
        operators. The following comparison operators are available:
      </para><itemizedlist><listitem><para><literal>==</literal>, Equals
            </para></listitem><listitem><para><literal>!=</literal>, Not equals
            </para></listitem><listitem><para><literal>&gt;=</literal>, Greater than or Equals
            </para></listitem><listitem><para><literal>&lt;=</literal>, Less than or Equals
            </para></listitem><listitem><para><literal>&gt;</literal>, Greater than
            </para></listitem><listitem><para><literal>&lt;</literal>, Less than
            </para></listitem><listitem><para><literal>&amp;&amp;</literal>, And (short circuit
              operator)
            </para></listitem><listitem><para><literal>||</literal>, Or (short circuit operator)
            </para></listitem><listitem><para><literal>!</literal>, Negation
            </para></listitem></itemizedlist><para>
        For all of these structures, the code to be executed may be either a
        single statement, or several statements enclosed in braces ('{' and
        '}').
      </para>
<section id="node-2686">
<title>The if Statement</title>
<para> The <literal>if</literal> statement is used to execute one piece of code if
        a test statement is true, and (optionally) another if the statement is
        false:
      </para><programlisting>
if <emphasis><function>test_statement</function></emphasis>: <emphasis><function>true_code</function></emphasis>
[ else <emphasis><function>false_code</function></emphasis> ]
</programlisting><para>
        Examples of the <literal>if</literal> statement are shown
        below.
      </para><programlisting>
# here we execute a single statement

if x &gt; 5: x = 20.
else x = 0.

# here we execute many...

if x &gt; 5: {
        x = 20.
        y = 40.
} 

# here we execute many in the if, but only one in the else...

if x &gt; 5: {
        x = 20.
        y = 40.
} else x = 200.
</programlisting>
</section>
<section id="node-2687">
<title>The while Loop</title>
<para> The
        <literal>while</literal> structure works just like the while
        statement in C. If executes a block of code repeatedly, as long as the
        condition statement is true:
      </para><programlisting>
while <emphasis><function>condition</function></emphasis>: <emphasis><function>code</function></emphasis></programlisting><para>
        Examples of the <literal>while</literal> loop are shown
        below.
      </para><programlisting>
# for example...

while x &lt; 10: {
        print "x = $x".
        x++.
}
</programlisting>
</section>
<section id="node-2688">
<title>The foreach Loop</title>
<para> The
        <literal>foreach</literal> structure is similar to the
        foreach loop in Perl. The loop iterates through a list, and executes
        the associated code each time. The current item in the list is stored
        in a temporary variable as supplied by the user:
      </para><programlisting>
foreach <emphasis><function>temporary_variable</function></emphasis> in <emphasis><function>list_variable</function></emphasis>: <emphasis><function>code</function></emphasis>.
</programlisting><para>
        Examples of the <literal>foreach</literal> loop are shown
        below.
      </para><programlisting>
# so, for example, if we have a variable called agent and a list
# of objects stored in agentList:

foreach agent in agentList: {
        print (agent get-location).
}
</programlisting>
</section>
<section id="node-2689">
<title>The for Loop</title>
<para> The
        <literal>for</literal> loop (similar to the <literal>for</literal> loop in C) repeatedly executes a block of code.
        Though it can function more generally like the <literal>while</literal> loop, it is typically used to run a block of
        code for each value of a "counter" variable.
      </para><para>
        The loop is separated into three statements&#x2014;an initializer, a
        test statement, and an increment statement.
      </para><programlisting>
for <emphasis><function>expression</function></emphasis>, <emphasis><function>test_expression</function></emphasis>, <emphasis><function>increment_expression</function></emphasis>: <emphasis><function>code</function></emphasis>.
</programlisting><para>
        The <emphasis>initializer</emphasis> is executed once
        when the loop starts. It is typically used to set the iteration
        variable before proceeding. The <emphasis>test
        statement</emphasis> is run at every iteration to determine whether
        the loop will continue to execute (similar to the <literal>while</literal> loop). Finally, the <emphasis>increment statement</emphasis> is run at every
        iteration of the loop, typically to update a counter variable. Examples
        of the <literal>for</literal> loop are shown below.
      </para><programlisting>
# so, for example, if we have a variable called n (int), this loop will
# print the numbers from 1 to 30.

for n=0, n&lt;30, n+=1: {
        print n.
}

# we can also use a different increment statement in order to run the 
# loop a bit differently&#x2014;let's print only even numbers between 1 and 30

for n=2, n&lt;30, n+=2: {
        print n.
}
</programlisting>
</section>
</section>
<section id="node-2690">
<title>Garbage Collection and Memory Management</title>
<para>
        breve includes built-in <emphasis>garbage
        collection</emphasis> (sometimes called <emphasis>GC</emphasis>). Garbage collection is a form of memory
        management in which the system detects when an object is no longer
        referenced by any other variable. When an object is no longer
        referenced by any other variable, it is an indication that the memory
        is no longer in use and can thus be safely deallocated.
      </para>
<section id="node-2691">
<title>Memory Management and Garbage Collection of Basic Types</title>
<para>
        Memory management and garbage collection of basic types happens
        automatically and requires no user interaction. ints, floats, matrices
        and vectors are passed by reference and do not require garbage
        collection. lists, hashes and data are automatically garbage collected
        when appropriate.
      </para>
</section>
<section id="node-2692">
<title>Memory Management and Garbage Collection of Objects</title>
<para>
        breve's garbage collection is slightly complicated by the fact that
        objects do not need to be referenced in memory to be "in use". An
        unreferened object may, for example, "come back to life" because of an
        all (<xref linkend="node-2723"/>) expression.
        Furthermore, objects in the simulated world (members of subclasses of
        the class "Real") may physically interact even without referencing each
        other in their variables. Because of these complications, garbage
        collection cannot be automatically enabled for all objects in a
        simulation.
      </para><para>
        Garbage collection for objects is thus enabled on a per-object basis
        and the programmer must decide when its use is appropriate. The
        following guidelines should generally help to decide when garbage
        collection is appropriate for an object:
      </para><itemizedlist><listitem><para>
              the object is not a member of a subclass of Real.
            </para></listitem><listitem><para>
              the object does not have it's own iterate or post-iterate
              methods.
            </para></listitem><listitem><para>
              the object is not a dependency of any object that does not hold a
              reference to it.
            </para></listitem></itemizedlist>
</section>
<section id="node-2693">
<title>A Garbage Collection Caveat: Circular References</title>
<para>
        One important caveat applies to garbage collection of both basic types
        and objects. The steve garbage collection scheme does not correctly
        deallocate memory when there are <emphasis>circular
        references</emphasis>. A circular reference occurs when two (or more)
        objects refer to each other in a circular fashion. An example of a
        circular reference between three objects is shown below:
      </para><mediaobject><imageobject><imagedata align="center" fileref="images/circular_reference.jpg"/></imageobject></mediaobject><para>
        When a circular reference occurs, the objects are never recognized as
        "unused" and are thus never deleted as they should be. Circular
        references thus lead to "islands" of unused memory which do not get
        released. This type of circular reference is rare, but if your
        simulation design makes use of these types of structures, you may have
        to explicitly overwrite variables in order to ensure that no circular
        references exist.
      </para>
</section>
</section>
<section id="node-2694">
<title>Directives</title>
<para>
        Before getting started with the code for a simulation or class, there
        are often a few special lines at the top of a steve file which begin
        with an @-character. These lines are called @-directives ("at
        directives") and they specify information that can help breve to locate
        classes or other files, or to define some constants that will be used
        in your simulation. These directives are described below.
      </para>
<section id="node-2695">
<title>include and @use: Load Another Source File</title>
<para>
        breve includes a rich hierarchy of classes which are used to construct
        simulations. To use a class which comes with breve (or another file
        which you have created yourself), you must tell breve to load in the
        associated file. You need to load the class before you instantiate it
        or subclass it.
      </para><para>
        Classes are loaded using the <literal>@include</literal>
        directive. It is used simply by specifying the name of the file to
        include:
      </para><programlisting>
@include "Control.tz".
</programlisting><para><literal>@use</literal> works the same way, but with a
        slightly different syntax, leaving out the quotes and the ".tz" from
        the file name:
      </para><programlisting>
@use Control.
</programlisting><para>
        There is no different between <literal>@include</literal>
        and <literal>@use</literal> in terms of how the file is
        actually loaded.
      </para><para><literal>@include</literal> directives are not only used to
        include classes which come with the breve distribution, but also
        potentially classes that you construct yourself. It is often used in
        conjunction with the <literal>@path</literal> directive
        (<xref linkend="node-2696"/>) to specify the
        location of classes before loading them.
      </para>
</section>
<section id="node-2696">
<title>path: Specify a Search Path</title>
<para> The <literal>@path</literal> directive specifies a directory that breve
        should search in to find files. These directories apply to finding
        class files, image files, sound files, archives and any other type of
        resource that breve might be looking for. It should go at the top of
        the file, before you try to include any other files.
      </para><para>
        Here's an example of <literal>@path</literal> line that
        searches a folder in my home directory for class files:
      </para><programlisting>
@path "/Users/jk/breve_classes".
</programlisting><para>
        You may specify as many directories with <literal>@path</literal> directives as necessary.
      </para>
</section>
<section id="node-2697">
<title>define: Define a Global Constant</title>
<para> A <emphasis>global
        constant</emphasis> lets you associate a name with a constant value in your
        simulation. The <literal>@define</literal> directive allows
        you to associate names with <literal>ints</literal>,
        <literal>floats</literal> and <literal>strings</literal>.
      </para><para>
        These constants can be very useful when you have the same value used
        several times in a simulation&#x2014;if you want to change the value,
        then instead of making the change several times, you can make it once
        in the <literal>@define</literal> directive. It can also be
        useful to assign meaningful symbols to numbers in your simulation. For
        example, if your cellular automata is arbitrarily chosen to be 50x50,
        then instead of <emphasis>hardcoding</emphasis> the
        number 50, it is more flexible and more descriptive to use a global
        constant.
      </para><para>
        Global constants are defined with the following form:
      </para><programlisting>
@define <emphasis><function>constant-name</function></emphasis><emphasis><function>constant-value</function></emphasis> .
</programlisting><para>
        Here are some examples:
      </para><programlisting>
@define CA_SIZE                 50.
@define PI_VALUE                3.14159.
@define STRING_CONSTANT         "Hello".
</programlisting><para>
        By setting these constants at the top of the source file, you can use
        them later on. For example:
      </para><programlisting>
+ to print-pi:
        print "pi is approximately: ", PI_VALUE.
</programlisting><para>
        It is not required, but, by convention, global constants are typically
        written with all capital letters, to distinguish them from variables.
      </para>
</section>
</section>
</chapter>
<chapter id="node-2698"><?dbhtml dir="docs" ?>
<title>Defining Basic Agents</title>
<para> To create a simple agent in breve, you'll need to
        subclass one of the basic agent classes, all subclasses of <ulink url="http://www.spiderland.org/documentation/classes/Real.html">Real</ulink>:
      </para><itemizedlist><listitem><para>
              Stationary, an immobile object in the simulated world.
            </para></listitem><listitem><para>
              Mobile, an object which moves around the simulated world.
            </para></listitem><listitem><para>
              Link, a physically simulated mobile object.
            </para></listitem></itemizedlist><para>
        This chapter describes the basics of implementing agents in breve, with
        a focus on Mobile agents. Stationary objects are even easier to use
        than Mobile objects, and Physically simulated Link objects (and their
        companion class, MultiBody) are described in the chapter on physical
        simulation (<xref linkend="node-2726"/>).
      </para><para>
        The section A Simple Mobile agent (<xref linkend="node-2699"/>) shows a very basic mobile
        agent template which can be used to any mobile agent. The appearance of
        the agent can be customized in a number of ways&#x2014;some basic
        options are described in the section Changing the Appearance of Agents
        (<xref linkend="node-2700"/>). Controlling
        the motion of agents is described in the section Moving Agents Around
        the 3D World (<xref linkend="node-2701"/>). The final
        section describes how events can be scheduled for specific times
        (<xref linkend="node-2702"/>).
      </para>
<section id="node-2699">
<title>A Simple Mobile Agent</title>
<para>
        The majority of agents created in breve are simple mobile agents.
      </para><para>
        Here's a simple mobile agent. It inherits most of its behaviors from
        the class mobile, but we'll customize it with our own <literal>init</literal> and <literal>iterate</literal>
        methods.
      </para><programlisting>
Mobile : Bird {
        + variables:
                myShape (object).

        + to init:
                # make a new shape -- this step is optional.  The 
                # default shape for a new mobile is a sphere of 
                # radius 1.

                myShape = (new Cube init-with size (1, 1, 1)).

                # set the Mobile to the new shape and we're done!

                self set-shape to myShape.

        + to iterate:
                # here we would specify our default behavior--the action
                # we take at each iteration.  typically this involves a
                # change in velocity or acceleration based on some sort
                # of computation
}
</programlisting><para>
        The shape used need not be a cube&#x2014;you can choose from a number of
        shapes using the class <ulink url="http://www.spiderland.org/documentation/classes/Shape.html">Shape</ulink>. You can also construct your own shapes with the class
        <ulink url="http://www.spiderland.org/documentation/classes/CustomShape.html">CustomShape</ulink>.
      </para><para>
        This is only a simple example&#x2014;a template for a real agent. In the
        rest of the chapter we'll see how to customize the appearance, motion
        and behavior of an agent.
      </para>
</section>
<section id="node-2700">
<title>Changing the Appearance of Agents</title>
<para>
        There are a number of ways to customize the appearance of an agent. As
        mentioned in the previous section, you can manipulate the size and
        shapes of objects using the class <ulink url="http://www.spiderland.org/documentation/classes/Shape.html">Shape</ulink> and its subclasses.
      </para><para> To set the color of an
        agent, use the method <ulink url="http://www.spiderland.org/documentation/classes/Real.html#set-color">set-color</ulink> in the class <ulink url="http://www.spiderland.org/documentation/classes/Real.html">Real</ulink>. The method expects a vector color where the three
        values represent red, green and blue intensities on a scale from 0.0 to
        1.0. For example:
      </para><programlisting>
# set the color to red = 0, green = 1, blue = 0.

self set-color to (0.0, 1.0, 0.0).
</programlisting><para>
        Objects can also be textured, represented as images or even as
        translucent glowing blobs called "lightmaps". All of these techniques
        are covered in detail in the chapter on Graphics and Sound (<xref linkend="node-2703"/>).
      </para>
</section>
<section id="node-2701">
<title>Moving Agents Around the 3D World</title>
<para> Agents can be moved around the world in a number of
        ways: by specifying their locations, their velocities and their
        accelerations. Object locations are typically set during
        initialization, while velocity and acceleration are typically adjusted
        dynamically over the course of the simulation.
      </para><para>
        Agents can be explicitly moved to a specific location using the method
        <ulink url="http://www.spiderland.org/documentation/classes/Mobile.html#move">move</ulink> in the class <ulink url="http://www.spiderland.org/documentation/classes/Mobile.html">Mobile</ulink>:
      </para><programlisting>
# move the agent to the location (10, 0, 0) in 3D space...

self move to (10, 0, 0).
</programlisting><para>
        The speed of an agent can be set using the method <ulink url="http://www.spiderland.org/documentation/classes/Mobile.html#set-velocity">set-velocity</ulink> in the class <ulink url="http://www.spiderland.org/documentation/classes/Mobile.html">Mobile</ulink>:
      </para><programlisting>
# set the agent's velocity to (0, 0, 10) 

self set-velocity to (0, 0, 10).
</programlisting><para>
        The acceleration of an agent can be set using the method <ulink url="http://www.spiderland.org/documentation/classes/Mobile.html#set-acceleration">set-acceleration</ulink> in the class <ulink url="http://www.spiderland.org/documentation/classes/Mobile.html">Mobile</ulink>:
      </para><programlisting>
# set the agent's acceleration to (0, -9.8, 0) 

self set-acceleration to (0, -9.8, 0).
</programlisting>
</section>
<section id="node-2702">
<title>Scheduling Events for a Specific Time</title>
<para> Events can be scheduled for a
        specific time for any object using the method <ulink url="http://www.spiderland.org/documentation/classes/Object.html#schedule">schedule</ulink> in the class <ulink url="http://www.spiderland.org/documentation/classes/Object.html">Object</ulink>:
      </para><programlisting>
# call a method after the simulation clock hits 100.0...

self schedule method-call "sing-and-dance" at-time 100.0.
</programlisting><para>
        It is often desirable to trigger a method call not for a specific
        simulation time, but for an offset relative to the current time (for
        example, "20 seconds from now"). This can be done with the help of the
        <ulink url="http://www.spiderland.org/documentation/classes/Control.html#get-time">get-time</ulink> method in the class <ulink url="http://www.spiderland.org/documentation/classes/Control.html">Control</ulink>:
      </para><programlisting>
# call a method 100.0 seconds from now...

self schedule method-call "sing-and-dance" at-time ((controller get-time) + 100.0).
</programlisting>
</section>
</chapter>
<chapter id="node-2703"><?dbhtml dir="docs" ?>
<title>Graphics and Sound</title>
<para> This chapter
        discusses customizing graphics and sound in a breve simulation.
      </para><para>
        The first section, Lighting (<xref linkend="node-2704"/>) shows how to enable and use lighting.
        (<xref linkend="node-2705"/>)
        shows how shadows and reflections can be added to simulated objects.
      </para><para>
        (<xref linkend="node-2709"/>) shows
        how to load images into a simulation. Once an object has been loaded
        into a simulation, it can be used to display an agent as an image
        (<xref linkend="node-2710"/>), to texture an
        object (<xref linkend="node-2711"/>)
        or to display an object as a translucent "lightmap" (<xref linkend="node-2712"/>). In
        addition, the image data may be accessed and manipulated, as described
        in (<xref linkend="node-2713"/>).
      </para><para>
        Users can also create custom drawings in the world which are not
        associated with simulated objects. This feature is described in
        (<xref linkend="node-2714"/>).
      </para><para>
        Finally, (<xref linkend="node-2715"/>) describes how sound files
        can be loaded and played as part of a breve simulation.
      </para>
<section id="node-2704">
<title>Lighting</title>
<para>
        Lighting can be used to aid in the visualization of a simulation. By
        default, lighting is enabled for physical simulations (those which use
        a controller subclassed from <ulink url="http://www.spiderland.org/documentation/classes/PhysicalControl.html">PhysicalControl.tz</ulink>) and disabled all other
        simulations.
      </para><para>
        To enable lighting or disable lighting, use the <ulink url="http://www.spiderland.org/documentation/classes/Control.html">Control.tz</ulink> methods <ulink url="http://www.spiderland.org/documentation/classes/Control.html#enable-lighting">enable-lighting</ulink> and <ulink url="http://www.spiderland.org/documentation/classes/Control.html#disable-lighting">disable-lighting</ulink>. To move the location of the light,
        use the method <ulink url="http://www.spiderland.org/documentation/classes/Control.html#move-light">move-light</ulink>. The following example shows how lighting
        could be enabled and setup as part of the controller object's init
        method:
      </para><programlisting>
        self enable-lighting. 
        self move-light to (0, 50, 0).
</programlisting>
</section>
<section id="node-2705">
<title>Shadows and Reflections</title>
<para> breve's visualization
        engine offers support for both shadows and reflections. These graphical
        effects not only make a simulation look better, they also enhance the
        benefits of visualization as an aid to understanding and discovery of
        simulation behaviors.
      </para><para>
        Reflections and shadows are quite simple to set up. For reflections,
        there is a single technique; for shadows, there are two techniques to
        choose from. These techniques are outlined below.
      </para>
<section id="node-2706">
<title>Setting Up Reflections</title>
<para> The first step to
        setting up shadows or reflections is to set up lighting as described in
        the previous section (<xref linkend="node-2704"/>). The next step is to pick the "floor"
        object to "catch" the reflections. The reflection-catching object must
        be a stationary object with one face pointing upwards on the Y-plane.
        Any unrotated rectangular solid should work just fine. You can specify
        the ground object using the <ulink url="http://www.spiderland.org/documentation/classes/Stationary.html">Stationary.tz</ulink> method <ulink url="http://www.spiderland.org/documentation/classes/Stationary.html#catch-shadows">catch-shadows</ulink>. In spite of its name, this method is
        used to specify the ground floor for both shadows <emphasis>and</emphasis> reflections.
      </para><para>
        The final step in displaying reflections is to enable them, using the
        <ulink url="http://www.spiderland.org/documentation/classes/Control.html">Control.tz</ulink> method <ulink url="http://www.spiderland.org/documentation/classes/Control.html#enable-reflections">enable-reflections</ulink>.
      </para><para>
        Reflections can be turned off later using the <ulink url="http://www.spiderland.org/documentation/classes/Control.html">Control.tz</ulink> method <ulink url="http://www.spiderland.org/documentation/classes/Control.html#disable-reflections">disable-reflections</ulink>.
      </para>
</section>
<section id="node-2707">
<title>Simple Shadows</title>
<para> The first variety of
        shadows available in breve renders shadows onto a single ground plane,
        just as reflections are. This technique allows all objects, including
        bitmapped objects, to cast shadows onto the ground plane.
      </para><para>
        To setup these simple shadows, you'll need to set up the lighting and
        "shadow-catcher" plane as described in the previous section (<xref linkend="node-2706"/>). Once the
        lighting and ground plane are configured, simple shadows can be enabled
        using the <ulink url="http://www.spiderland.org/documentation/classes/Control.html">Control.tz</ulink> method <ulink url="http://www.spiderland.org/documentation/classes/Control.html#enable-shadows">enable-shadows</ulink>, and later disabled using <ulink url="http://www.spiderland.org/documentation/classes/Control.html#disable-shadows">disable-shadows</ulink>.
      </para>
</section>
<section id="node-2708">
<title>Better Shadows With Shadow Volumes</title>
<para><emphasis>Shadow
        volumes</emphasis> offer an improvement over the simple shadows described
        above. Shadow volumes can be used to cast shadows over <emphasis>any</emphasis> object, not just flat planes. In
        addition, shadow volumes will cast shadows over <emphasis>all</emphasis> objects in the simulation, not only on a
        single "ground" object. This means that with shadow volumes, all
        objects cast shadows on all other objects.
      </para><para>
        Because shadow volumes can be drawn onto non-flat objects, shadow
        volumes are the only way to draw shadow onto terrains (<xref linkend="node-2737"/>)&#x2014;simple
        shadows will not work.
      </para><para>
        There are, of course, a few disadvantages with this approach. One
        problem is that shadow volumes cannot correctly draw shadows for
        bitmapped objects. Bitmapped objects will get shadowed as spheres when
        using shadow volumes. Another issue is that shadow volumes are often
        slower than simple shadows. The exact performance hit depends on the
        number and complexity of objects in your simulation, but is often
        negligible. The final disadvantage of shadow volumes is that they are
        more prone to visual artifacts than simple shadows.
      </para><para>
        In spite of these disadvantages, shadow volumes offer far more
        realistic shadows than the simple shadows described above. Unless it's
        important to render accurate shadows of bitmapped objects, shadow
        volumes are recommended over simple shadows. To use shadow volumes,
        you'll need to enable lighting, and then enable the shadows using the
        <ulink url="http://www.spiderland.org/documentation/classes/Control.html">Control.tz</ulink> method <ulink url="http://www.spiderland.org/documentation/classes/Control.html#enable-shadows">enable-shadow-volumes</ulink>. Shadow volumes can be disabled
        using <ulink url="http://www.spiderland.org/documentation/classes/Control.html#disable-shadows">disable-shadows-volumes</ulink>.
      </para>
</section>
</section>
<section id="node-2709">
<title>Loading Image Files</title>
<note><title>
              Changed in breve 2.0
            </title><para>
                The methods used for loading images have been changed from
                breve 1.x, so pay close attention to this section if you're
                updating your simulation from a previous version of breve.
              </para></note><para> breve can use image files to
        texture objects, display objects as bitmaps, or to display objects as
        lightmaps. These techniques are described later in the chapter. This
        section describes how image files can be loaded into breve.
      </para><para><emphasis>breve</emphasis> supports three image file
        formats: 1) SGI, 2) JPEG, 3) PNG. Though JPEG is the most common, most
        graphics programs can output images in all three formats. Specifically,
        the shareware program Graphic Converter can convert between the three
        formats.
      </para><para><emphasis>PNG is the preferred image format&#x2014;it
        allows more control over how the image is loaded into a
        texture</emphasis>. Support for the SGI format is provided for
        backward compatibility. Support for the JPEG format is provided because
        it is somewhat more common than PNG.
      </para><para>
        Prior to version 2.0, breve required all images loaded into breve to be
        square, and for the length of the sides of the images must be a power
        of two (for example, 256x256 or 128x128). This is no longer strictly
        required, though it may still be preferable. breve will automatically
        surround the image with a transparent border in order to fulfill the
        size requirements.
      </para><para>
        Images are loaded using the class Image. To load an image file, create
        a new instance of the class Image, and load a file with the load
        method:
      </para><programlisting>
        image = new Image.
        image load file "myimage.png".
</programlisting><para>
        Once an image file has been loaded, it can be used as a texture, bitmap
        or lightmap, as described later in this chapter.
      </para>
</section>
<section id="node-2710">
<title>Displaying Objects as Bitmaps</title>
<note><title>
              Changed in breve 2.0
            </title><para>
                The methods used for bitmapping have been changed from breve
                1.x, so pay close attention to this section if you're updating
                your simulation from a previous version of breve.
              </para></note><para> Agents in <emphasis>breve</emphasis> can be displayed as user-specified
        image files. This technique is referred to as <emphasis>bitmapping</emphasis>. If an object is set up for
        bitmapping, the bitmap image is shown instead of the 3D object and will
        always face forward, regardless of the viewer's perspective. This is in
        contrast to <emphasis>texturing</emphasis>, in which
        the image is used as a surface for a 3D shape. Texturing is described
        in the next section, <xref linkend="node-2711"/>.
      </para><para>
        To set a bitmap image for an object in breve, the image must be loaded
        into breve as described in the previous section <xref linkend="node-2709"/>. Once the image has been
        loaded, you can set the bitmap image of an object by passing the image
        to the method "set-bitmap-image" found in <ulink url="http://www.spiderland.org/documentation/classes/Real.html">Real.tz</ulink></para><para>
        The following code loads an image and uses it as the bitmap image for
        an instance of the class Bird (this example is taken from the Swarm
        demo):
      </para><programlisting>
        breveTexture = (new Image load from "breve.png"). 
        bird = new Bird. 
        bird set-bitmap-image to breveTexture.
</programlisting><para>
        This technique is used in the Swarm demo to generate flying
        <emphasis>breve</emphasis> logos shown below.
      </para><mediaobject><imageobject><imagedata align="center" fileref="images/billboard.jpg"/></imageobject></mediaobject><para>
        Don't forget that the bitmap is set on an instance by instance basis,
        so you should call these methods for explicitly for each instance you
        want to bitmap. objects.
      </para><para>
        Also note that loading multiple textures use up a lot of memory and
        hurt performance, <emphasis>even if you are loading
        the same texture multiple times</emphasis>. It is therefore preferable
        to share the same texture image among many agents when possible. This
        may require the controller to load the texture and pass it out to the
        agents, instead of having the agents load it themselves:
      </para><programlisting>
        # bad idea!
        
        self set-bitmap-image to (new Image load from "texture.png").
        
        # good idea!
        
        self set-bitmap-image to (controller get-shared-texture).
</programlisting>
</section>
<section id="node-2711">
<title>Texturing Objects</title>
<note><title>
              Changed in breve 2.0
            </title><para>
                The methods used for texturing objects have been changed from
                breve 1.x, so pay close attention to this section if you're
                updating your simulation from a previous version of breve.
              </para></note><para>
        Texturing allows images to be tiled on a 3D object. This is in contrast
        to the bitmapping described in <xref linkend="node-2710"/>, in which an image
        is displayed in place of the 3D object. An example of object texturing
        is shown below, with a semi-transparent textured cube:
      </para><mediaobject><imageobject><imagedata align="center" fileref="images/textured_transparent_cube.jpg"/></imageobject></mediaobject><para>
        The first step in texturing an object is loading in the texture from an
        image file. Instructions for loading image files for texturing are
        given in <xref linkend="node-2709"/>. Once the texture image has
        been loaded, texturing can be done by passing the texture image to the
        method <ulink url="http://www.spiderland.org/documentation/classes/Real.html#set-texture">set-texture-image</ulink> for any <ulink url="http://www.spiderland.org/documentation/classes/Real.html">Real</ulink> object.
      </para><para>
        As mentioned in <xref linkend="node-2710"/>, loading multiple
        instances of the same texture image will be expensive in terms of both
        memory and performance, so if you're using the same texture on many
        agents, you should reuse the same Image object. An example of this is
        shown in <xref linkend="node-2710"/>.
      </para>
</section>
<section id="node-2712">
<title>Displaying Objects as "Lightmaps"</title>
<note><title>
              Changed in breve 2.0
            </title><para>
                The methods used for lightmapping have been changed from breve
                1.x, so pay close attention to this section if you're updating
                your simulation from a previous version of breve.
              </para></note><para> Lightmaps use
        textures to make objects glow transparently. An image from the included
        <literal>ParticleFountain</literal> demo is shown below.
      </para><mediaobject><imageobject><imagedata align="center" fileref="images/lightmap.jpg"/></imageobject></mediaobject><para>
        The first step in applying a lightmap to a object is loading in the
        texture from an image file. Instructions for loading image files for
        lightmapping are given in <xref linkend="node-2709"/>. Once the image has been
        loaded, lightmapping can be done by passing the image to the method
        <ulink url="http://www.spiderland.org/documentation/classes/Real.html#set-texture">set-lightmap-image</ulink> for any <ulink url="http://www.spiderland.org/documentation/classes/Real.html">Real</ulink> object.
      </para><para>
        Lightmapping will work with any image, but looks best with spherical
        images which taper off around the edges. Two images that work well as
        lightmaps are included with breve. The files are included in the
        classes directory and are available as "images/lightmap.png" and
        "images/dirtylightmap.png".
      </para><para>
        As mentioned in <xref linkend="node-2710"/>, loading multiple
        instances of the same lightmap image will be expensive in terms of both
        memory and performance, so if you're using the same lightmap on many
        agents, you should reuse the same Image object. An example of this is
        shown in <xref linkend="node-2710"/>.
      </para>
</section>
<section id="node-2713">
<title>Using the "Image" Class</title>
<para>
        Once an image file has been loaded in to an Image object (as described
        in <xref linkend="node-2709"/>),
        the image data can be accessed or manipulated directly via methods in
        the class <ulink url="http://www.spiderland.org/documentation/classes/Image.html">Image.tz</ulink>.
      </para><para>
        The Image class method <ulink url="http://www.spiderland.org/documentation/classes/Image.html#set-pixel">set-pixel</ulink> (and related methods for setting red,
        green, blue and alpha pixel values individually) can be used to modify
        an image dynamically. This will dynamically alter the appearence of any
        objects using the image as a texture, bitmap or lightmap. The demo
        "DynamicTexture" shows an example of how image textures can be
        dynamically modified.
      </para><para>
        The Image class method <ulink url="http://www.spiderland.org/documentation/classes/Image.html#get-pixel">get-pixel</ulink> (and related methods for getting red,
        green, blue and alpha pixel values individually) can be used to read
        individual pixel data from an Image. This allows the image data to be
        used as simulation input. The demo "Painter" shows an example of how an
        Image file can be used as input data for a simulation.
      </para>
</section>
<section id="node-2714">
<title>Custom Drawings with the "Drawing" Class</title>
<para>
        It is sometimes desirable to draw lines or polygons directly into the
        simulated world. Custom drawings can be created by using class <ulink url="http://www.spiderland.org/documentation/classes/Drawing.html">Drawing.tz</ulink>. After creating an instance of the Drawing class,
        individual drawing instructions are added to create line segments and
        polygons, or to change color and transparency values. More information
        on creating drawings can be found in the documentation for the class
        <ulink url="http://www.spiderland.org/documentation/classes/Drawing.html">Drawing.tz</ulink></para>
</section>
<section id="node-2715">
<title>Playing Sound Effects</title>
<para> Sounds can be loaded and played using
        the class <ulink url="http://www.spiderland.org/documentation/classes/Sound.html">Sound</ulink>. Supported file formats for sounds are AIFF and WAV.
        To load a sound file, created a new instance of the Sound class, and
        load in the file using the method <ulink url="http://www.spiderland.org/documentation/classes/Sound.html#load">load</ulink>. You can then play the sound using the method
        <ulink url="http://www.spiderland.org/documentation/classes/Sound.html#play">play</ulink>. Sound instances can play multiple overlapping
        copies of the same sound simultaneously, meaning that one sound need
        not finish before another call to <literal>play</literal> is
        made.
      </para><tip><title>
              Bad Sound Files
            </title><para>
                Though AIFF and WAV are well-defined standards, it is not
                uncommon to find AIFF or WAV files which play fine in some
                programs, but which cannot be read by others. If you have an
                AIFF or WAV file that does not seem to play correctly in breve,
                try loading it into a good quality sound editor (such as
                QuickTime Player on Mac OS X), and re-exporting the sound.
              </para></tip>
</section>
<section id="node-2716">
<title>Sounds Included With breve</title>
<para>
        A few sounds are included in the breve distribution for use in any
        simulation. The are located in the <literal>classes</literal> directory, in a subdirectory called
        <literal>sounds</literal>.
      </para><para>
        The sounds provided are:
      </para><itemizedlist><listitem><para><literal>sounds/cat.wav</literal></para></listitem><listitem><para><literal>sounds/chimp.wav</literal></para></listitem><listitem><para><literal>sounds/dog_bark.wav</literal></para></listitem><listitem><para><literal>sounds/explosion.wav</literal></para></listitem><listitem><para><literal>sounds/laser_cannon.wav</literal></para></listitem></itemizedlist>
</section>
</chapter>
<chapter id="node-2717"><?dbhtml dir="docs" ?>
<title>Interactions Between Agents</title>
<para>
        This chapter describes implementing interactions between agents in a
        breve simulation.
      </para>
<section id="node-2718">
<title>Interacting With the Controller Object</title>
<para>
        The controller object is the heart and soul of the breve simulation and
        every object should be able to speak to it. The class <ulink url="http://www.spiderland.org/documentation/classes/Object.html">Object</ulink>&#x2014;and thus all other classes ever created in
        breve&#x2014;has a variable called controller which is the simulations
        controller instance.
      </para><para>
        This simply means that the expression "controller" will automatically
        refer to the simulation's controller instance. You should not try to
        modify the value of the controller variable, as this will have
        unexpected results on the simulation.
      </para>
</section>
<section id="node-2719">
<title>Triggering Events When Agents Collide</title>
<para> It is frequently
        desirable to have agents perform some sort of interaction when they
        collide. The agents might exchange information, fight or reproduce, for
        example. In order to specify what happens when a collision occurs, use
        the method <ulink url="http://www.spiderland.org/documentation/classes/Real.html#handle-collisions">handle-collisions</ulink> found in <ulink url="http://www.spiderland.org/documentation/classes/Real.html">Real.tz</ulink>. This method expects a <literal>string</literal> method name, which is the method that will be
        invoked when the collision occurs, and a <literal>string</literal> type, which specifies the class name to set up
        the handler for.
      </para><para>
        The handler method must expect a single argument, of type <literal>object</literal>. When the collision occurs, the method is
        called with object that is encountered. In the following code excerpt,
        for example, an agent defines a method called "setup-collision-handler"
        to setup a collision handler for a (fictional) class called "Food".
        When the agent collides with a piece of food, the method "eat" will be
        called, and the argument passed in is the piece of food with which the
        agent has collided:
      </para><programlisting>
+ to setup-collision-handler:
        self handle-collisions with-type "Food" with-method "eat".

+ to eat foodObject (object):
        print "I just ate $foodObject.  It was yummy.".
        free foodObject.
</programlisting><para>
        If two agents collide, and both have collision handlers setup, then the
        collision callbacks are not guaranteed to be executed in any particular
        order. It is sometimes desirable for both objects to execute their
        callbacks, while in other cases, only one agent should execute the
        callback. If the callback is expected to trigger a one-time interaction
        (like a fight) for example, then you don't want to allow the callback
        to be executed for both agents. In this case, make your collision
        handler return a positive number. <emphasis>If the
        first callback method returns a positive number, then the second
        callback will not be executed</emphasis>. If the callback returns
        zero, or doesn't return a value at all, both callbacks will be
        executed.
      </para>
</section>
<section id="node-2720">
<title>Finding Neighboring Objects</title>
<para> The slow way to find neighboring
        objects is to look at every object in the simulation and determine
        whether they are close enough the be considered neighbors. To repeat
        this process for N objects which want to keep track of, N*N checks are
        required for each iteration. This quickly becomes the an inefficient
        bottleneck.
      </para><para>
        breve offers a solution to this problem in which the time required to
        find neighbors grows roughly linearly with the number of the objects in
        the simulation. The feature is referred to as <emphasis>neighbor checking</emphasis>. Neighbor checking is done in three
        steps:
      </para><orderedlist><listitem><para>
              Set each agent's "neighborhood size".
            </para></listitem><listitem><para>
              Ask the engine to update the neighbors at each iteration.
            </para></listitem><listitem><para>
              Retrieve each agents list of neighbors at each timestep.
            </para></listitem></orderedlist><para>
        The neighborhood size specifies the distance that each agent will look
        in order to find any neighbors. The distance between two objects is, in
        this case, defined as the distance between the center-points of the
        objects. Setting the neighborhood size is typically done during object
        initialization, but it may be changed at any time during the
        simulation. Neighborhood size is set using the method <ulink url="http://www.spiderland.org/documentation/classes/Real.html#set-neighborhood-size">set-neighborhood-size</ulink> in <ulink url="http://www.spiderland.org/documentation/classes/Real.html">Real.tz</ulink>. Real is the parent class of both <ulink url="http://www.spiderland.org/documentation/classes/Stationary.html">Stationary</ulink> and <ulink url="http://www.spiderland.org/documentation/classes/Mobile.html">Mobile</ulink> objects, so the method can be used with these classes
        as well.
      </para><para>
        The second step, updating the neighbors, is done with a call to the
        method <ulink url="http://www.spiderland.org/documentation/classes/Control.html">update-neighbors</ulink> in the iterate method of your simulations
        controller object.
      </para><para>
        The final step of retrieving the neighbors is done using the <ulink url="http://www.spiderland.org/documentation/classes/Real.html#get-neighbors">get-neighbors</ulink> method of <ulink url="http://www.spiderland.org/documentation/classes/Real.html">Real.tz</ulink>. This method returns the neighbors as a <literal>list</literal>. For example, the following iterate method would
        print out a list of the agent's neighbors at each time step, assuming
        that the neighborhood size has been set and that the neighbors are
        being updated:
      </para><programlisting>
+ to iterate:
        neighbors (list).
        item (object).

        neighbors = (self get-neighbors).

        foreach item in neighbors: print "$item is in my neighborhood.".
</programlisting>
</section>
<section id="node-2721">
<title>Finding the Closest Object</title>
<para> Finding the
        closest object can be slightly more complicated than simply getting the
        neighbors, because it's possible that the closest object is not within
        an object's neighborhood. However, assuming that some number of
        neighbors are found for your agent, the following code should help:
      </para><programlisting>
+ to find-closest-neighbor:
        closestNeighbor (object).
        distance, minDistance (float).

        # start with an arbitrarily high distance

        minDistance = 1000000.

        foreach i in (self get-neighbors): {
                distance = | (self get-location) - (i get-location) |.

                if distance &lt; minDistance: {
                        minDistance = distance.
                        closestNeighbor = i.
                }
        }

        return closestNeighbor.
</programlisting><para>
        If there are no neighbors within the local neighborhood then it is
        sometimes necessary to do a search of all agents in the simulation. To
        do this, the code above can be modified by using an <literal>all</literal> statement (<xref linkend="node-2723"/>) in place of
        the "self get-neighbors" expression:
      </para><programlisting>
        foreach i in (all "Reals") {
                # code to select the closest neighbor
        }
</programlisting>
</section>
<section id="node-2722">
<title>Triggering Events Using Notifications</title>
<para> Notifications allow instances to
        make announcements to an arbitrary set of "listeners". This allows
        instances to communicate somewhat indirectly&#x2014; the announcing
        instance care or keep track of who is listening to the announcements.
      </para><para>
        An object may make an announcement at any time by using the method
        <ulink url="http://www.spiderland.org/documentation/classes/Object.html#announce">announce</ulink> in the class <ulink url="http://www.spiderland.org/documentation/classes/Object.html">Object</ulink>. The announcement may reflect a state change in the
        object or a reaction to a specific event.
      </para><para>
        The announcement itself does not affect the other instances in the
        simulation unless they have explicitly decided to "observe" the
        announcer using the observe. The observe method expects the object to
        be observed, the name of the announcement to look for, and the method
        to call when the announcement occurs. For example, an instance
        interested in monitoring the controller for a (fictional) "New Object"
        notification would call:
      </para><programlisting>
self observe instance controller for-notification "New Object" with-method "new-of-new-object".
</programlisting><para>
        The observing object would then get a call to the method
        notify-of-new-object whenever the controller made the announcement "New
        Object".
      </para><para>
        Once an observer instance begins to observe another instance, the
        observer will get a callback every time the desired notification is
        announced. The callback method must take 2 arguments: the source of the
        announcement and the announcement string. The keywords are unimportant,
        but a simple example is:
      </para><programlisting>
+ to notify-of-new-object from-instance announcer (object) with-message message (string):
        print "I got the message $message from $announcer!".
</programlisting>
</section>
<section id="node-2723">
<title>Finding All Objects of a Given Type</title>
<para> You can find
        all instances of a given class using the "all" expression:
      </para><programlisting>
# get a list of all mobile objects in the simulation

myMobile = all Mobiles
</programlisting>
</section>
<section id="node-2724">
<title>Testing Whether an Object Responds to a Method Call</title>
<para> If you need
        to know whether an item can respond to a certain method call, use the
        method <ulink url="http://www.spiderland.org/documentation/classes/Object.html#can-respond">can-respond</ulink> in <ulink url="http://www.spiderland.org/documentation/classes/Object.html">Object.tz</ulink>. As with is, this method is used like a statement
        that returns true or false:
      </para><programlisting>
    if (item can-respond to "sing-and-dance"): item sing-and-dance.
</programlisting>
</section>
<section id="node-2725">
<title>Testing the Type of an Object</title>
<para> If you need
        to determine whether an object is of a certain type, you can use the
        method <ulink url="http://www.spiderland.org/documentation/classes/Object.html#is">is</ulink> from <ulink url="http://www.spiderland.org/documentation/classes/Object.html">Object.tz</ulink>. The method takes a single keyword, "a", such that
        the method call can be written:
      </para><programlisting>
    item is a "Dog".
</programlisting><para>
        The call returns a int value 1 if the item is of the specified type, or
        0 otherwise. This would most likely be part of an if statement:
      </para><programlisting>
    if (item is a "Dog"): item roll-over.
</programlisting><para>
        This method is useful in collision callbacks or when examining
        neighbors in order to determine the appropriate action.
      </para>
</section>
</chapter>
<chapter id="node-2726"><?dbhtml dir="docs" ?>
<title>Physical Simulation</title>
<para> Physical simulation allows
        simulated agents to behave in a physically realistic fashion. This
        means that agents in the simulated world can be configured to behave
        just as real objects do, according to the laws of physics. If a ball is
        placed in the air above a floor, for example, physical simulation can
        be used to make the ball realistically fall toward the floor and
        bounce. Among other things, physical simulation can be used for
        realistic simulation of robots, vehicles and animals. The current
        version of breve uses portions of the excellent ODE physical simulation
        engine.
      </para><para>
        Even though it is incredibly useful, physical simulation can add
        complexity and potential instabilities to a simulation. This chapter
        begins by with the section When to Use Physical Simulation (<xref linkend="node-2727"/>),
        which discusses when it is appropriate to use physical simulation and
        possible alternatives to full physical simulation. You should read this
        section first to help you decide whether physical simulation is
        necessary for your simulation.
      </para>
<section id="node-2727">
<title>When to Use Physical Simulation</title>
<para> In many
        circumstances, users wish to write simulations which use certain
        aspects of physics, but not others. In these situations it is tempting
        to enable physical simulation, but this often opens the door to other
        sorts of complications. Physical simulation is slower, more complicated
        and inherently less stable than non-physical simulation. It is often
        far more effective to use "pseudo-physics" in which you implement some
        physical simulation features without enabling full physical simulation.
      </para><para>
        One example is a simulation which requires gravity for "ballistic"
        (non-Multibody Real) objects. Though the effects of gravity can be
        enabled using physical simulation, a more robust and far more efficient
        approach is to simply set a constant acceleration of (0, -9.8, 0). By
        disabling the physical simulation engine and setting a constant
        acceleration, a great deal of complexity can be avoided.
      </para><para>
        Another example is two objects which stick together and behave as a
        single entity. Though this can be simulated as a <ulink url="http://www.spiderland.org/documentation/classes/MultiBody.html">MultiBody</ulink> object, if other aspects of physical
        simulation are <emphasis>not</emphasis> required, it
        may be better to enforce the relationship between the objects manually
        at each time-step by making one of the objects move itself to maintain
        a certain position relative to the other.
      </para><para>
        It's often unclear which technique should be used, but many users tend
        to err on the side of enabling physics which is the <emphasis>more</emphasis> complicated solution. True physical
        simulation is typically necessary only when dealing with physically
        realistic jointed bodies, such as a simulated robot or simulated
        animal. You should be aware of the pros and cons of true physical
        simulation and consider using your own "pseudo-physics" instead.
      </para>
</section>
<section id="node-2728">
<title>Enabling Physical Simulation</title>
<para>
        To write a simulation with physical simulation, your controller object
        should be a subclass of the class <ulink url="http://www.spiderland.org/documentation/classes/PhysicalControl.html">PhysicalControl</ulink>. This class sets certain simulation
        parameters to values sensible for physical simulation, such as
        integration step, gravity, etc.
      </para><para>
        Physics must be enabled for <ulink url="http://www.spiderland.org/documentation/classes/Mobile.html">Mobile</ulink> objects on an object by object basis using the method
        <ulink url="http://www.spiderland.org/documentation/classes/Mobile.html#enable-physics">enable-physics</ulink>. When dealing with physical
        simulations, however, it is often preferable to use the Mobile subclass
        <ulink url="http://www.spiderland.org/documentation/classes/Link.html">Link</ulink> for which physical simulation is automatically
        enabled.
      </para>
</section>
<section id="node-2729">
<title>Fast Physical Simulation</title>
<para>
        The ODE simulation library supports an accelerated physics simulation
        which offers great improvements in simulation speed and memory usage,
        at the expense of some accuracy. The fast physics algorithm scales
        better than the normal physics algorithm as the number of interacting
        physical bodies increases. With a small number of interacting physical
        bodies, there may not be a great difference between the two. As the
        number increases, however, the benefits of fast physics will become
        much greater.
      </para><para>
        Fast physics may be enabled using the method <ulink url="http://www.spiderland.org/documentation/classes/PhysicalControl.html#enable-fast-physics">enable-fast-physics</ulink>. An additional iterations
        parameter can be set using the method <ulink url="http://www.spiderland.org/documentation/classes/PhysicalControl.html#set-fast-physics-iterations">set-fast-physics-iterations</ulink>. The default value of 40
        should give good results, but the number may be adjusted upwards for
        more accuracy, or downwards for better performance.
      </para>
</section>
<section id="node-2730">
<title>Writing Stable Physical Simulations</title>
<para> The physical
        simulation engine can be quite sensitive to the configuration of bodies
        in a simulation. This can lead to performance problems, instabilities
        and unexpected results. Because of the number of factors involved, it
        can be difficult to track down the exact reason for instabilities or
        unexpected results.
      </para><para>
        Below are some things to watch out for when dealing with physical
        simulation.
      </para><itemizedlist><listitem><para>
              Instabilities may arise when dealing with very large (heavy) and
              very small (light) objects
            </para></listitem><listitem><para>
              Exerting very large joint pressures or velocities may cause
              unrealistic behaviors.
            </para></listitem><listitem><para>
              Beware of joints which force invalid or conflicting conformations
              on your objects.
            </para></listitem><listitem><para>
              Avoid forcing deep collisions between objects with either joints
              or manual movement.
            </para></listitem><listitem><para>
              Use of redundant or unnecessary joints will cause instabilities
              and performance problems.
            </para></listitem></itemizedlist>
</section>
<section id="node-2731">
<title>The Components of Physically Simulated Bodies</title>
<note><title>
              Changed in breve 2.0
            </title><para>
                The methods used for loading images have been changed from
                breve 1.x, so pay close attention to this section if you're
                updating your simulation from a previous version of breve.
              </para></note><para>
        In order to construct physically simulated agents, you'll need to be
        familiar with the components of physically simulated bodies. There are
        three main components used in physical simulations:
      </para><itemizedlist><listitem><para>
              Links, the basic building blocks of physically simulated objects
            </para></listitem><listitem><para>
              MultiBodies, physical bodies made up of one or more Link objects
              (<xref linkend="node-2734"/>)
            </para></listitem><listitem><para>
              Joints, rigid connections between Link objects (<xref linkend="node-2733"/>)
            </para></listitem><listitem><para>
              Springs, flexible connections between Link objects (<xref linkend="node-2736"/>)
            </para></listitem></itemizedlist>
<section id="node-2732">
<title>The Link Class</title>
<para> The Link class is the
        basic building block of physically simulated objects. A link is simply
        a rigid body with a particular shape. Once a Link is created and
        associated with a shape, it can be attached to other links via Joint
        objects, covered in the section The Joint Class and its Subclasses
        (<xref linkend="node-2733"/>) or brought
        into the physical simulation by being associated with a MultiBody, as
        discussed in the section on using MultiBody objects (<xref linkend="node-2734"/>).
      </para><para>
        Prior to breve 2.0, Link objects would not appear in the simulated
        world unless they were associated with MultiBody objects (described
        below). This is no longer the case.
      </para>
</section>
<section id="node-2733">
<title>The Joint Class and its Subclasses</title>
<para> As mentioned in the previous section (<xref linkend="node-2734"/>), <ulink url="http://www.spiderland.org/documentation/classes/Link.html">Links</ulink> are joined together using <ulink url="http://www.spiderland.org/documentation/classes/Joint.html">Joint</ulink> objects.
      </para><para>
        There are several types of joints available&#x2014;see each class'
        documentation for more details:
      </para><itemizedlist><listitem><para><ulink url="http://www.spiderland.org/documentation/classes/FixedJoint.html">FixedJoint</ulink></para></listitem><listitem><para><ulink url="http://www.spiderland.org/documentation/classes/PrismaticJoint.html">PrismaticJoint</ulink></para></listitem><listitem><para><ulink url="http://www.spiderland.org/documentation/classes/RevoluteJoint.html">RevoluteJoint</ulink></para></listitem><listitem><para><ulink url="http://www.spiderland.org/documentation/classes/UniversalJoint.html">UniversalJoint</ulink></para></listitem><listitem><para><ulink url="http://www.spiderland.org/documentation/classes/BallJoint.html">BallJoint</ulink></para></listitem></itemizedlist>
</section>
<section id="node-2734">
<title>The MultiBody class</title>
<para> A MultiBody
        is a single logical physically simulated agent, whether it is made up
        of a single Link, or multiple Links joined together with Joint objects.
      </para><para><emphasis>The role of the MultiBody has changed
        drastically in breve 2.0 from previous versions of breve</emphasis>.
        Previously, Link objects would not appear at all in the simulated world
        unless they were part of a MultiBody. Now, the use of MultiBodies is
        completely optional.
      </para><para>
        Keeping a set of Links bound together as a logical MultiBody unit
        allows the user to move or rotate the entire logical structure, as
        opposed to moving or rotating individual links. Imagine that suddenly
        your arm was moved across the room without the rest of your body
        &#x2014;in all likelihood, this would not make you very happy. This is
        what it's like for the underlying physics engine to move a single
        link&#x2014;confusing and painful things can happen. By encompassing a
        set of connected Links within a MultiBody, the user has more logical
        control over the object.
      </para><mediaobject><imageobject><imagedata align="center" fileref="images/MultiBody.jpg"/></imageobject></mediaobject><para>
        To create a MultiBody, you can simply associate it with any existing
        Link object. The Link object you choose will be known as the <emphasis>root link</emphasis>, and all other Links connected to the root
        link&#x2014;directly or indirectly&#x2014;will become part of the
        MultiBody. The MultiBody is automatically updated as joints are created
        and destroyed.
      </para>
</section>
</section>
<section id="node-2735">
<title>Dynamically Creating and Destroying Joints</title>
<para> breve allows <ulink url="http://www.spiderland.org/documentation/classes/Joint.html">Joints</ulink> to be created and destroyed dynamically over the
        course of the simulation.
      </para><para>
        Joining <ulink url="http://www.spiderland.org/documentation/classes/MultiBody.html">MultiBodies</ulink> dynamically is simple&#x2014;you simply
        link them as always using the various <ulink url="http://www.spiderland.org/documentation/classes/Joint.html">Joint</ulink> subclasses. The joints can be made not only to modify
        the structure of a single MultiBody, but also to join together distinct
        MultiBodies.
      </para><para>
        Breaking MultiBodies is accomplished using the <ulink url="http://www.spiderland.org/documentation/classes/Joint.html">Joint</ulink> method <ulink url="http://www.spiderland.org/documentation/classes/Joint.html#break">break</ulink>.
      </para><para>
        Prior to <emphasis>breve</emphasis> version 2.0, when
        all Links had to be part of a MultiBody to appear in the simulated
        world, breaking joints were often accompanied by broken hearts:
        breaking a joint could cause entire subtrees of links to disappear into
        the ether because the links were orphaned. In <emphasis>breve</emphasis> 2.0, links will go on living happily
        even if they are not associated with a MultiBody.
      </para>
</section>
<section id="node-2736">
<title>Using Springs</title>
<para>
        Documentation forthcoming.
      </para>
</section>
<section id="node-2737">
<title>Using Terrains With Physical Simulation</title>
<para> The class <ulink url="http://www.spiderland.org/documentation/classes/Terrain.html">Terrain</ulink> allows fractal terrains to be created in breve.
        These terrains provide a more realistic ground than simply using a flat
        plane. The terrains can be automatically generated using the method
        <ulink url="http://www.spiderland.org/documentation/classes/Terrain.html#generate">generate</ulink>, or set manually by the user using the
        method <ulink url="http://www.spiderland.org/documentation/classes/Terrain.html#set-height">set-height</ulink>. See the <ulink url="http://www.spiderland.org/documentation/classes/Terrain.html">Terrain</ulink> class documentation for information on using
        terrains.
      </para>
</section>
</chapter>
<chapter id="node-2738"><?dbhtml dir="docs" ?>
<title>Graphical User Interface</title>
<para> This chapter describes
        techniques for specifying how users can interact with running
        simulations via a number of user interface features. The first section
        describes the global simulation menu and the per-object contextual
        menus (<xref linkend="node-2739"/>). The
        next sections describe how to catch keyboard events (<xref linkend="node-2740"/>), and how to
        display a message using a dialog (<xref linkend="node-2741"/>).
      </para><para>
        While most aspects of The breve Simulation Environment function the
        same on all platforms, user interface is an area where the different
        platforms offer different levels of support. All of the techniques
        covered in this section may yield different results on different
        platforms.
      </para><para>
        The most complete support is the Mac OS X breve application. In
        addition to the techniques described above, the Mac OS X implementation
        also allows fully customized user interfaces to be loaded into running
        simulations. The section on loading "nib" files (<xref linkend="node-2742"/>)
        describes how this is done.
      </para>
<section id="node-2739">
<title>The Simulation Menu and Contextual Menus</title>
<para> Menus allow users to
        trigger events in simulations by selecting menu items. Each simulation
        has a <emphasis>global simulation menu</emphasis>. This menu is
        associated with the controller object and is used to trigger actions
        which effect the entire simulation. Objects in the simulation each have
        their own <emphasis>contextual menus</emphasis> which allows the
        user to trigger actions in individual instances.
      </para><para>
        For the controller object, the methods <ulink url="http://www.spiderland.org/documentation/classes/Control.html#add-menu">add-menu</ulink><ulink url="http://www.spiderland.org/documentation/classes/Control.html#add-menu">add-menu-separator</ulink> of class <ulink url="http://www.spiderland.org/documentation/classes/Control.html">Control.tz</ulink> are used to configure the menus. For the
        simulation objects, the methods <ulink url="http://www.spiderland.org/documentation/classes/Real.html#add-menu">add-menu</ulink><ulink url="http://www.spiderland.org/documentation/classes/Real.html#add-menu">add-menu-separator</ulink> class <ulink url="http://www.spiderland.org/documentation/classes/Real.html">Real.tz</ulink> are used.
      </para>
</section>
<section id="node-2740">
<title>Responding to Keyboard Events</title>
<para> Catching keyboard events lets a simulation execute
        certain actions in response to user keypresses. To catch keyboard
        events, simply implement methods in your simulation with names like
        <literal>catch-key-<emphasis><function>X</function></emphasis>-down</literal> and <literal>catch-key-<emphasis><function>X</function></emphasis>-up</literal>, where <emphasis><function>X</function></emphasis> is any letter or number, uppercase or
        lowercase.
      </para><para>
        In the event that the key you want to catch is <emphasis>not</emphasis> a letter or number, then the method
        names described above may not work, due to conflicts with the steve
        language. If you tried to catch the space bar, for example, using a
        method named "<literal>catch-key- -up</literal>", breve
        would get confused&#x2014;the same is true of most punctuation as well.
        In this case, you can still catch the event using the <emphasis>hexadecimal ASCII equivalent</emphasis> for the character. In
        this case of the space bar, the valid breve method name would be
        <literal>catch-key-0x20-down</literal>. Consult an ASCII
        table for more information. Don't forget to add <literal>0x</literal> in front of hexadecimal values.
      </para><para>
        In addition to catching regular ASCII characters, similar methods may
        be used to catch the arrow keys:
      </para><programlisting>
catch-key-left-down
catch-key-left-up
catch-key-right-down
catch-key-right-up
catch-key-up-down
catch-key-up-up
catch-key-down-down
catch-key-down-up
</programlisting><para>
        When a key is pressed down, only one call to the "down" method is made
        (as opposed to repeated calls until the button is released). And
        likewise, only a single call to the "up" method is made. If you wish
        for an action to continue for as long as a key is pressed down, then
        you should have the "down" callback set a flag or call a method which
        will trigger a continuous event, then use the "up" callback to
        deactivate the event.
      </para>
</section>
<section id="node-2741">
<title>Displaying a Dialog Box</title>
<para> The <ulink url="http://www.spiderland.org/documentation/classes/Control.html">Control</ulink> method <ulink url="http://www.spiderland.org/documentation/classes/Control.html#show-dialog">show-dialog</ulink> will bring up a dialog with the options
        "yes" and "no". The arguments passed to the method will specify the
        title, message, and text for both the "yes" and "no" buttons. The
        method returns 1 if the "yes" button is clicked, and 0 otherwise.
      </para><para>
        This method only produces a "true" dialog with the Mac OS X
        application. With the command line version of breve, this method will
        produce a message to standard output.
      </para>
</section>
<section id="node-2742">
<title>Loading ".nib" Files for Customized Interfaces</title>
<note><title>
              Mac OS X only
            </title><para>
                This feature is available under Mac OS X only.
              </para></note><para> breve offers basic support for loading customized
        ".nib" files to give more customized interfaces to simulations. Users
        can design a customized window of controls (like buttons, sliders,
        checkboxes, etc.) and load it when the simulation is run. This feature
        is only available on the Mac OS X version of breve.
      </para><para>
        In order to build customized interfaces, the Mac OS X development tools
        including "Interface Builder", must be installed. A basic understanding
        of Interface Builder is also very helpful.
      </para><para>
        To implement a customized interface for your simulation, follow the
        following steps:
      </para><itemizedlist><listitem><para>
              Make a copy of the interface template file included with the
              breve distribution.
            </para></listitem><listitem><para>
              Open the new template file with Interface Builder.
            </para></listitem><listitem><para>
              In the Instances tab of the interface window, open the
              "InterfaceWindow" instance.
            </para></listitem><listitem><para>
              Add interface elements from the included palette to the window.
            </para></listitem><listitem><para>
              For each interface element you add, you should give it a unique
              "tag" number in it's inspector window (select the object, press
              command-1).
            </para></listitem><listitem><para>
              Save the file.
            </para></listitem><listitem><para>
              At the top of your simulation file, add a line for the file:
              <literal>@nib_file "<emphasis><function>filename</function></emphasis>"</literal>.
            </para></listitem><listitem><para>
              For each interface action you wish to catch, you'll need a method
              with the corresponding tag number:
            </para><programlisting>
+ to catch-interface-id-<emphasis><function>xxx</function></emphasis> with-string s (string):  
</programlisting><para>
              You can also set the values of interface with the method <ulink url="http://www.spiderland.org/documentation/classes/Control.html#set-interface-item">set-interface-item</ulink> in the class <ulink url="http://www.spiderland.org/documentation/classes/Control.html">Control.tz</ulink>. In both cases&#x2014;for both
              catching and setting interface values&#x2014;note that even though
              the interface value is expressed as a string, the actual value is
              often a number. A slider interface element, for example, will
              actually give (and expect) a number value, but on the breve side,
              it will be expressed as a string. steve's automatic conversion
              between <literal>ints</literal>, <literal>floats</literal> and <literal>strings</literal> typically takes care of this
              automatically.
            </para></listitem></itemizedlist><para>
        When the user interface element with the corresponding tag is
        activated, these methods will be called with the string value of the
        interface element. In the case of most types of controls, like buttons
        or sliders, you'll generally want to use the string value as a number
        to set some parameter.
      </para>
<section id="node-2743">
<title>Creating ".nib" Files Without Using the Included Template</title>
<para> It is best to
        use the included template for creating your own custom nib files
        because the process for creating them from scratch can be a bit
        confusing. Nevertheless the process is described below for those who
        are curious:
      </para><itemizedlist><listitem><para>
              Launch interface builder
            </para></listitem><listitem><para>
              Create a new "Cocoa, Empty" nib file
            </para></listitem><listitem><para>
              In the document window, click on the "Classes" tab
            </para></listitem><listitem><para>
              Control-click on "NSObject", select the menu entry "subclass
              NSObject". A new object called "MyObject" will appear--rename
              this object to "slBreveNibLoader"
            </para></listitem><listitem><para>
              With the slBreveNibLoader object selected, bring up the info
              window with Command-1
            </para></listitem><listitem><para>
              In the "Outlet" tab of this window, click add. Name the new
              outlet "window".
            </para></listitem><listitem><para>
              Click back to the "Instances" tab of the project. Click on
              "File's Owner", and type Command-5 to bring up the "Custom Class"
              inspector. Find the object "slBreveNibLoader" from this list and
              select it.
            </para></listitem><listitem><para>
              Go back to the "Instances" tab of the project. From the "Cocoa
              Views" palette, drag a "Window" object to the "Instances" area.
            </para></listitem><listitem><para>
              Select the "File's Owner" icon. Control-click and drag from the
              "File's Owner" icon to the icon of the newly created window.
            </para></listitem><listitem><para>
              In the "File's Owner" info window that appears, select the item
              "window" and then click on the connect button.
            </para></listitem></itemizedlist>
</section>
</section>
</chapter>
<chapter id="node-2744"><?dbhtml dir="docs" ?>
<title>Saving Movies and Snapshots</title>
<para>
        breve allows you to save snapshots of your simulation as PNG files
        (<xref linkend="node-2746"/>), and
        movies as MPEG files (<xref linkend="node-2745"/>).
      </para><note><title>
              Note Available When Using breve_cli
            </title><para>
                These features are not supported for the "graphicless" build of
                breve, breve_cli.
              </para></note>
<section id="node-2745">
<title>Saving Movies</title>
<para>
        You can save MPEG movies of <emphasis>breve</emphasis> simulations using the class <ulink url="http://www.spiderland.org/documentation/classes/Movie.html">Movie.tz</ulink>. First create an instance of the class, then begin
        recording a movie by using the method <ulink url="http://www.spiderland.org/documentation/classes/Movie.html#record">record</ulink>. For your convenience, the standard Control
        class simulation menu includes an option for exporting an MPEG movie.
      </para>
</section>
<section id="node-2746">
<title>Saving Snapshots</title>
<para>
        To save a PNG snapshot of a running <emphasis>breve</emphasis> simulation, use the method <ulink url="http://www.spiderland.org/documentation/classes/Control.html#save-snapshot">save-snapshot</ulink> in the class <ulink url="http://www.spiderland.org/documentation/classes/Control.html">Control</ulink>. For your convenience, the standard Control class
        simulation menu includes an option for exporting PNG snapshots.
      </para>
</section>
</chapter>
<chapter id="node-2747"><?dbhtml dir="docs" ?>
<title>Archiving and Dearchiving Objects and Simulations</title>
<para> breve allows simulations and
        individual objects within simulations to be archived into
        human-readable XML files, and then later extracted. The XML
        archive/dearchive process applies both to saving simulation objects to
        files and to sending objects over the network. Both techniques require
        object encoding and decoding, and the discussion in this chapter
        applies to both.
      </para><para>
        This chapter first describes how individual objects can be archived and
        dearchived (<xref linkend="node-2748"/>) and then
        how entire simulations can be archived and dearchived (<xref linkend="node-2752"/>).
      </para>
<section id="node-2748">
<title>Saving and Loading Individual Objects</title>
<para> This method is used to export and import individual
        objects or subsets of objects in a simulation. When an object is
        dearchived with this method, a new instance is created for the saved
        object and loaded into a running simulation. This technique is in
        contrast to the method described in <xref linkend="node-2752"/>,
        which creates an entirely new simulation from an archived world. The
        steps described here also apply to sending and receiving objects over a
        network as described in <xref linkend="node-2755"/>.
      </para>
<section id="node-2749">
<title>Methods Called During Archiving/Dearchiving</title>
<para>
        The special methods <literal>archive</literal> and
        <literal>dearchive</literal> are called during archiving and
        dearchiving respectively. The "archive" method is used, if necessary,
        to prepare an object for archiving. The "dearchive" method is used, if
        necessary, after an object has been loaded to prepare it for being
        loaded into the simulation.
      </para><para>
        For most users, these methods are not required and should not be
        implemented. If they are implemented, however, they <emphasis>must return 1 to indicate success</emphasis> and unless
        the methods are specifically intended to override superclass behaviors,
        they <emphasis>must call the superclass
        implementation</emphasis>. In most cases, it is desirable to return
        the same value as the superclass implementation so that errors are
        handled correctly. Example <literal>archive</literal> and
        <literal>dearchive</literal> methods are shown below. These
        methods do no special preparation for archiving and dearchiving, but
        instead fulfill the requirements lists above and print a message.
      </para><programlisting>
+ to archive:
        print "Archiving $self...".

        return (super archive).

+ to dearchive:
        print "Dearchiving $self...".

        return (super archive).
</programlisting>
</section>
<section id="node-2750">
<title>Saving and Loading Objects With No Dependencies</title>
<para>
        In a "simple" object archive, only a single object is encoded. If the
        object has variable <literal>object</literal> variables or
        <literal>pointer</literal> variables, they will be set to 0
        when the object is dearchived. All other variable types will be
        restored to their pre-archiving values. For this type of object
        archiving and dearchiving, no additional code or preparation is
        required.
      </para>
</section>
<section id="node-2751">
<title>Saving and Loading Objects With Dependencies</title>
<para>
        Variables of type <literal>object</literal> and <literal>pointer</literal> cannot be automatically maintained without
        special treatment. This is because an <literal>object</literal> may reference another, which in turn
        references several others, and so forth. If all <literal>object</literal> variables were maintained, then a huge chain
        reaction would result every time an instance was saved.
      </para><para>
        To avoid this, saving objects does not include an object variable
        <emphasis>unless</emphasis> the the object being
        saved has declared it as a dependency, using the <ulink url="http://www.spiderland.org/documentation/classes/Object.html">Object</ulink> method <ulink url="http://www.spiderland.org/documentation/classes/Object.html#add-dependency">add-dependency</ulink>. If you define an object, Y, as a
        dependency of X, then saving X will also save Y. Loading the saved
        instance X will also recreate the instance Y.
      </para><para>
        Because adding dependencies also has the potential to lead to
        chain-reactions of archiving, it should be used with care. Generally,
        an object should only add dependencies on objects it has created and
        for which it is exclusively responsible. So while a simulated creature
        might legitimately add a dependency on an object containing its genome
        or an object which determines its movement (a "brain"), it would be
        inappropriate for the object to add a dependency on the controller
        object, or other creatures in the world.
      </para><para>
        When an object is to be archived using this technique, the
        user-supplied method <literal>archive</literal> is executed
        for the object. In your <literal>archive</literal> method,
        you should include code that might be needed to prepare the object for
        archiving such as updating variables which will be required when the
        object is dearchived. <emphasis>Your <function>archive</function> method must, on success, return
        1</emphasis>. Any other return value is considered failure and will
        abort the archive.
      </para><para>
        When an object is to be dearchived using this method, the user-supplied
        method <literal>dearchive</literal> is executed for the
        object. In your <literal>dearchive</literal> method, you
        should include code that might be needed to restore the state of the
        object, or to inform the rest of the simulation of its presence if
        necessary. <emphasis>Your dearchive method must, on
        success, return 1</emphasis>. Any other return value is considered
        failure and will abort the archive.
      </para><para>
        Once dependencies, archive methods and dearchive methods (all of which
        may prove to be unnecessary for most straightforward classes) are
        addressed, you may initiate an archive using the <ulink url="http://www.spiderland.org/documentation/classes/Object.html">Object</ulink> method <ulink url="http://www.spiderland.org/documentation/classes/Object.html#archive-as-xml">archive-as-xml</ulink>.
      </para><para>
        To dearchive an object previously archived with this technique, use the
        <ulink url="http://www.spiderland.org/documentation/classes/Control.html">Control</ulink> method <ulink url="http://www.spiderland.org/documentation/classes/Control.html#dearchive-xml">dearchive-xml</ulink>. Note that this creates new instances
        of the objects in the archived file, instead of "filling" an existing
        object.
      </para>
</section>
</section>
<section id="node-2752">
<title>Saving and Loading the Entire State of a Simulation</title>
<para> This technique allows you to save
        a simulation, and resume it later. In this case, all objects are
        archived and their states are archived entirely (except for objects
        containing variables of type pointer, which should apply only to those
        developing their own breve plug-ins). <emphasis>You
        must have the original simulation source file in order to restart a
        saved simulation</emphasis>.
      </para><para>
        As with the archiving discussed in the previous section (<xref linkend="node-2748"/>,
        dependencies can also be used when archiving entire simulations. In
        this case, the dependencies effect only the order in which objects are
        dearchived, an issue that should not effect most users.
      </para><para>
        When an object is to be archived using this technique, the method
        "archive" is executed for the object. In your archive method, you
        should include code that might be needed to prepare the object for
        archiving such as updating variables which will be required when the
        object is dearchived. <emphasis>Your archive method
        must, on success, return 1</emphasis>. Any other return value is
        considered failure and will abort the archive.
      </para><para>
        When an object is to be dearchived using this method, the method
        "dearchive" is executed for the object. In your dearchive method, you
        should include code that might be needed to restore the state of the
        object, or to inform the rest of the simulation of its presence if
        necessary. <emphasis>Your dearchive method must, on
        success, return 1</emphasis>. Any other return value is considered
        failure and will abort the archive.
      </para><para>
        To initiate a "whole simulation archive", use the <ulink url="http://www.spiderland.org/documentation/classes/Control.html">Control</ulink> method <ulink url="http://www.spiderland.org/documentation/classes/Control.html#save-as-xml">save-as-xml</ulink>.
      </para><para>
        An archived world cannot be loaded into a running simulation&#x2014;to
        dearchive a simulation saved with this technique, you have to start the
        simulation with the archive. In the OS X version of <emphasis>breve</emphasis>, this is done from the "File" menu. In
        command-line versions of the software, this is done by using the "-l"
        flag, along with the name of the saved simulation file, for example:
      </para><programlisting>
        breve -l "myWorld.xml" myWorld.tz
</programlisting>
</section>
</chapter>
<chapter id="node-2753"><?dbhtml dir="docs" ?>
<title>Networking</title>
<para>
        breve supports two kinds of networking: sending objects over the
        network from one simulation to another, and interacting with running
        breve simulations using a web browser.
      </para><para>
        This chapter starts by describing how to create a NetworkServer object
        which is used for both of these networking features (<xref linkend="node-2754"/>). Next, sending
        and receiving breve objects over the network is described (<xref linkend="node-2755"/>). The final
        section describes how to allow the control of a breve simulation via a
        web interface (<xref linkend="node-2756"/>).
      </para>
<section id="node-2754">
<title>Starting a Network Server</title>
<para>
        To start a network server, make a new instance of the class <ulink url="http://www.spiderland.org/documentation/classes/NetworkServer.html">NetworkServer</ulink>. The NetworkServer class is used for
        both receiving object from other breve simulations, and for allowing a
        web interface to your breve simulation.
      </para><para>
        Once the NetworkServer instance has been created, it should be told to
        start listening for connections using the method <ulink url="http://www.spiderland.org/documentation/classes/NetworkServer.html#listen">listen</ulink>. The listen method expects a port number which
        must be greater than 1024, but otherwise may be any unused port that
        both the client and the server breve users can agree to.
      </para>
</section>
<section id="node-2755">
<title>Sending and Receiving breve Objects</title>
<para>
        In order to send and receive objects over the network, the objects must
        be prepared for archiving and dearchiving as described in <xref linkend="node-2748"/>. Read
        that section first to be certain that your objects can be properly
        encoded and decoded.
      </para><para>
        When sending an instance over the network, breve recreates the instance
        on the server machine. It recreates the object and the state of all of
        its variables, except that variables of type <literal>object</literal> and <literal>pointer</literal> can
        not be automatically maintained without special treatment. The reason
        for this and the solution are described in <xref linkend="node-2748"/>.
      </para><para>
        To send an object over the network, use the Object method <literal><ulink url="http://www.spiderland.org/documentation/classes/Object.html#send-over-network">send-over-network</ulink></literal> with the server computer's
        hostname and port:
      </para><programlisting>
        response = ( self send-over-network to "myOtherComputer" on 31337 ).
</programlisting><para>
        If a NetworkServer receives an instance upload from another host, it
        dearchives the object, adds it to the simulation, then informs the
        controller of the newly added object with the callback method
        <literal>accept-upload</literal>. You should implement your
        own <literal>accept-upload</literal> with the following
        method declaration:
      </para><para>
        The function <literal>send-over-network</literal> may return
        a response object if one is sent by the server. This is described in
        more detail below.
      </para><programlisting>
        + to accept-upload of-instance newInstance (object) from-host clientHostname (string):
</programlisting><para>
        The newly created instance, and the hostname which sent the instance
        are passed in as arguments. This method may optionally return an object
        which will be encoded and returned to the host which initiated the
        network connection.
      </para>
</section>
<section id="node-2756">
<title>Using a Web-interface to a breve Simulation</title>
<para>
        The NetworkServer object can accept connections from regular
        web-browsers. After the NetworkServer starts running, you can get the
        address that clients should connect to by using the method <ulink url="http://www.spiderland.org/documentation/classes/NetworkServer.html#get-url">get-url</ulink>. The URL will be the hostname (or IP address)
        of the server machine, followed by a ":<emphasis><function>portNumber</function></emphasis>".
      </para><para>
        When a web-client connects to the server, it may do one of two things:
        it may execute a command in the simulation's controller object, or it
        may request an HTML page.
      </para>
<section id="node-2757">
<title>Executing Controller Commands Via Web Requests</title>
<para>
        To execute a method in the controller instance, simply append the
        method name to the end of the URL. If you wish to pass in either int or
        float arguments, they can be added afterwords, delimited by
        underscores. Other types may currently not be passed via the web
        interface. Here are some examples:
      </para><programlisting>
# call the Controller method "turn-agent-blue"
http://myserver:33333/turn-agent-blue

# call the Controller method "set-agent-color" with three float type arguments.
http://myserver:33333/set-agent-color_.2_.4_.6
</programlisting><para>
        The controller methods called may optionally return a string which will
        determine what information is sent back to the web-browser. If the
        string ends with ".html", breve will try to load data from an HTML on
        the local disk and send it back to the web-browser (sending HTML files
        is described in more detail in the next section). Otherwise, the string
        itself is returned to the web-broswer.
      </para>
</section>
<section id="node-2758">
<title>Serving HTML Pages Via Web Requests</title>
<para>
        If an HTTP request to a breve network server ends with ".html", breve
        will try to provide the web-browser with an HTML file from the local
        disk. This feature is not typically used to serve informational web
        files as a normal web server might&#x2014;instead, it should be used to
        serve files containing "links" that will execute controller commands in
        the simulation, as described above (<xref linkend="node-2757"/>).
      </para><para>
        Additionally, you can set an "index" page that will be served to the
        web-browser when they send a request to your server without an actual
        page or method request, for example, http://myserver:33333. This index
        page can be set using the method <ulink url="http://www.spiderland.org/documentation/classes/NetworkServer.html#set-index-page">set-index-page</ulink>.
      </para>
</section>
</section>
</chapter>
<chapter id="node-2765"><?dbhtml dir="docs" ?>
<title>Plugins</title>
<para> breve's
        plugin architecture allows you to incorporate arbitrary code into a
        breve simulation. By loading external code into breve, you can add
        customized types of computation, bridges to other languages,
        connections to other input and output methods and much more.
      </para><para>
        Effective breve release 2.5, all plugins must be compiled with a C++
        compiler. Plugins may still be written using C, but must be compiled
        with a C++ compiler to accomodate changes made to the plugin API.
      </para><note><title>
              Programming Experience Required
            </title><para>
                Building plugins for breve does require some programming
                experience in C/C++, plus access to and familiarity with the
                g++ compiler. Building plugins on Windows currently requires a
                POSIX environment such as <ulink url="http://www.mingw.org">MinGW</ulink> or <ulink url="http://www.cygwin.com">Cygwin</ulink>.
              </para></note>
<section id="node-2766">
<title>The Plugin API: Writing Plugins</title>
<note><title>
              The breve Plugin API
            </title><para>
                In order to build plugins for breve, you'll need the breve
                plugin API which is included with all command-line
                distributions of breve. You'll also need a C compiler&#x2014;the
                instructions here assume you're using GCC.
              </para><para>
                In addition to the documentation listed here, you should also
                look at the sample plugin files included with the breve
                distribution. These samples show how to build simple plugins
                for Mac OS X, Linux and Windows.
              </para><para>
                A number of the names and symbols have been changed from
                versions of the breve plugin API prior to version 2.0, though
                the older symbols should be preserved for backward
                compatibility. Still, you will most likely have to rebuild your
                plugin using the 2.0 header file to ensure continued
                compatibility.
              </para></note><para>
        In order to write plugins for breve, you'll need to follow a few simple
        steps.
      </para><orderedlist><listitem><para>
              compose C wrapper functions around your external code (C or C++),
              <xref linkend="node-2767"/></para></listitem><listitem><para>
              create an "entry point function" in C which will load your
              functions into the breve engine <xref linkend="node-2772"/></para></listitem><listitem><para>
              write a class (or classes) to interface with your newly created
              functions
            </para></listitem></orderedlist>
<section id="node-2767">
<title>Writing C Wrapper Functions Around Existing Code</title>
<para>
        The first step in composing a breve plugin is to write wrapper
        functions around your existing code. The wrapper functions simply act
        as a bridge between the internal breve function calling code, and
        standard C function calls. When a function is called from within steve,
        the wrapper function is called. The wrapper function, in turn, calls
        the necessary C code and coordinates input and output between the C
        code and the breve call.
      </para><para>
        The wrapper function passes input and output data between breve and C
        using a structure called <literal>brEval</literal>. The
        <literal>brEval</literal> struct is a C data structure which
        is used internally to hold the values of expressions in steve. The
        structure is used to hold any and all types of steve expressions. So
        <literal>ints</literal>, <literal>lists</literal>, <literal>objects</literal> and the
        rest of the steve types are all held in <literal>brEval</literal> structs. The <literal>type</literal> field of the struct specifies the type of the
        expression. The <literal>values</literal> union of the
        struct contains the actual value of the expression. Information on how
        to use these fields is listed below.
      </para><para>
        Wrapper functions have the following prototype:
      </para><programlisting>
int function(brEval arguments[], brEval *result, void *instance);
</programlisting><para>
        Arguments are passed in as the <emphasis><function>arguments</function></emphasis> array of <literal>brEval</literal> objects. The function output is returned by
        setting the contents of the brEval
        object pointed to by <emphasis><function>result</function></emphasis>.
        <emphasis><function>instance</function></emphasis> is an internal pointer
        to the calling instance&#x2014;this can be ignored.
      </para>
<section id="node-2768">
<title>Getting Values from the brEval Class</title>
<para> To access native C types stored in the brEval class, you'll need to use the following
        macros, which are defined in the header file distributed with the API.
      </para><itemizedlist><listitem><para><literal>BRINT(&amp;<emphasis><function>eval</function></emphasis>)</literal>, returns the int (C
              type int) contained in <emphasis><function>eval</function></emphasis></para></listitem><listitem><para><literal>BRDOUBLE(&amp;<emphasis><function>eval</function></emphasis>)</literal>, returns the float
              (C type double) contained in <emphasis><function>eval</function></emphasis></para></listitem><listitem><para><literal>BRVECTOR(&amp;<emphasis><function>eval</function></emphasis>)</literal>, returns the vector
              (C type slVector struct) contained in <emphasis><function>eval</function></emphasis></para></listitem><listitem><para><literal>BRMATRIX(&amp;<emphasis><function>eval</function></emphasis>)</literal>, returns the matrix
              (C type double [3][3]) contained in <emphasis><function>eval</function></emphasis></para></listitem><listitem><para><literal>BRBRRING(&amp;<emphasis><function>eval</function></emphasis>)</literal>, returns the string
              (C type char*) contained in <emphasis><function>eval</function></emphasis></para></listitem><listitem><para><literal>BROBJECT(&amp;<emphasis><function>eval</function></emphasis>)</literal>, returns the object
              (C type brInstance*) contained in <emphasis><function>eval</function></emphasis></para></listitem><listitem><para><literal>BRPOINTER(&amp;<emphasis><function>eval</function></emphasis>)</literal>, returns the pointer
              (C type void*) contained in <emphasis><function>eval</function></emphasis></para></listitem><listitem><para><literal>BRDATA(&amp;<emphasis><function>eval</function></emphasis>)</literal>, returns the data (C
              type brData*) contained in <emphasis><function>eval</function></emphasis></para></listitem><listitem><para><literal>BRHASH(&amp;<emphasis><function>eval</function></emphasis>)</literal>, returns the hash (C
              type brEvalHash*) contained in <emphasis><function>eval</function></emphasis></para></listitem><listitem><para><literal>BRLIST(&amp;<emphasis><function>eval</function></emphasis>)</literal>, returns the list (C
              type brEvalList*) contained in <emphasis><function>eval</function></emphasis></para></listitem></itemizedlist>
</section>
<section id="node-2769">
<title>Setting Values in the brEval Class</title>
<para>
        In order to set the result, use the overloaded method <literal>set()</literal> in the brEval class. This method can take any
        of the C types listed above and will set the brEval's type according to
        the input type. Some examples are shown below.
      </para><programlisting>
        // for a function returning an integer
        result-&gt;set( 10 );

        // for a function returning a string
        char *myString = "look at me, I'm returning a string!";
        result-&gt;set( myString );
</programlisting><para>
        In most cases, passing data to <literal>set()</literal> is
        as simple as the examples above. However, care must be taken to ensure
        that the C-type being passed in corresponds to the desired brEval type.
        This may become an issue, for example, if a plugin calculation uses
        floating point math, but desires to return an integer, or when
        returning NULL pointers. It is therefore necessary to explicitly
        typecast values which do not match the expected return type. Some
        examples are shown below. In each example, the wrong type would be used
        without the typecast.
      </para><programlisting>
        // our calculation creates a double, but we wish to return an AT_INT type to breve:
        result-&gt;set( (int)pow( x, y ) );

        // we want to return an AT_STRING type, but the value is NULL:
        result-&gt;set( (char*)NULL );

        // now we want to return an AT_LIST type, but the value is NULL:
        result-&gt;set( (brEvalListHead*)NULL );
</programlisting>
</section>
<section id="node-2770">
<title>Types in the brEval Class</title>
<para>
        The following list of constants specifies the types for plugin function
        input arguments and output types. The "AT" prefix stands for "atomic
        type".
      </para><itemizedlist><listitem><para><literal>AT_INT</literal></para></listitem><listitem><para><literal>AT_DOUBLE</literal></para></listitem><listitem><para><literal>AT_STRING</literal></para></listitem><listitem><para><literal>AT_VECTOR</literal></para></listitem><listitem><para><literal>AT_MATRIX</literal></para></listitem><listitem><para><literal>AT_DATA</literal></para></listitem><listitem><para><literal>AT_HASH</literal></para></listitem><listitem><para><literal>AT_LIST</literal></para></listitem><listitem><para><literal>AT_OBJECT</literal></para></listitem><listitem><para><literal>AT_POINTER</literal></para></listitem></itemizedlist><para>
        Your wrapper function should use these macros to extract data from the
        arguments array, and to store the result. The return value of your
        wrapper function should be <literal>EC_OK</literal> in the
        event of successful execution, or <literal>EC_ERROR</literal> in the event of a fatal error. Returning
        <literal>EC_ERROR</literal> will cause the simulation to
        stop, so you should generally not return this value. In many cases it
        is better to indicate the error using a special return value of the
        internal function (that is to say, by putting a special value in the
        "result" struct, not actually returning from your C code with a special
        value). You can then handle the error from within steve.
      </para>
</section>
<section id="node-2771">
<title>An Example Wrapper Function</title>
<para>
        As an example of a breve function wrapper around an existing function,
        imagine a function with the following prototype:
      </para><programlisting>
char *downloadURL(char *url, int timeout);
</programlisting><para>
        The wrapper function in breve will need to extract the url and timeout
        arguments from the arguments array, call the function, and store the
        resulting string in the structure pointed to by result. Here's how the
        wrapper function might look.
      </para><programlisting>
int breveDownloadURL(brEval *arguments, brEval *result, void *instance) {
        char *url, *urlData;
        int timeout;

        url = BRBRRING(&amp;arguments[0]);
        timeout = BRINT(&amp;arguments[1]);

        urlData = downloadURL(url, timeout);

        result-&gt;set( urlData );
                
        return EC_OK;
}
</programlisting>
</section>
</section>
<section id="node-2772">
<title>Writing an Entry Point Function</title>
<para>
        Your entry point function will be called when the plugin is loaded. Its
        job is to tell the breve engine what new steve functions to add, their
        names, and the arguments they will take.
      </para><para>
        The prototype for an entry-point function is:
      </para><programlisting>
void <emphasis><function>entryPointFunctionName</function></emphasis>(void *data);
</programlisting><para>
        The name may be anything you'd like, but it must be a unique symbol.
      </para><para>
        This entry-point function will be filled with one or more calls to the
        function <literal>brNewBreveCall</literal>. The calling
        convention for this function is:
      </para><programlisting>
brNewBreveCall(data, "<emphasis><function>functionName</function></emphasis>", <emphasis><function>cFunctionPointer</function></emphasis>, <emphasis><function>returnType</function></emphasis>, <emphasis><function>arg1</function></emphasis>, <emphasis><function>arg2</function></emphasis>, ..., 0);
</programlisting><itemizedlist><listitem><para>
              The first argument, data, is the "data" pointer which gets passed
              in to the entry-point function.
            </para></listitem><listitem><para>
              The second argument, functionName, is the quoted function name
              <emphasis>as it will appear in
              steve</emphasis>.
            </para></listitem><listitem><para>
              The third argument, cFunctionPointer, is the unquoted name of the
              C function.
            </para></listitem><listitem><para>
              The fourth argument, returnType, is the return type (as a steve
              constant, listed in the previous section).
            </para></listitem><listitem><para>
              Subsequent arguments are the types of input arguments (as steve
              constants, listed in the previous section) that your steve
              function will expect, with the value 0 afterwards indicating the
              end of the parameter list.
            </para></listitem><listitem><para>
              The final argument, to follow all of the input types, must be 0.
            </para></listitem></itemizedlist><para>
        For example, if you have a function which takes two <literal>vector</literal> inputs and produces an <literal>int</literal> output, your <literal>brNewBreveCall</literal> might look like this:
      </para><programlisting>
brNewBreveCall(data, "mySteveFunctionName", myCFunctionName, AT_INT, AT_VECTOR, AT_VECTOR, 0);
</programlisting>
</section>
<section id="node-2773">
<title>Interfacing With The New Functions</title>
<para>
        In order to write plugins for breve, you'll first need to familiarize
        yourself with a feature of steve which is generally hidden from
        users&#x2014;the C-style function call.
      </para><para>
        C-style function calls in breve work just as they do in C: they take a
        number of arguments and may return a value. In breve, a C-style
        function call is used to access code which is built in to the breve
        engine (as opposed to code written in steve). In fact, the built-in
        class hierarchy provided with breve uses C-style function calls
        extensively to interface with the breve engine.
      </para><para>
        From the user's perspective, all computation in breve happens within
        objects. So when we write a plugin, we'll also give it an object
        interface. Here's a simple example in which the plugin simply provides
        some data (like a <literal>float</literal> or an
        <literal>int</literal>) back to the caller.
      </para><programlisting>
Object : mySimplePluginObject {
        + to get-input-from-plugin:
                return getPluginInput().
}
</programlisting><para>
        By packaging this functionality inside an object, breve users look at
        is as they do any other object, without needing any information about
        how the plugin works underneath.
      </para><para>
        The more important reason to use objects, however, is so that the
        plugin can be used by more than one agent simultaneously. Imagine, for
        example, a plugin which simulates neural networks. It's easy to imagine
        that a breve simulation might want to use several of these neural
        networks at the same time. Because the neural networking code requires
        a "persistent state", we would need a way to store many distinct states
        simultaneously.
      </para><para>
        Inside our breve object, we'll hold a pointer to C-memory representing
        these distinct states. Whenever a neural network function is needed,
        we'll pass that pointer back to the plugin so that it can operate on
        the correct state. Here's an example:
      </para><programlisting>
Object : myNeuralNetwork {
        + variables:
                networkPointer (pointer).

        + to init:
                networkPointer = newNeuralNetwork().

        + to iterate:
                neuralNetworkIterate(networkPointer).

        + to get-output:
                return neuralNetworkOutput(networkPointer).

        + to set-input to value (double):
                neuralNetworkSet(networkPointer, value).
}
</programlisting>
</section>
</section>
<section id="node-2774">
<title>Building Plugins</title>
<para>
        Once you've written your wrapper functions as described in the previous
        section, you'll need to compile the source into an object file. Note
        that beginning with breve 2.5, all plugins must be compiled with a C++
        compiler. On a system with gcc/g++ installed, this will probably look
        something like:
      </para><programlisting>
g++ -c <emphasis><function>myPluginFuncs</function></emphasis>.c
</programlisting><para>
        This should produce a file named <emphasis><function>myPluginFuncs</function></emphasis>.o. The final step in the
        process is different for each platform and is outlined below for Mac OS
        X, Linux and Windows.
      </para>
<section id="node-2775">
<title>Building Plugins With Mac OS X</title>
<para> Once you've
        created the object file containing your plugin functions, you'll need
        to execute a command like the following to build the plugin file.
      </para><programlisting>
g++ -bundle -o <emphasis><function>myPlugin</function></emphasis>.o ./<emphasis><function>myPluginFuncs</function></emphasis>.o <emphasis><function>[required libraries]</function></emphasis> -bundle_loader <emphasis><function>/Applications/breve.app</function></emphasis>/Contents/MacOS/breve
</programlisting><para>
        Note that the location of <literal>breve.app</literal> may
        be different on your system, so you'll need to change part of the
        pathname accordingly. Regardless of the path to <literal>breve.app</literal>, you will need to append the text
        "/Contents/MacOS/breve".
      </para><para>
        The <emphasis><function>[required libraries]</function></emphasis>
        means that you may have to include linker options to include any other
        libraries that your plugin relies on. For example, if your plugin
        functions require code from the standard math library, you may need to
        add <literal>-lm</literal>.
      </para>
</section>
<section id="node-2776">
<title>Building Plugins With Linux</title>
<para> Once you've
        created the object file containing your plugin functions, you'll need
        to execute a command like the following to build the plugin file.
      </para><programlisting>
ld -shared -o <emphasis><function>myPlugin</function></emphasis>.so.1.0 ./<emphasis><function>myPluginFuncs</function></emphasis>.o <emphasis><function>[required libraries]</function></emphasis></programlisting><para>
        The <emphasis><function>[required libraries]</function></emphasis>
        means that you may have to include linker options to include any other
        libraries that your plugin relies on. For example, if your plugin
        functions require code from the standard math library, you may need to
        add <literal>-lm</literal>.
      </para>
</section>
<section id="node-2777">
<title>Building Plugins With Windows</title>
<para> Once you've
        created the object file containing your plugin functions, you'll need
        to execute a command like the following to build the plugin file.
        You'll need to have GNU development tools installed to follow the
        instructions listed below.
      </para><programlisting>
dlltool -z <emphasis><function>myPluginFuncs</function></emphasis>.def <emphasis><function>myPluginFuncs</function></emphasis>.o
ld -shared -o <emphasis><function>myPlugin</function></emphasis>.o <emphasis><function>myPluginFuncs</function></emphasis>.o <emphasis><function>myPluginFuncs</function></emphasis>.def <emphasis><function>path_to_breve_binary</function></emphasis>.exe <emphasis><function>[required libraries]</function></emphasis></programlisting><para>
        The <emphasis><function>[required libraries]</function></emphasis>
        means that you may have to include linker options to include any other
        libraries that your plugin relies on. For example, if your plugin
        functions require code from the standard math library, you may need to
        add <literal>-lm</literal>.
      </para>
</section>
</section>
<section id="node-2778">
<title>Archiving Plugin Data With The data Type</title>
<para> The <literal>data</literal> type is used for archiving and dearchiving
        custom binary data. If a plugin creates a large internal block of data,
        for example, how could this data be archived? The <literal>pointer</literal> type cannot be archived because breve doesn't
        know the structure or size of the data that the pointer is referring
        to. The type <literal>data</literal> is therefore used to
        hold a linear block of data of a known type.
      </para><para>
        In order for plugin data to be stored in a breve archive, the data must
        be made into a <literal>data</literal> type. Internally,
        this is represented as the C structure <literal>brData</literal>. The following functions are declared in the
        plugin header file and will allow you to create and free <literal>brData</literal> structures:
      </para><programlisting>
brData *brDataNew(void *data, int length);
void brDataFree(brData *data);
</programlisting><para>
        To archive and dearchive data from a plugin object, you'll need one
        internal function to serialize and encode the state of your plugin
        object and another to deserialize and decode the object. For instance,
        consider a plugin which deals with large matrices, say 100x100 doubles.
        When the simulation is to be archived, the matrix needs to be encoded
        into an <literal>brData</literal> struct and returned to the
        object. When the simulation is to be dearchived, the <literal>brData</literal> needs to be decoded back into a matrix.
      </para><para>
        Here's how these functions might look:
      </para><programlisting>
int archiveMatrix(brEval arguments[], brEval *result, void *instance) {
        // assume that the plugin object passes us the pointer to its matrix
        // also assume that the size of the matrix is 100x100 doubles

        double **matrix = BRPOINTER(&amp;arguments[0]);

        BRDATA(result) = brDataNew(matrix, 100 * 100 * sizeof(double));

        return EC_OK;
}

int dearchiveMatrix(brEval arguments[], brEval *result, void *instance) {
        brData *matrixData = BRDATA(&amp;arguments[0]);
        double **matrix = malloc(100 * 100 * sizeof(double));

        memcpy(matrix, matrixData-&gt;data, 100 * 100 * sizeof(double));

        // now we return the matrix pointer to the object, and the state 
        // of the object is restored!

        BRPOINTER(result) = matrix;

        return EC_OK;
}
</programlisting><para>
        We also need to modify the <literal>archive</literal> and
        <literal>dearchive</literal> methods of our breve plugin
        object to call the new functions:
      </para><programlisting>
+ to archive:
        # convert the internal data to a "data" type
        matrixData = archiveMatrix(matrixPointer).

+ to dearchive:
        # convert the "data" type back to internal data
        matrixPointer = dearchiveMatrix(matrixData).
</programlisting>
</section>
<section id="node-2779">
<title>Using Plugins in Simulations</title>
<para> Loading a
        plugin from within a simulation is relatively simple. First, place the
        plugin in a directory where breve will find it (either a directory in
        your class path, or in a directory specified with a "@path" line). Then
        simply load the plugin using a "@plugin" line at the top of your
        simulation file:
      </para><programlisting>
@plugin "<emphasis><function>pluginName</function></emphasis>" (<emphasis><function>pluginEntryFunction</function></emphasis>).
</programlisting><para>
        The plugin file specified with <literal>@plugin</literal>
        does not always have the extension ".o". The specific type of file
        expected by the <literal>@plugin</literal> directive varies
        by platform. On Linux, the file is normally a shared object file
        (<emphasis><function>pluginName.so</function></emphasis>). On Mac OS X,
        plugins are OS X "bundle" files (<emphasis><function>pluginName.o</function></emphasis> or <emphasis><function>pluginName.bundle</function></emphasis>). On Windows, the
        plugin file is a DLL (<emphasis><function>pluginName.dll</function></emphasis>).
      </para><para>
        Assuming that breve is able to locate and load your plugin file and the
        corresponding class files, you should now be able to use the plugin
        classes in your simulation.
      </para>
</section>
</chapter>
<chapter id="node-2780"><?dbhtml dir="docs" ?>
<title>The breve Source Code</title>
<para>
        This chapter describes the breve source implementation, and how it can
        be extended. This documentation describes only key API features for
        extending certain aspects of breve functionality. For more detailed
        documentation of the source code, see the <ulink url="http://www.spiderland.org/breve/docs/source">full breve
        source code documentation</ulink>.
      </para><para>
        This documentation has changed since breve 2.4. breve 2.4 required the
        use of an additional API, the breve Frontend API, to implement a custom
        language frontend, but this API is now obsolete.
      </para>
<section id="node-2781">
<title>The basic structure of the breve source code</title>
<para>
        The following image shows the basic structure of the breve source code:
      </para><mediaobject><imageobject><imagedata align="center" fileref="images/breve_structure.jpg"/></imageobject></mediaobject><para>
        The text in bold for each layer indicates the source code directory
        where the source code for that layer is found.
      </para>
</section>
<section id="node-2782">
<title>Adding a frontend language to the breve engine: the breve object API</title>
<para>
        This section describes how to incorporate another frontend language
        with breve. Using this information, you'll be able to use the breve
        engine from any language which can interface a C library.
      </para><para>
        The following steps are required to set up a language frontend in
        breve.
      </para><itemizedlist><listitem><para>
              Write special callbacks for the language frontend (<xref linkend="node-2784"/>).
            </para></listitem><listitem><para>
              Construct a new breve object type structure, brObjectType, and
              add classes to the breve engine (<xref linkend="node-2785"/>).
            </para></listitem><listitem><para>
              Test the language frontend using the existing breve program
              (<xref linkend="node-2786"/>).
            </para></listitem><listitem><para>
              If desired, connect the language frontend to an application
              frontend (<xref linkend="node-2787"/>)
              or write your own customized frontend (<xref linkend="node-2794"/>).
            </para></listitem></itemizedlist>
<section id="node-2783">
<title>Structures used by the breve Object API</title>
<para>
        The following structures are used by the breve Object API. These
        structures are passed to the frontend language callback functions. See
        the file <literal>kernel/breveObjectAPI.h</literal> and its
        documentation for a full description of these structs.
      </para><itemizedlist><listitem><para><literal>brObjectType</literal>: information and
              callbacks for a language frontend
            </para></listitem><listitem><para><literal>brObject</literal>: a class in any frontend
              language
            </para></listitem><listitem><para><literal>brInstance</literal>: an instance in any
              frontend language
            </para></listitem><listitem><para><literal>brMethod</literal>: information about a
              method in an object
            </para></listitem></itemizedlist><para>
        You should also familiarize yourself with the <literal>brEval</literal> structure and types which are described in
        <xref linkend="node-2767"/>.
      </para>
</section>
<section id="node-2784">
<title>Callbacks required to add a new frontend language</title>
<para>
        In order to provide a language frontend to breve, a set of callbacks
        must be defined.
      </para><itemizedlist><listitem><para><literal>findObject</literal>: locate a class by name.
            </para><programlisting>
void *(*findObject)( void *inObjectTypeUserData, char *name );
</programlisting><para>
              When breve encounters a class name that it does not recognize, it
              will use this function to attempt to lookup the object. The
              pointer that is returned will be placed in the <literal>pointer</literal> field of a <literal>brObject</literal>. This pointer will likely be used
              later to instantiate objects or locate instance methods by your
              <literal>instantiate</literal> or <literal>findMethod</literal> callbacks.
            </para></listitem><listitem><para><literal>findMethod</literal>: locate a method for a
              class by name and argument count.
            </para><programlisting>
void *(*findMethod)( void *inObjectUserData, const char *inName, unsigned char *inTypes, int inTypeCount );
</programlisting><para>
              When breve needs to call a method in an object, it will be looked
              up using this callback. The <literal>inObjectUserData</literal> argument refers to the object
              in which the method can be found&#x2014;it is the pointer returned
              by your <literal>findObject</literal> callback. The
              <literal>inName</literal> argument is the name of the
              method to look for.
            </para><para>
              The <literal>inTypeCount</literal> argument gives the
              number of arguments that will be passed to the method, and the
              <literal>inTypes</literal> argument contains the
              argument types. The types are described in <xref linkend="node-2767"/></para></listitem><listitem><para><literal>instantiate</literal>: create an instance of
              an object.
            </para><programlisting>
brInstance *(*instantiate)( brEngine *inEngine, brObject *inObject, const brEval **inArguments, int inArgCount )
</programlisting><para>
              breve calls this function to create a new instance of a class.
              The <literal>inObject</literal> argument specifes the
              object to be created and contains the user data found with
              <literal>findObject</literal> in the <literal>userData</literal> field.
            </para><para>
              The function is expected to add the newly created instance to the
              breve engine by calling <literal>brEngineAddInstance</literal>. <literal>brEngineAddInstance</literal> returns a <literal>brInstance</literal>, which should in turn be returned by
              <literal>instantiate</literal>. <literal>brEngineAddInstance</literal> is called as follows:
            </para><programlisting>
brInstance *brEngineAddInstance( brEngine *inEngine, brObject *inObject, void *inInstanceUserData );
</programlisting><para>
              The constructor arguments <literal>inArguments</literal> and count <literal>inArgCount</literal> are currently unused.
            </para></listitem><listitem><para><literal>callMethod</literal>: trigger a method call
              in the frontend language.
            </para><programlisting>
int (*callMethod)(brInstance *instancePointer, brMethod *method, brEval **arguments, brEval *result);
</programlisting><para>
              The breve engine will need to trigger method calls in the
              frontend language for a number of events such as iteration and
              collision handling. This callback is used to trigger such events.
            </para><para>
              The callback is given the instance to be used, a <literal>brInstance</literal> instance structure (which contains a
              native language instance pointer in the "pointer" field); the
              method to be called, a <literal>brMethod</literal>
              structure (which contains a native language method pointer in the
              "pointer" field); an array of <literal>brEval</literal> argument pointers, and a pointer to an
              output <literal>brEval</literal> structure.
            </para><para>
              The callback should trigger the method call <emphasis><function>method</function></emphasis> for the instance
              <emphasis><function>instancePointer</function></emphasis>. It
              expects that the <emphasis><function>arguments</function></emphasis> array contains the
              number of items specified by the <literal>brMethod</literal> structure's argumentCount field.
            </para></listitem><listitem><para><literal>isSubclass</literal>: determine whether a
              class is a subclass of another.
            </para><programlisting>
int (*isSubclass)(brObject *class1, brObject *class2);
</programlisting><para>
              In order to correctly handle certain interactions like
              collisions, the breve engine needs to know whether one class is a
              subclass of another.
            </para><para>
              This callback is given two breve object pointers, and must return
              1 if <emphasis><function>class1</function></emphasis> is a
              subclass of <emphasis><function>class2</function></emphasis>, and
              0 otherwise.
            </para></listitem><listitem><para><literal>destroyObject:</literal> release memory
              allocated by your <literal>findObject</literal>
              callback.
            </para><programlisting>
void (*destoryObject)(void *objectData);
</programlisting><para>
              If your <literal>findObject</literal> callback
              allocates memory, this callback should release that memory.
            </para></listitem><listitem><para><literal>destroyInstance:</literal> release memory
              allocated by your <literal>instantiate</literal>
              callback.
            </para><programlisting>
void (*destoryInstance)(void *instanceData);
</programlisting><para>
              If your <literal>instantiate</literal> callback
              allocates memory, this callback should release that memory.
            </para></listitem><listitem><para><literal>destroyMethod:</literal> release memory
              allocated by your <literal>findMethod</literal>
              callback.
            </para><programlisting>
void (*destoryMethod)(void *methodData);
</programlisting><para>
              If your <literal>findMetho</literal> callback
              allocates memory, this callback should release that memory.
            </para></listitem><listitem><para><literal>destroyObjectType:</literal> release the
              memory associated with your <literal>brObjectType</literal>.
            </para><programlisting>
void (*destroyData)(void *objectTypeData);
</programlisting><para>
              If you have allocate memory to be placed in the <literal>data</literal> field of the <literal>brObjectType</literal>, this callback should release that
              memory.
            </para></listitem></itemizedlist>
</section>
<section id="node-2785">
<title>Specifying a new breve object type, and 
registering objects</title>
<para>
        Every object in a frontend language that will have instances in the
        breve engine must be registered with the breve engine. Moreover, when
        an object is added to the breve engine, it must also tell the engine
        what "type" of object it is. Each object "type" corresponds to a
        different language frontend and a different set of callbacks, so for
        each language frontend one creates, one must also create a <literal>brObjectType</literal> structure which contains the proper
        callbacks. The structure is shown below.
      </para><programlisting>
struct brObjectType {
        /**
         * Finds a method in a given class
         */
        void                    *(*findMethod)( void *inObject, const char *inName, unsigned char *inTypes, int inTypeCount );

        /**
         * Finds an object class in the given language frontend
         */
        void                    *(*findObject)( void *inObjectType, const char *inName );

        /**
         * Creates a new instance of the given class.  The constructor arguments are currently unused.
         */
        brInstance              *(*instantiate)( brEngine *inEngine, brObject *inObject, const brEval **inArguments, int inArgCount );

        /**
         * Calls a method in the language frontend
         */
        int                     (*callMethod)( void *inInstance, void *, const brEval **, brEval * );

        /**
         * Returns 1 if parent is a subclass of parent.
         */
        int                     (*isSubclass)( void *inChild, void *inParent );

        /**
         * Destroys an instance of a language object previously created with instantiate.
         */
        void                    (*destroyObject)( void *inObject );

        /**
         * Destroys an instance of a language method previously created with findMethod.
         */
        void                    (*destroyMethod)( void *inMethod );

        /**
         * Destroys an instance of a language instance previously created with instantiate.
         */
        void                    (*destroyInstance)( void *inInstance );

        /**
         * Frees any leftover memory associated with the frontend, typically _userData.
         */
        void                    (*destroyObjectType)( void *inObjectType );
        
        /**
         * A function to execute code in this frontend language.
         */                     
        int                     (*evaluate)( brEngine *inEngine, char *inFilename, char *inFiletext );

        /**
         * A user-data callback pointer.
         */
        void                    *_userData;
        
        /**
         * A unique identifier which will be set for all objects of this object type.  This
         * identifier can be used to determine whether an instance or object is native to
         * a certain object type.
         */
        long                    _typeSignature;

};
</programlisting><para>
        Only one <literal>brObjectType</literal> is required for
        each language frontend.
      </para><para>
        Once the language frontend is defined, you can add it to the engine
        with the following function:
      </para><programlisting>
void brEngineRegisterObjectType( brEngine *engine, brObjectType *type );
</programlisting>
</section>
<section id="node-2786">
<title>Testing and using the object frontend</title>
<para>
        Once you have written code to setup and register your new breve object
        type, you'll want to test that breve can locate objects, instantiate
        them and call their methods. To do so, you can add your frontend object
        type to the breve engine, and then instantiate an object from steve
        code.
      </para><para>
        To add your frontend object type to the breve engine, edit the file
        <literal>kernel/frontendAPI.c</literal>, and look at the
        function <literal>breveFrontendInit</literal>. The existing
        breve applications call this function to create a breve engine. At the
        bottom of this function, you can create and register your custom
        language frontend.
      </para><programlisting>
brEngineRegisterObjectType(frontend-&gt;engine, <emphasis><function>functionToCreateLanguageFrontend</function></emphasis>());
</programlisting><para>
        After recompiling breve with this change, it should be possible to
        instantiate an object from your new language frontend from directly
        within a steve simulation. See the Java example <literal>java/JavaTest.tz</literal> for more information.
      </para>
</section>
</section>
<section id="node-2794">
<title>Embedding breve In Another Program</title>
<para>
        To implement a custom application frontend, or to use breve simulations
        as part of another program, you'll need to familiarize yourself with
        functions relating to the breve engine structure <literal>brEngine</literal>.
      </para><itemizedlist><listitem><para>
              Create and initialize the breve engine (<literal>brEngineNew</literal>)
            </para><para>
              Call <literal>brEngineNew()</literal> to get a breve
              engine. You may optionally pass in command-line arguments using
              the alternative function <literal>brEngineNewWithArguments( argc, argv )</literal>. After
              creating the engine, initialize the standard frontend languages
              using <literal>brInitFrontendLanguages( engine
              )</literal></para><programlisting>
engine = brEngineNew();
brInitFrontendLanguages( engine );
</programlisting></listitem><listitem><para>
              Add breve file search paths using <literal>brAddSearchPath( engine, path )</literal>. The search
              paths must be properly initialized so that breve can locate the
              standard class files.
            </para><programlisting>
brAddSearchPath( engine, "lib/classes/breve" );
brAddSearchPath( engine, "lib/classes/mybreveclasses" );
</programlisting></listitem><listitem><para>
              Start a simulation using <literal>brLoadSimulation</literal>.
            </para><programlisting>
brLoadSimulation( engine, simulationText, simulationFilename );
</programlisting></listitem><listitem><para>
              Iterate the breve engine (<literal>brEngineIterate</literal>) repeatedly in your program's
              execution loop.
            </para><programlisting>
brEngineIterate( engine );
</programlisting></listitem></itemizedlist>
</section>
</chapter>
<chapter id="node-3246"><?dbhtml dir="docs" ?>
<title>The Python Bridge</title>
<para>
      Starting in version 2.5.1, breve supports an experimental bridge to the
      Python language. This means that your simulation can execute Python code
      to preform computation. Communication between the languages is done by
      creating objects in the other language: Python objects can be created
      from steve code, and vice versa.
    </para><para>
      This feature is in-development and is subject to minor changes.
    </para>
<section id="node-3247">
<title>Writing Python Code for Inclusion in breve</title>
<para>
      All Python files to be loaded into breve should import the breve module
      to gain access to important breve engine functionality. In order for a
      Python object to be compatible with the breve engine, it must be a
      subclass of the breve Python module class breve.object. If an object is
      not a subclass of breve.object, it will not be visible to the breve
      engine. The <literal>__init__</literal> method of the class must execute the
      <literal>breve.object.__init__</literal> method before any breve bridge
      functionality is used.
    </para><para>
      The following example illustrates a basic Python file with a simple
      breve-compatible class defined:
    </para><programlisting>
@import breve


class PythonBridgeObject( breve.object ):
        def __init__( self ):
                breve.object.__init__( self )
                print "Inited Python bridge object"


        def iterate( self ):
                print "Iterating Python bridge object"</programlisting><para>
      This simple Python object will be visible to the breve engine and will
      have its iterate method called at each iteration of the breve engine.
    </para>
</section>
<section id="node-3248">
<title>Importing and Executing Python Code From Steve</title>
<para>
      To include a Python file from a steve simulation file, simply use an
      <literal>"@include"</literal> statement with the name of the Python file, just
      as steve files are included.
    </para><para>
      To use a Python class from a steve file, simply create a new instance of
      the class exactly as you would with a steve object. Likewise, methods can
      be called in the new object exactly as usual. Because of differences
      between the two languages, there are a few minor differences in calling
      objects over the bridge:
    </para><itemizedlist><listitem><para>Keywords are ignored for arugment passing. Instead, arguments are
      expected in the order they are defined for a method. When calling Python
      methods from steve, you can use made-up keyword names (to preserve the
      normal steve syntax), but be sure to match the argument order of the
      python method.
      </para></listitem><listitem><para>steve uses the "-" (dash) character in many method names, but Python
      does not allow this character in method names. If calling a steve method
      from Python, use the "_" (underscore) character in place of "-". The
      character will be automatically converted.
      </para></listitem></itemizedlist>
</section>
<section id="node-3249">
<title>Additional Notes</title>
<para>
      Foreign language objects appear to behave exactly as native objects,
      meaning that methods are called in native syntax. For typical usage, this
      is the only thing that matters.
    </para><para>
      The foreign language objects are not, however, truely native. The objects
      are actually "bridge objects", which forward method calls to the native
      object. Practically speaking, this means a couple of things:
    </para><itemizedlist><listitem><para>Bridge objects always appear to be of the same type, no matter what
      type they actually represent in their native language.
      </para></listitem><listitem><para>Functions which inspect internal object state will be inspecting the
      bridge object, not the object that the bridge represents.
      </para></listitem></itemizedlist><para>
      These details are subtle and do not effect most typical object usage.
      Just remember that bridge objects are "shells" for other objects, and not
      the actual objects they appear to be.
    </para>
</section>
</chapter>
<chapter id="node-2759"><?dbhtml dir="docs" ?>
<title>The "Push" Language</title>
<para>
        This chapter describes genetic programming, and describes how to use
        genetic programming in breve simulations using an evolvable language
        called "Push".
      </para><para>
        Many artificial life simulations are designed around the concept of
        evolving agents: agents in a simulated world use evolution in order to
        find better and better solutions to some task such as locomotion,
        survival or some sort of "intelligent" behavior.
      </para><para>
        Evolution of agent behaviors is typically accomplished in one of two
        ways: optimizing a set of parameters, a technique known as "genetic
        algorithms" (GA); or by developing evolved computer programs, a
        technique known as "genetic programming".
      </para><para>
        Genetic programming involves random crossover and mutation of computer
        programs. Most computer languages designed for people are picky about
        syntax and variable types and are not well suited to
        evolution&#x2014;most random crossovers and mutations would produce code
        that simply does not compile (like <literal>x = y +
        =;</literal>), or code which does compile, but which semantically does not
        make sense (like <literal>x = sqrt( "puppydog"
        );</literal>).
      </para><para>
        The "Push" language is designed specifically for genetic programming
        and other evolutionary computational applications. Push is designed to
        avoid most of the complications that can arise when evolving code. In
        fact, Push code is almost never written by hand. This chapter is
        intended as a short introduction to using Push in a breve simulation
        and is not a definitive overview of Push or its features. More
        information about Push and how it is being used can be found on
        <ulink url="http://hampshire.edu/lspector/push.html">this
        page</ulink>.
      </para>
<section id="node-2760">
<title>A Brief Introduction to Push</title>
<para>
        The Push language is well suited for evolution because of its extremely
        simple syntax, and its stack-based typing system. The simple syntax
        helps to ensure that any kind of genetic operator (including the
        commonly used crossover and mutation) will produce a syntactically
        valid individual. The stack-based typing system&#x2014;in which
        instructions look for operators on typed stacks&#x2014;ensures that all
        push programs are semantically valid.
      </para><para>
        Arguments are passed to instructions using a set of stacks, one for
        each variable type. When an instruction is executed, it reads and
        removes argument values from the tops of the relevant stacks, it
        performs a computation, and then it pushes any output values onto the
        relevant stacks. If a stack is empty and cannot provide input values
        for an instruction, the instruction performs a "NOOP" and does nothing.
        This scheme ensures that instructions are always provided with input
        data of the correct type.
      </para><para>
        The version of push built into breve 2.0 provides support for the
        following native types: integer, float, name, vector and code.
      </para><para>
        A Push program is made up of lists of the following elements:
        instructions, literal values, and sublists of these elements. Execution
        of a Push program begins by placing the entire expression onto the code
        stack and proceeds recursively as follows:
      </para><programlisting>
        To execute program P:
                If P is a single instruction then execute it.
                Else if P is a literal then push it onto the appropriate stack.
                Else (P must be a list) sequentially execute each of the Push programs in P.
</programlisting><para>
        Here's a sample Push program which does some mathematical and logical
        computations:
      </para><programlisting>
( 2 3 INTEGER.* 4.1 5.2 FLOAT.+ TRUE FALSE BOOLEAN.OR )
</programlisting><para>
        After execution of the program, the stacks are left in the following
        states:
      </para><programlisting>
        # the program we started with
        CODE STACK: ( ( 2 3 INTEGER.* 4.1 5.2 FLOAT.+ TRUE FALSE BOOLEAN.OR ) )

        # the result of the code TRUE FALSE BOOLEAN.OR
        BOOLEAN STACK: ( TRUE )

        # the result of the code 4.1 5.2 FLOAT.+
        FLOAT STACK: ( 9.3 )

        # the result of the code 2 3 INTEGER.*
        INTEGER STACK: ( 6 )
</programlisting><para>
        Real push programs are far more complex: instructions are provided to
        allow push programs to modify their own code, perform logical and
        program flow control operations. and even create and run new programs
        on-the-fly (automatically providing support for elements which resemble
        macros and "automatically defined functions"). For a full list of Push
        instructions and features, see <ulink url="http://hampshire.edu/lspector/push.html">this page</ulink>.
      </para>
</section>
<section id="node-2761">
<title>Creating and Configuring Push Environments</title>
<para>
        To create a new push interpreter, simply create a new instance of the
        class <ulink url="http://www.spiderland.org/documentation/classes/PushInterpreter.html">PushInterpreter</ulink>.
      </para><para>
        An important decision in creating a PushGP experiment is deciding what
        Push instructions will be available to evolution. It is important to
        choose instructions that will give evolving programs the right tools to
        solve the problems they are given.
      </para><para>
        These instructions and other parameters must are specified using a Push
        configuration file which is loaded into the interpreter with the
        PushInterpreter method <ulink url="http://www.spiderland.org/documentation/classes/PushInterpreter.html#read-config">read-config</ulink>. A full list of Push instructions and
        parameters, as well as instructions on setting up a Push configuration
        file are available <ulink url="http://hampshire.edu/lspector/push.html">here</ulink>.
      </para>
</section>
<section id="node-2762">
<title>Running and Evolving Push Programs</title>
<para>
        A program in the Push language is stored in a <ulink url="http://www.spiderland.org/documentation/classes/PushProgram.html">PushProgram</ulink> object. This object provides methods for
        parsing Push programs, creating random programs, breeding and mutating
        programs and more. All of these features are described in detail in the
        class documentation.
      </para><para>
        Running a Push program is accomplished with help from the
        PushInterpeter object. Typically, the steps involved in running a Push
        program are:
      </para><itemizedlist><listitem><para>
              Create and configure the Push interpreter
            </para></listitem><listitem><para>
              Clear the interpreter's stacks with the method <ulink url="http://www.spiderland.org/documentation/classes/PushInterpreter.html#clear-stacks">clear-stacks</ulink>.
            </para></listitem><listitem><para>
              Push input values onto the interpreter's stacks (using various
              methods in the PushInterpreter <ulink url="http://www.spiderland.org/documentation/classes/PushInterpreter.html">PushInterpreter</ulink> class).
            </para></listitem><listitem><para>
              Run the push program with the method <ulink url="http://www.spiderland.org/documentation/classes/PushInterpreter.html#run">run</ulink>.
            </para></listitem><listitem><para>
              Read output values from the interpreter's stacks (using various
              methods in the PushInterpreter <ulink url="http://www.spiderland.org/documentation/classes/PushInterpreter.html">PushInterpreter</ulink> class).
            </para></listitem></itemizedlist>
</section>
<section id="node-2763">
<title>Genetic Programming With the PushGP Class</title>
<para>
        The simplest way to run a basic genetic programming experiment with
        Push is to override the included <ulink url="http://www.spiderland.org/documentation/classes/PushGP.html">PushGP</ulink> class. Using this class, you need only to implement
        two simple methods to create a basic PushGP experiment. One method sets
        up the PushInterpreter before running a fitness test, and the other
        inspects the interpreter after running the fitness test to determine
        the fitness of the output.
      </para><para>
        See the <ulink url="http://www.spiderland.org/documentation/classes/PushGP.html">PushGP</ulink> class for more information.
      </para>
</section>
<section id="node-2764">
<title>Interacting with the Simulated World Using Callback Instructions</title>
<para>
        Push includes a variety of instructions for performing computation on
        the native Push types, but does not provide instructions for
        interacting with the the simulated world or simulated agents. If you
        plan to evolve behaviors for simulated agents, you will need to provide
        instructions by which Push programs can read input data from the world
        ("sensors") and other output instructions by which the programs can
        modify the agent's behavior ("actuators").
      </para><para>
        Instructions are added to a PushInterpreter with the method <ulink url="http://www.spiderland.org/documentation/classes/PushInterpreter.html#add-instruction">add-instruction</ulink>. The method is passed a name for the
        new instruction, the name of the "callback" method, and the breve
        instance which is to receive the method call. When the newly created
        instruction is called, the specified method will be called for the
        specified instance.
      </para><para>
        An input callback instruction ("sensor") will typically read values
        from the world from an agent's perspective and push the values onto a
        Push stack so that they can be used for computation. A "find-food"
        instruction, for example, may find the closest food object to an agent,
        and push onto the vector stack a vector toward the food object.
      </para><para>
        An output callback instruction ("actuator") will typically take values
        from the Push interpreter's stack and use those values to perform an
        action in the world. A "move-towards" instruction, for example, might
        read a vector value from the vector stack, and then use the breve
        method "set-velocity" to direct the agent towards the Push-computed
        location.
      </para>
</section>
</chapter>
<chapter id="node-2795"><?dbhtml dir="docs" ?>
<title>The Built-In breve Class APIs</title>
This section lists all of the built-in breve class objects. These objects
      are used to interact with specific features in the breve engine.
    
<section id="node-2833">
<title>Mobile</title>
<para>
        Mobile objects are objects in the simulated world which move around and
        interact with other objects. This is in contrast to Stationary objects
        which can collide and interact with other objects but which never move.
        When a Mobile object is created, it will be by default a simple sphere.
        You can change the appearance of this sphere by using methods in this
        class, or its parent class Real. Or you can change the shape altogether
        with the method set-shape.
      </para><para> Full API
        documentation for the class <literal>Mobile</literal> can be
        found <ulink url="http://www.spiderland.org/documentation/classes/Mobile.html">here</ulink>.
      </para>
</section>
<section id="node-2796">
<title>Abstract</title>
<para>
        Abstract is a logical separation of the Object class, used for objects
        which have no representation in the simulated world. This is in
        contrast to Real objects, which do have representations in the
        simulated world. Since "abstract" is only a logical distinction, the
        Abstract class currently has no methods implemented.
      </para><para> Full API
        documentation for the class <literal>Abstract</literal> can
        be found <ulink url="http://www.spiderland.org/documentation/classes/Abstract.html">here</ulink>.
      </para>
</section>
<section id="node-2797">
<title>BallJoint</title>
<para>
        This subclass of Joint is used to link two Link objects together using
        a ball joint. A universal joint has three degrees of freedom. It can
        tilt "up-and-down" and "side-to-side", and can "twist". Your neck is
        basically a ball joint--your head tilt up-and-down, side-to-side, and
        can twist (although not all the way around--if your head turns all the
        way around, please consult the user manual for repair).
      </para><para>
        This joint uses a scheme of 3 Euler angles to represent the relative
        rotation between two objects. The Z-axis of rotation is automatically
        derived from the parent link point, meaning that the Z-axis rotation is
        always a "twist" relative to the link point. The X-axis of rotation is
        specified by the user with the normal argument. The Y-axis is
        automatically derived from the other two.
      </para><para>
        Because of a limitation of the physics engine, the Y-axis rotation is
        limited to a range of approximately +/- 80 degrees of rotation.
      </para><para>
        If versions of breve prior to 2.3, there was no normal argument because
        the axes of rotation were automatically defined. The argument is
        therefore optional for backwards compatibility only, and should always
        be specified when writing new code.
      </para><para> Full API
        documentation for the class <literal>BallJoint</literal> can
        be found <ulink url="http://www.spiderland.org/documentation/classes/BallJoint.html">here</ulink>.
      </para>
</section>
<section id="node-2798">
<title>BraitenbergControl</title>
<para>
        This class is used for building simple Braitenberg vehicle simulations.
        To create a Braitenberg vehicle simulation, subclass BraitenbergControl
        and use the init method to create BraitenbergLight and
        BraitenbergVehicle objects.
      </para><para> Full API
        documentation for the class <literal>BraitenbergControl</literal> can be found <ulink url="http://www.spiderland.org/documentation/classes/BraitenbergControl.html">here</ulink>.
      </para>
</section>
<section id="node-2799">
<title>BraitenbergHeavyVehicle</title>
<para>
        A heavy duty version of BraitenbergVehicle, this vehicle is heavier and
        harder to control, but more stable at higher speeds. For new
        Braitenberg Vehicle simulations, using this class may be preferred over
        the normal BraitenbergVehicle. This object was added as a separate
        class to preserve backwards compatibility for existing Braitenberg
        Vehicle simulations.
      </para><para> Full API
        documentation for the class <literal>BraitenbergHeavyVehicle</literal> can be found <ulink url="http://www.spiderland.org/documentation/classes/BraitenbergHeavyVehicle.html">here</ulink>.
      </para>
</section>
<section id="node-2800">
<title>BraitenbergLight</title>
<para> Full API
        documentation for the class <literal>BraitenbergLight</literal> can be found <ulink url="http://www.spiderland.org/documentation/classes/BraitenbergLight.html">here</ulink>.
      </para>
</section>
<section id="node-2801">
<title>BraitenbergSensor</title>
<para>
        A BraitenbergSensor is used in conjunction with BraitenbergVehicle to
        build Braitenberg vehicles. This class is typically not instantiated
        manually, since BraitenbergVehicle creates one for you when you add a
        sensor to the vehicle.
      </para><para> Full API
        documentation for the class <literal>BraitenbergSensor</literal> can be found <ulink url="http://www.spiderland.org/documentation/classes/BraitenbergSensor.html">here</ulink>.
      </para>
</section>
<section id="node-2802">
<title>BraitenbergVehicle</title>
<para> Full API
        documentation for the class <literal>BraitenbergVehicle</literal> can be found <ulink url="http://www.spiderland.org/documentation/classes/BraitenbergVehicle.html">here</ulink>.
      </para>
</section>
<section id="node-2803">
<title>BraitenbergWheel</title>
<para> Full API
        documentation for the class <literal>BraitenbergWheel</literal> can be found <ulink url="http://www.spiderland.org/documentation/classes/BraitenbergWheel.html">here</ulink>.
      </para>
</section>
<section id="node-2804">
<title>Camera</title>
<para> Full API
        documentation for the class <literal>Camera</literal> can be
        found <ulink url="http://www.spiderland.org/documentation/classes/Camera.html">here</ulink>.
      </para>
</section>
<section id="node-2805">
<title>Control</title>
<para> Full API
        documentation for the class <literal>Control</literal> can
        be found <ulink url="http://www.spiderland.org/documentation/classes/Control.html">here</ulink>.
      </para>
</section>
<section id="node-2806">
<title>Cube</title>
<para> Full API
        documentation for the class <literal>Cube</literal> can be
        found <ulink url="http://www.spiderland.org/documentation/classes/Cube.html">here</ulink>.
      </para>
</section>
<section id="node-2807">
<title>CustomShape</title>
<para> Full API
        documentation for the class <literal>CustomShape</literal>
        can be found <ulink url="http://www.spiderland.org/documentation/classes/CustomShape.html">here</ulink>.
      </para>
</section>
<section id="node-2808">
<title>Data</title>
<para> Full API
        documentation for the class <literal>Data</literal> can be
        found <ulink url="http://www.spiderland.org/documentation/classes/Data.html">here</ulink>.
      </para>
</section>
<section id="node-2809">
<title>Drawing</title>
<para> Full API
        documentation for the class <literal>Drawing</literal> can
        be found <ulink url="http://www.spiderland.org/documentation/classes/Drawing.html">here</ulink>.
      </para>
</section>
<section id="node-2810">
<title>FFNetwork</title>
<para> Full API
        documentation for the class <literal>FFNetwork</literal> can
        be found <ulink url="http://www.spiderland.org/documentation/classes/FFNetwork.html">here</ulink>.
      </para>
</section>
<section id="node-2811">
<title>File</title>
<para> Full API
        documentation for the class <literal>File</literal> can be
        found <ulink url="http://www.spiderland.org/documentation/classes/File.html">here</ulink>.
      </para>
</section>
<section id="node-2812">
<title>FixedJoint</title>
<para> Full API
        documentation for the class <literal>FixedJoint</literal>
        can be found <ulink url="http://www.spiderland.org/documentation/classes/FixedJoint.html">here</ulink>.
      </para>
</section>
<section id="node-2813">
<title>Floor</title>
<para> Full API
        documentation for the class <literal>Floor</literal> can be
        found <ulink url="http://www.spiderland.org/documentation/classes/Floor.html">here</ulink>.
      </para>
</section>
<section id="node-2814">
<title>GADirectedGraph</title>
<para> Full API
        documentation for the class <literal>GADirectedGraph</literal> can be found <ulink url="http://www.spiderland.org/documentation/classes/GADirectedGraph.html">here</ulink>.
      </para>
</section>
<section id="node-2815">
<title>GADirectedGraphConnection</title>
<para> Full API
        documentation for the class <literal>GADirectedGraphConnection</literal> can be found <ulink url="http://www.spiderland.org/documentation/classes/GADirectedGraphConnection.html">here</ulink>.
      </para>
</section>
<section id="node-2816">
<title>GADirectedGraphNode</title>
<para> Full API
        documentation for the class <literal>GADirectedGraphNode</literal> can be found <ulink url="http://www.spiderland.org/documentation/classes/GADirectedGraphNode.html">here</ulink>.
      </para>
</section>
<section id="node-2817">
<title>GADirectedGraphParameterObject</title>
<para> Full API
        documentation for the class <literal>GADirectedGraphParameterObject</literal> can be found <ulink url="http://www.spiderland.org/documentation/classes/GADirectedGraphParameterObject.html">here</ulink>.
      </para>
</section>
<section id="node-2818">
<title>GAIndividualTransporter</title>
<para> Full API
        documentation for the class <literal>GAIndividualTransporter</literal> can be found <ulink url="http://www.spiderland.org/documentation/classes/GAIndividualTransporter.html">here</ulink>.
      </para>
</section>
<section id="node-2819">
<title>GeneticAlgorithm</title>
<para> Full API
        documentation for the class <literal>GeneticAlgorithm</literal> can be found <ulink url="http://www.spiderland.org/documentation/classes/GeneticAlgorithm.html">here</ulink>.
      </para>
</section>
<section id="node-2820">
<title>GeneticAlgorithmIndividual</title>
<para> Full API
        documentation for the class <literal>GeneticAlgorithmIndividual</literal> can be found <ulink url="http://www.spiderland.org/documentation/classes/GeneticAlgorithmIndividual.html">here</ulink>.
      </para>
</section>
<section id="node-2821">
<title>Genome</title>
<para> Full API
        documentation for the class <literal>Genome</literal> can be
        found <ulink url="http://www.spiderland.org/documentation/classes/Genome.html">here</ulink>.
      </para>
</section>
<section id="node-2822">
<title>Graph</title>
<para> Full API
        documentation for the class <literal>Graph</literal> can be
        found <ulink url="http://www.spiderland.org/documentation/classes/Graph.html">here</ulink>.
      </para>
</section>
<section id="node-2823">
<title>Image</title>
<para> Full API
        documentation for the class <literal>Image</literal> can be
        found <ulink url="http://www.spiderland.org/documentation/classes/Image.html">here</ulink>.
      </para>
</section>
<section id="node-2824">
<title>Joint</title>
<para> Full API
        documentation for the class <literal>Joint</literal> can be
        found <ulink url="http://www.spiderland.org/documentation/classes/Joint.html">here</ulink>.
      </para>
</section>
<section id="node-2825">
<title>Line</title>
<para> Full API
        documentation for the class <literal>Line</literal> can be
        found <ulink url="http://www.spiderland.org/documentation/classes/Line.html">here</ulink>.
      </para>
</section>
<section id="node-2826">
<title>Link</title>
<para> Full API
        documentation for the class <literal>Link</literal> can be
        found <ulink url="http://www.spiderland.org/documentation/classes/Link.html">here</ulink>.
      </para>
</section>
<section id="node-2827">
<title>Matrix</title>
<para> Full API
        documentation for the class <literal>Matrix</literal> can be
        found <ulink url="http://www.spiderland.org/documentation/classes/Matrix.html">here</ulink>.
      </para>
</section>
<section id="node-2828">
<title>Matrix2D</title>
<para> Full API
        documentation for the class <literal>Matrix2D</literal> can
        be found <ulink url="http://www.spiderland.org/documentation/classes/Matrix2D.html">here</ulink>.
      </para>
</section>
<section id="node-2829">
<title>Matrix3D</title>
<para> Full API
        documentation for the class <literal>Matrix3D</literal> can
        be found <ulink url="http://www.spiderland.org/documentation/classes/Matrix3D.html">here</ulink>.
      </para>
</section>
<section id="node-2830">
<title>MatrixImage</title>
<para> Full API
        documentation for the class <literal>MatrixImage</literal>
        can be found <ulink url="http://www.spiderland.org/documentation/classes/MatrixImage.html">here</ulink>.
      </para>
</section>
<section id="node-2831">
<title>MenuItem</title>
<para> Full API
        documentation for the class <literal>MenuItem</literal> can
        be found <ulink url="http://www.spiderland.org/documentation/classes/MenuItem.html">here</ulink>.
      </para>
</section>
<section id="node-2832">
<title>MeshShape</title>
<para> Full API
        documentation for the class <literal>MeshShape</literal> can
        be found <ulink url="http://www.spiderland.org/documentation/classes/MeshShape.html">here</ulink>.
      </para>
</section>
<section id="node-2834">
<title>Movie</title>
<para> Full API
        documentation for the class <literal>Movie</literal> can be
        found <ulink url="http://www.spiderland.org/documentation/classes/Movie.html">here</ulink>.
      </para>
</section>
<section id="node-2835">
<title>MultiBody</title>
<para> Full API
        documentation for the class <literal>MultiBody</literal> can
        be found <ulink url="http://www.spiderland.org/documentation/classes/MultiBody.html">here</ulink>.
      </para>
</section>
<section id="node-2836">
<title>NetworkServer</title>
<para> Full API
        documentation for the class <literal>NetworkServer</literal>
        can be found <ulink url="http://www.spiderland.org/documentation/classes/NetworkServer.html">here</ulink>.
      </para>
</section>
<section id="node-2837">
<title>NeuralNetwork</title>
<para> Full API
        documentation for the class <literal>NeuralNetwork</literal>
        can be found <ulink url="http://www.spiderland.org/documentation/classes/NeuralNetwork.html">here</ulink>.
      </para>
</section>
<section id="node-2838">
<title>Object</title>
<para> Full API
        documentation for the class <literal>Object</literal> can be
        found <ulink url="http://www.spiderland.org/documentation/classes/Object.html">here</ulink>.
      </para>
</section>
<section id="node-2839">
<title>Patch</title>
<para> Full API
        documentation for the class <literal>Patch</literal> can be
        found <ulink url="http://www.spiderland.org/documentation/classes/Patch.html">here</ulink>.
      </para>
</section>
<section id="node-2840">
<title>PatchGrid</title>
<para> Full API
        documentation for the class <literal>PatchGrid</literal> can
        be found <ulink url="http://www.spiderland.org/documentation/classes/PatchGrid.html">here</ulink>.
      </para>
</section>
<section id="node-2841">
<title>PatchToroid</title>
<para> Full API
        documentation for the class <literal>PatchToroid</literal>
        can be found <ulink url="http://www.spiderland.org/documentation/classes/PatchToroid.html">here</ulink>.
      </para>
</section>
<section id="node-2842">
<title>PhysicalControl</title>
<para> Full API
        documentation for the class <literal>PhysicalControl</literal> can be found <ulink url="http://www.spiderland.org/documentation/classes/PhysicalControl.html">here</ulink>.
      </para>
</section>
<section id="node-2843">
<title>PolygonCone</title>
<para> Full API
        documentation for the class <literal>PolygonCone</literal>
        can be found <ulink url="http://www.spiderland.org/documentation/classes/PolygonCone.html">here</ulink>.
      </para>
</section>
<section id="node-2844">
<title>PolygonDisk</title>
<para> Full API
        documentation for the class <literal>PolygonDisk</literal>
        can be found <ulink url="http://www.spiderland.org/documentation/classes/PolygonDisk.html">here</ulink>.
      </para>
</section>
<section id="node-2845">
<title>PrismaticJoint</title>
<para> Full API
        documentation for the class <literal>PrismaticJoint</literal> can be found <ulink url="http://www.spiderland.org/documentation/classes/PrismaticJoint.html">here</ulink>.
      </para>
</section>
<section id="node-2846">
<title>PushClusterGP</title>
<para> Full API
        documentation for the class <literal>PushClusterGP</literal>
        can be found <ulink url="http://www.spiderland.org/documentation/classes/PushClusterGP.html">here</ulink>.
      </para>
</section>
<section id="node-2847">
<title>PushDiversityPool</title>
<para> Full API
        documentation for the class <literal>PushDiversityPool</literal> can be found <ulink url="http://www.spiderland.org/documentation/classes/PushDiversityPool.html">here</ulink>.
      </para>
</section>
<section id="node-2848">
<title>PushGP</title>
<para> Full API
        documentation for the class <literal>PushGP</literal> can be
        found <ulink url="http://www.spiderland.org/documentation/classes/PushGP.html">here</ulink>.
      </para>
</section>
<section id="node-2849">
<title>PushGPIndividual</title>
<para> Full API
        documentation for the class <literal>PushGPIndividual</literal> can be found <ulink url="http://www.spiderland.org/documentation/classes/PushGPIndividual.html">here</ulink>.
      </para>
</section>
<section id="node-2850">
<title>PushInterpreter</title>
<para> Full API
        documentation for the class <literal>PushInterpreter</literal> can be found <ulink url="http://www.spiderland.org/documentation/classes/PushInterpreter.html">here</ulink>.
      </para>
</section>
<section id="node-2851">
<title>PushProgram</title>
<para> Full API
        documentation for the class <literal>PushProgram</literal>
        can be found <ulink url="http://www.spiderland.org/documentation/classes/PushProgram.html">here</ulink>.
      </para>
</section>
<section id="node-2852">
<title>PushProgramTransporter</title>
<para> Full API
        documentation for the class <literal>PushProgramTransporter</literal> can be found <ulink url="http://www.spiderland.org/documentation/classes/PushProgramTransporter.html">here</ulink>.
      </para>
</section>
<section id="node-2853">
<title>QProgram</title>
<para> Full API
        documentation for the class <literal>QProgram</literal> can
        be found <ulink url="http://www.spiderland.org/documentation/classes/QProgram.html">here</ulink>.
      </para>
</section>
<section id="node-2854">
<title>QSystem</title>
<para> Full API
        documentation for the class <literal>QSystem</literal> can
        be found <ulink url="http://www.spiderland.org/documentation/classes/QSystem.html">here</ulink>.
      </para>
</section>
<section id="node-2855">
<title>Real</title>
<para> Full API
        documentation for the class <literal>Real</literal> can be
        found <ulink url="http://www.spiderland.org/documentation/classes/Real.html">here</ulink>.
      </para>
</section>
<section id="node-2856">
<title>RevoluteJoint</title>
<para> Full API
        documentation for the class <literal>RevoluteJoint</literal>
        can be found <ulink url="http://www.spiderland.org/documentation/classes/RevoluteJoint.html">here</ulink>.
      </para>
</section>
<section id="node-2857">
<title>Shape</title>
<para> Full API
        documentation for the class <literal>Shape</literal> can be
        found <ulink url="http://www.spiderland.org/documentation/classes/Shape.html">here</ulink>.
      </para>
</section>
<section id="node-2858">
<title>Sound</title>
<para> Full API
        documentation for the class <literal>Sound</literal> can be
        found <ulink url="http://www.spiderland.org/documentation/classes/Sound.html">here</ulink>.
      </para>
</section>
<section id="node-2859">
<title>Sphere</title>
<para> Full API
        documentation for the class <literal>Sphere</literal> can be
        found <ulink url="http://www.spiderland.org/documentation/classes/Sphere.html">here</ulink>.
      </para>
</section>
<section id="node-2860">
<title>Spring</title>
<para> Full API
        documentation for the class <literal>Spring</literal> can be
        found <ulink url="http://www.spiderland.org/documentation/classes/Spring.html">here</ulink>.
      </para>
</section>
<section id="node-2861">
<title>Stationary</title>
<para> Full API
        documentation for the class <literal>Stationary</literal>
        can be found <ulink url="http://www.spiderland.org/documentation/classes/Stationary.html">here</ulink>.
      </para>
</section>
<section id="node-2862">
<title>Terrain</title>
<para> Full API
        documentation for the class <literal>Terrain</literal> can
        be found <ulink url="http://www.spiderland.org/documentation/classes/Terrain.html">here</ulink>.
      </para>
</section>
<section id="node-2863">
<title>Tone</title>
<para> Full API
        documentation for the class <literal>Tone</literal> can be
        found <ulink url="http://www.spiderland.org/documentation/classes/Tone.html">here</ulink>.
      </para>
</section>
<section id="node-2864">
<title>Tracer</title>
<para> Full API
        documentation for the class <literal>Tracer</literal> can be
        found <ulink url="http://www.spiderland.org/documentation/classes/Tracer.html">here</ulink>.
      </para>
</section>
<section id="node-2865">
<title>TurtleDrawing</title>
<para> Full API
        documentation for the class <literal>TurtleDrawing</literal>
        can be found <ulink url="http://www.spiderland.org/documentation/classes/TurtleDrawing.html">here</ulink>.
      </para>
</section>
<section id="node-2866">
<title>UniversalJoint</title>
<para> Full API
        documentation for the class <literal>UniversalJoint</literal> can be found <ulink url="http://www.spiderland.org/documentation/classes/UniversalJoint.html">here</ulink>.
      </para>
</section>
<section id="node-2867">
<title>Vector</title>
<para> Full API
        documentation for the class <literal>Vector</literal> can be
        found <ulink url="http://www.spiderland.org/documentation/classes/Vector.html">here</ulink>.
      </para>
</section>
<section id="node-2868">
<title>VectorImage</title>
<para> Full API
        documentation for the class <literal>VectorImage</literal>
        can be found <ulink url="http://www.spiderland.org/documentation/classes/VectorImage.html">here</ulink>.
      </para>
</section>
<section id="node-2869">
<title>Wanderer</title>
<para> Full API
        documentation for the class <literal>Wanderer</literal> can
        be found <ulink url="http://www.spiderland.org/documentation/classes/Wanderer.html">here</ulink>.
      </para>
</section>
</chapter>
<chapter id="node-2870"><?dbhtml dir="docs" ?>
<title>Index</title>
<variablelist><varlistentry><term>
              !#, <para><xref linkend="node-2635"/></para></term><listitem/></varlistentry><varlistentry><term>
              #, <para><xref linkend="node-2635"/></para>, <para><xref linkend="node-2637"/></para></term><listitem/></varlistentry><varlistentry><term>
              #!, <para><xref linkend="node-2635"/></para></term><listitem/></varlistentry><varlistentry><term>
              + to, <para><xref linkend="node-2640"/></para></term><listitem/></varlistentry><varlistentry><term>
              /dev/random, <para><xref linkend="node-2679"/></para></term><listitem/></varlistentry><varlistentry><term>
              @define, <para><xref linkend="node-2697"/></para></term><listitem/></varlistentry><varlistentry><term>
              @include, <para><xref linkend="node-2695"/></para></term><listitem/></varlistentry><varlistentry><term>
              @nib_file, <para><xref linkend="node-2742"/></para></term><listitem/></varlistentry><varlistentry><term>
              @path, <para><xref linkend="node-2696"/></para></term><listitem/></varlistentry><varlistentry><term>
              @plugin, <para><xref linkend="node-2779"/></para></term><listitem/></varlistentry><varlistentry><term>
              @use , <para><xref linkend="node-2695"/></para></term><listitem/></varlistentry></variablelist><variablelist><varlistentry><term>
              Abstract class, <para><xref linkend="node-2796"/></para></term><listitem/></varlistentry><varlistentry><term>
              acceleration, <para><xref linkend="node-2701"/></para></term><listitem/></varlistentry><varlistentry><term>
              acos() function, <para><xref linkend="node-2678"/></para></term><listitem/></varlistentry><varlistentry><term>
              add-dependency (method), <para><xref linkend="node-2748"/></para></term><listitem/></varlistentry><varlistentry><term>
              add-menu (method), <para><xref linkend="node-2739"/></para></term><listitem/></varlistentry><varlistentry><term>
              add-menu-separator (method), <para><xref linkend="node-2739"/></para></term><listitem/></varlistentry><varlistentry><term>
              agents, <para><xref linkend="node-2617"/></para>, <para><xref linkend="node-2698"/></para></term><listitem/></varlistentry><varlistentry><term>
              AIFF sound files, <para><xref linkend="node-2715"/></para></term><listitem/></varlistentry><varlistentry><term>
              aka, <para><xref linkend="node-2638"/></para></term><listitem/></varlistentry><varlistentry><term>
              alias, <para><xref linkend="node-2638"/></para></term><listitem/></varlistentry><varlistentry><term>
              all expression, <para><xref linkend="node-2723"/></para></term><listitem/></varlistentry><varlistentry><term>
              angle() function, <para><xref linkend="node-2678"/></para></term><listitem/></varlistentry><varlistentry><term>
              announce method, <para><xref linkend="node-2722"/></para></term><listitem/></varlistentry><varlistentry><term>
              archive (method), <para><xref linkend="node-2748"/></para></term><listitem/></varlistentry><varlistentry><term>
              archive-as-xml (method), <para><xref linkend="node-2748"/></para></term><listitem/></varlistentry><varlistentry><term>
              archiving, <para><xref linkend="node-2747"/></para></term><listitem/></varlistentry><varlistentry><term>
              arrays, <para><xref linkend="node-2672"/></para></term><listitem/></varlistentry><varlistentry><term>
              ASCII, <para><xref linkend="node-2740"/></para></term><listitem/></varlistentry><varlistentry><term>
              asin() function, <para><xref linkend="node-2678"/></para></term><listitem/></varlistentry><varlistentry><term>
              assignment, <para><xref linkend="node-2675"/></para></term><listitem/></varlistentry><varlistentry><term>
              AT_DATA plugin constant, <para><xref linkend="node-2768"/></para></term><listitem/></varlistentry><varlistentry><term>
              AT_DOUBLE plugin constant, <para><xref linkend="node-2768"/></para></term><listitem/></varlistentry><varlistentry><term>
              AT_HASH constant, <para><xref linkend="node-2768"/></para></term><listitem/></varlistentry><varlistentry><term>
              AT_INT plugin constant, <para><xref linkend="node-2768"/></para></term><listitem/></varlistentry><varlistentry><term>
              AT_LIST constant, <para><xref linkend="node-2768"/></para></term><listitem/></varlistentry><varlistentry><term>
              AT_MATRIX plugin constant, <para><xref linkend="node-2768"/></para></term><listitem/></varlistentry><varlistentry><term>
              AT_OBJECT plugin constant, <para><xref linkend="node-2768"/></para></term><listitem/></varlistentry><varlistentry><term>
              AT_POINTER plugin constant, <para><xref linkend="node-2768"/></para></term><listitem/></varlistentry><varlistentry><term>
              AT_STRING plugin constant, <para><xref linkend="node-2768"/></para></term><listitem/></varlistentry><varlistentry><term>
              AT_VECTOR plugin constant, <para><xref linkend="node-2768"/></para></term><listitem/></varlistentry></variablelist><variablelist><varlistentry><term>
              BallJoint class, <para><xref linkend="node-2733"/></para>, <para><xref linkend="node-2797"/></para></term><listitem/></varlistentry><varlistentry><term>
              bitmapping, <para><xref linkend="node-2710"/></para></term><listitem/></varlistentry><varlistentry><term>
              BraitenbergControl class, <para><xref linkend="node-2798"/></para></term><listitem/></varlistentry><varlistentry><term>
              BraitenbergHeavyVehicle class, <para><xref linkend="node-2799"/></para></term><listitem/></varlistentry><varlistentry><term>
              BraitenbergLight class, <para><xref linkend="node-2800"/></para></term><listitem/></varlistentry><varlistentry><term>
              BraitenbergSensor class, <para><xref linkend="node-2801"/></para></term><listitem/></varlistentry><varlistentry><term>
              BraitenbergVehicle class, <para><xref linkend="node-2802"/></para></term><listitem/></varlistentry><varlistentry><term>
              BraitenbergWheel class, <para><xref linkend="node-2803"/></para></term><listitem/></varlistentry><varlistentry><term>
              BRDATA plugin macro, <para><xref linkend="node-2768"/></para></term><listitem/></varlistentry><varlistentry><term>
              brData structure, <para><xref linkend="node-2778"/></para></term><listitem/></varlistentry><varlistentry><term>
              BRDOUBLE plugin macro, <para><xref linkend="node-2768"/></para></term><listitem/></varlistentry><varlistentry><term>
              breaking joints, <para><xref linkend="node-2735"/></para></term><listitem/></varlistentry><varlistentry><term>
              BREVE_CLASS_PATH, <para><xref linkend="node-2626"/></para></term><listitem/></varlistentry><varlistentry><term>
              BRHASH plugin macro, <para><xref linkend="node-2768"/></para></term><listitem/></varlistentry><varlistentry><term>
              BRINT plugin macro, <para><xref linkend="node-2768"/></para></term><listitem/></varlistentry><varlistentry><term>
              BRLIST plugin macro, <para><xref linkend="node-2768"/></para></term><listitem/></varlistentry><varlistentry><term>
              BRMATRIX plugin macro, <para><xref linkend="node-2768"/></para></term><listitem/></varlistentry><varlistentry><term>
              BROBJECT plugin macro, <para><xref linkend="node-2768"/></para></term><listitem/></varlistentry><varlistentry><term>
              BRPOINTER plugin macro, <para><xref linkend="node-2768"/></para></term><listitem/></varlistentry><varlistentry><term>
              BRSTRING plugin macro, <para><xref linkend="node-2768"/></para></term><listitem/></varlistentry><varlistentry><term>
              BRVECTOR plugin macro, <para><xref linkend="node-2768"/></para></term><listitem/></varlistentry></variablelist><variablelist><varlistentry><term>
              Camera class, <para><xref linkend="node-2804"/></para></term><listitem/></varlistentry><varlistentry><term>
              can-respond (method), <para><xref linkend="node-2724"/></para></term><listitem/></varlistentry><varlistentry><term>
              catch-interface-id-xxx (user-defined method), <para><xref linkend="node-2742"/></para></term><listitem/></varlistentry><varlistentry><term>
              catch-key-left-down (method), <para><xref linkend="node-2740"/></para></term><listitem/></varlistentry><varlistentry><term>
              catch-key-left-up (method), <para><xref linkend="node-2740"/></para></term><listitem/></varlistentry><varlistentry><term>
              catch-key-X-down (method), <para><xref linkend="node-2740"/></para></term><listitem/></varlistentry><varlistentry><term>
              catch-key-X-up (method), <para><xref linkend="node-2740"/></para></term><listitem/></varlistentry><varlistentry><term>
              closest object, <para><xref linkend="node-2721"/></para></term><listitem/></varlistentry><varlistentry><term>
              collisions, <para><xref linkend="node-2719"/></para></term><listitem/></varlistentry><varlistentry><term>
              color, <para><xref linkend="node-2700"/></para></term><listitem/></varlistentry><varlistentry><term>
              command-line, <para><xref linkend="node-2626"/></para></term><listitem/></varlistentry><varlistentry><term>
              comments, <para><xref linkend="node-2635"/></para></term><listitem/></varlistentry><varlistentry><term>
              Control class, <para><xref linkend="node-2805"/></para></term><listitem/></varlistentry><varlistentry><term>
              control structures, <para><xref linkend="node-2685"/></para></term><listitem/></varlistentry><varlistentry><term>
              controller object, <para><xref linkend="node-2636"/></para></term><listitem/></varlistentry><varlistentry><term>
              controller variable, <para><xref linkend="node-2674"/></para></term><listitem/></varlistentry><varlistentry><term>
              cos() function, <para><xref linkend="node-2678"/></para></term><listitem/></varlistentry><varlistentry><term>
              cross() function (cross product), <para><xref linkend="node-2678"/></para></term><listitem/></varlistentry><varlistentry><term>
              Cube class, <para><xref linkend="node-2806"/></para></term><listitem/></varlistentry><varlistentry><term>
              CustomShape class, <para><xref linkend="node-2807"/></para></term><listitem/></varlistentry></variablelist><variablelist><varlistentry><term>
              data, <para><xref linkend="node-2671"/></para></term><listitem/></varlistentry><varlistentry><term>
              data archiving, <para><xref linkend="node-2778"/></para></term><listitem/></varlistentry><varlistentry><term>
              Data class, <para><xref linkend="node-2808"/></para></term><listitem/></varlistentry><varlistentry><term>
              dearchive (method), <para><xref linkend="node-2748"/></para></term><listitem/></varlistentry><varlistentry><term>
              dearchive-xml (method), <para><xref linkend="node-2748"/></para></term><listitem/></varlistentry><varlistentry><term>
              dearchiving, <para><xref linkend="node-2747"/></para></term><listitem/></varlistentry><varlistentry><term>
              define directive, <para><xref linkend="node-2697"/></para></term><listitem/></varlistentry><varlistentry><term>
              dependencies, <para><xref linkend="node-2748"/></para></term><listitem/></varlistentry><varlistentry><term>
              dependency, <para><xref linkend="node-2748"/></para></term><listitem/></varlistentry><varlistentry><term>
              destroy (special method), <para><xref linkend="node-2642"/></para></term><listitem/></varlistentry><varlistentry><term>
              dialog box, <para><xref linkend="node-2741"/></para></term><listitem/></varlistentry><varlistentry><term>
              disable-lighting method, <para><xref linkend="node-2704"/></para></term><listitem/></varlistentry><varlistentry><term>
              disable-reflections (method), <para><xref linkend="node-2706"/></para></term><listitem/></varlistentry><varlistentry><term>
              disable-shadow-volumes (method), <para><xref linkend="node-2708"/></para></term><listitem/></varlistentry><varlistentry><term>
              disable-shadows (method), <para><xref linkend="node-2707"/></para></term><listitem/></varlistentry><varlistentry><term>
              dot() function (dot product), <para><xref linkend="node-2678"/></para></term><listitem/></varlistentry><varlistentry><term>
              double (type), <para><xref linkend="node-2648"/></para></term><listitem/></varlistentry><varlistentry><term>
              dragging objects, <para><xref linkend="node-2622"/></para>, <para><xref linkend="node-2626"/></para></term><listitem/></varlistentry><varlistentry><term>
              Drawing class, <para><xref linkend="node-2809"/></para></term><listitem/></varlistentry><varlistentry><term>
              dynamic joints, <para><xref linkend="node-2735"/></para></term><listitem/></varlistentry></variablelist><variablelist><varlistentry><term>
              else, <para><xref linkend="node-2686"/></para></term><listitem/></varlistentry><varlistentry><term>
              enable-lighting method, <para><xref linkend="node-2704"/></para></term><listitem/></varlistentry><varlistentry><term>
              enable-reflections (method), <para><xref linkend="node-2706"/></para></term><listitem/></varlistentry><varlistentry><term>
              enable-shadow-volumes (method), <para><xref linkend="node-2708"/></para></term><listitem/></varlistentry><varlistentry><term>
              enable-shadows (method), <para><xref linkend="node-2707"/></para></term><listitem/></varlistentry><varlistentry><term>
              environment variables, <para><xref linkend="node-2626"/></para></term><listitem/></varlistentry><varlistentry><term>
              events, <para><xref linkend="node-2702"/></para></term><listitem/></varlistentry></variablelist><variablelist><varlistentry><term>
              FFNetwork class, <para><xref linkend="node-2810"/></para></term><listitem/></varlistentry><varlistentry><term>
              File class, <para><xref linkend="node-2811"/></para></term><listitem/></varlistentry><varlistentry><term>
              FixedJoint class, <para><xref linkend="node-2733"/></para>, <para><xref linkend="node-2812"/></para></term><listitem/></varlistentry><varlistentry><term>
              float (type), <para><xref linkend="node-2648"/></para></term><listitem/></varlistentry><varlistentry><term>
              Floor class, <para><xref linkend="node-2813"/></para></term><listitem/></varlistentry><varlistentry><term>
              for, <para><xref linkend="node-2689"/></para></term><listitem/></varlistentry><varlistentry><term>
              foreach, <para><xref linkend="node-2688"/></para></term><listitem/></varlistentry><varlistentry><term>
              fractal terrain, <para><xref linkend="node-2737"/></para></term><listitem/></varlistentry></variablelist><variablelist><varlistentry><term>
              GADirectedGraph class, <para><xref linkend="node-2814"/></para></term><listitem/></varlistentry><varlistentry><term>
              GADirectedGraphConnection class, <para><xref linkend="node-2815"/></para></term><listitem/></varlistentry><varlistentry><term>
              GADirectedGraphNode class, <para><xref linkend="node-2816"/></para></term><listitem/></varlistentry><varlistentry><term>
              GADirectedGraphParameterObject class, <para><xref linkend="node-2817"/></para></term><listitem/></varlistentry><varlistentry><term>
              GAIndividualTransporter class, <para><xref linkend="node-2818"/></para></term><listitem/></varlistentry><varlistentry><term>
              garbage collection, <para><xref linkend="node-2690"/></para></term><listitem/></varlistentry><varlistentry><term>
              Gaussian distribution, <para><xref linkend="node-2678"/></para></term><listitem/></varlistentry><varlistentry><term>
              GeneticAlgorithm class, <para><xref linkend="node-2819"/></para></term><listitem/></varlistentry><varlistentry><term>
              GeneticAlgorithmIndividual class, <para><xref linkend="node-2820"/></para></term><listitem/></varlistentry><varlistentry><term>
              Genome class, <para><xref linkend="node-2821"/></para></term><listitem/></varlistentry><varlistentry><term>
              get-neighbors (method), <para><xref linkend="node-2720"/></para></term><listitem/></varlistentry><varlistentry><term>
              get-time (method), <para><xref linkend="node-2702"/></para></term><listitem/></varlistentry><varlistentry><term>
              global constants, <para><xref linkend="node-2697"/></para></term><listitem/></varlistentry><varlistentry><term>
              Graph class, <para><xref linkend="node-2822"/></para></term><listitem/></varlistentry><varlistentry><term>
              graphics, <para><xref linkend="node-2703"/></para></term><listitem/></varlistentry><varlistentry><term>
              GUI, <para><xref linkend="node-2738"/></para></term><listitem/></varlistentry></variablelist><variablelist><varlistentry><term>
              handle-collisions (method), <para><xref linkend="node-2719"/></para></term><listitem/></varlistentry><varlistentry><term>
              hash (type), <para><xref linkend="node-2666"/></para></term><listitem/></varlistentry><varlistentry><term>
              Hello, World!, <para><xref linkend="node-2633"/></para></term><listitem/></varlistentry><varlistentry><term>
              hexadecimal, <para><xref linkend="node-2740"/></para></term><listitem/></varlistentry><varlistentry><term>
              HTML, <para><xref linkend="node-2753"/></para></term><listitem/></varlistentry></variablelist><variablelist><varlistentry><term>
              if, <para><xref linkend="node-2686"/></para></term><listitem/></varlistentry><varlistentry><term>
              Image class, <para><xref linkend="node-2823"/></para></term><listitem/></varlistentry><varlistentry><term>
              include directive, <para><xref linkend="node-2695"/></para></term><listitem/></varlistentry><varlistentry><term>
              infinity, <para><xref linkend="node-2678"/></para></term><listitem/></varlistentry><varlistentry><term>
              init (special method), <para><xref linkend="node-2642"/></para></term><listitem/></varlistentry><varlistentry><term>
              instance, <para><xref linkend="node-2637"/></para></term><listitem/></varlistentry><varlistentry><term>
              instance variable, <para><xref linkend="node-2639"/></para>, <para><xref linkend="node-2641"/></para></term><listitem/></varlistentry><varlistentry><term>
              int (type), <para><xref linkend="node-2645"/></para></term><listitem/></varlistentry><varlistentry><term>
              Interface Builder, <para><xref linkend="node-2742"/></para></term><listitem/></varlistentry><varlistentry><term>
              internal function calls, <para><xref linkend="node-2684"/></para></term><listitem/></varlistentry><varlistentry><term>
              is (method), <para><xref linkend="node-2725"/></para></term><listitem/></varlistentry><varlistentry><term>
              isinf() function, <para><xref linkend="node-2678"/></para></term><listitem/></varlistentry><varlistentry><term>
              isnan() function, <para><xref linkend="node-2678"/></para></term><listitem/></varlistentry><varlistentry><term>
              iterate (special method), <para><xref linkend="node-2642"/></para></term><listitem/></varlistentry></variablelist><variablelist><varlistentry><term>
              Joint class, <para><xref linkend="node-2733"/></para>, <para><xref linkend="node-2824"/></para></term><listitem/></varlistentry><varlistentry><term>
              JPEG image files, <para><xref linkend="node-2709"/></para></term><listitem/></varlistentry></variablelist><variablelist><varlistentry><term>
              keyboard events, <para><xref linkend="node-2740"/></para></term><listitem/></varlistentry><varlistentry><term>
              keyword, <para><xref linkend="node-2640"/></para></term><listitem/></varlistentry></variablelist><variablelist><varlistentry><term>
              lighting, <para><xref linkend="node-2704"/></para></term><listitem><para><variablelist><varlistentry><term>
                  copylist, <para><xref linkend="node-2661"/></para></term><listitem/></varlistentry><varlistentry><term>
                  insert, <para><xref linkend="node-2661"/></para></term><listitem/></varlistentry><varlistentry><term>
                  length, <para><xref linkend="node-2661"/></para></term><listitem/></varlistentry><varlistentry><term>
                  pop, <para><xref linkend="node-2661"/></para></term><listitem/></varlistentry><varlistentry><term>
                  prepend, <para><xref linkend="node-2661"/></para></term><listitem/></varlistentry><varlistentry><term>
                  push, <para><xref linkend="node-2661"/></para></term><listitem/></varlistentry><varlistentry><term>
                  remove, <para><xref linkend="node-2661"/></para></term><listitem/></varlistentry><varlistentry><term>
                  sort, <para><xref linkend="node-2661"/></para></term><listitem/></varlistentry><varlistentry><term>
                  unprepend, <para><xref linkend="node-2661"/></para></term><listitem/></varlistentry></variablelist></para></listitem></varlistentry><varlistentry><term>
              lightmapping, <para><xref linkend="node-2712"/></para></term><listitem><para><variablelist><varlistentry><term>
                  copylist, <para><xref linkend="node-2661"/></para></term><listitem/></varlistentry><varlistentry><term>
                  insert, <para><xref linkend="node-2661"/></para></term><listitem/></varlistentry><varlistentry><term>
                  length, <para><xref linkend="node-2661"/></para></term><listitem/></varlistentry><varlistentry><term>
                  pop, <para><xref linkend="node-2661"/></para></term><listitem/></varlistentry><varlistentry><term>
                  prepend, <para><xref linkend="node-2661"/></para></term><listitem/></varlistentry><varlistentry><term>
                  push, <para><xref linkend="node-2661"/></para></term><listitem/></varlistentry><varlistentry><term>
                  remove, <para><xref linkend="node-2661"/></para></term><listitem/></varlistentry><varlistentry><term>
                  sort, <para><xref linkend="node-2661"/></para></term><listitem/></varlistentry><varlistentry><term>
                  unprepend, <para><xref linkend="node-2661"/></para></term><listitem/></varlistentry></variablelist></para></listitem></varlistentry><varlistentry><term>
              Line class, <para><xref linkend="node-2825"/></para></term><listitem><para><variablelist><varlistentry><term>
                  copylist, <para><xref linkend="node-2661"/></para></term><listitem/></varlistentry><varlistentry><term>
                  insert, <para><xref linkend="node-2661"/></para></term><listitem/></varlistentry><varlistentry><term>
                  length, <para><xref linkend="node-2661"/></para></term><listitem/></varlistentry><varlistentry><term>
                  pop, <para><xref linkend="node-2661"/></para></term><listitem/></varlistentry><varlistentry><term>
                  prepend, <para><xref linkend="node-2661"/></para></term><listitem/></varlistentry><varlistentry><term>
                  push, <para><xref linkend="node-2661"/></para></term><listitem/></varlistentry><varlistentry><term>
                  remove, <para><xref linkend="node-2661"/></para></term><listitem/></varlistentry><varlistentry><term>
                  sort, <para><xref linkend="node-2661"/></para></term><listitem/></varlistentry><varlistentry><term>
                  unprepend, <para><xref linkend="node-2661"/></para></term><listitem/></varlistentry></variablelist></para></listitem></varlistentry><varlistentry><term>
              Link (class), <para><xref linkend="node-2698"/></para></term><listitem><para><variablelist><varlistentry><term>
                  copylist, <para><xref linkend="node-2661"/></para></term><listitem/></varlistentry><varlistentry><term>
                  insert, <para><xref linkend="node-2661"/></para></term><listitem/></varlistentry><varlistentry><term>
                  length, <para><xref linkend="node-2661"/></para></term><listitem/></varlistentry><varlistentry><term>
                  pop, <para><xref linkend="node-2661"/></para></term><listitem/></varlistentry><varlistentry><term>
                  prepend, <para><xref linkend="node-2661"/></para></term><listitem/></varlistentry><varlistentry><term>
                  push, <para><xref linkend="node-2661"/></para></term><listitem/></varlistentry><varlistentry><term>
                  remove, <para><xref linkend="node-2661"/></para></term><listitem/></varlistentry><varlistentry><term>
                  sort, <para><xref linkend="node-2661"/></para></term><listitem/></varlistentry><varlistentry><term>
                  unprepend, <para><xref linkend="node-2661"/></para></term><listitem/></varlistentry></variablelist></para></listitem></varlistentry><varlistentry><term>
              Link class, <para><xref linkend="node-2732"/></para>, <para><xref linkend="node-2826"/></para></term><listitem><para><variablelist><varlistentry><term>
                  copylist, <para><xref linkend="node-2661"/></para></term><listitem/></varlistentry><varlistentry><term>
                  insert, <para><xref linkend="node-2661"/></para></term><listitem/></varlistentry><varlistentry><term>
                  length, <para><xref linkend="node-2661"/></para></term><listitem/></varlistentry><varlistentry><term>
                  pop, <para><xref linkend="node-2661"/></para></term><listitem/></varlistentry><varlistentry><term>
                  prepend, <para><xref linkend="node-2661"/></para></term><listitem/></varlistentry><varlistentry><term>
                  push, <para><xref linkend="node-2661"/></para></term><listitem/></varlistentry><varlistentry><term>
                  remove, <para><xref linkend="node-2661"/></para></term><listitem/></varlistentry><varlistentry><term>
                  sort, <para><xref linkend="node-2661"/></para></term><listitem/></varlistentry><varlistentry><term>
                  unprepend, <para><xref linkend="node-2661"/></para></term><listitem/></varlistentry></variablelist></para></listitem></varlistentry><varlistentry><term>
              Linux, <para><xref linkend="node-2626"/></para>, <para><xref linkend="node-2776"/></para></term><listitem><para><variablelist><varlistentry><term>
                  copylist, <para><xref linkend="node-2661"/></para></term><listitem/></varlistentry><varlistentry><term>
                  insert, <para><xref linkend="node-2661"/></para></term><listitem/></varlistentry><varlistentry><term>
                  length, <para><xref linkend="node-2661"/></para></term><listitem/></varlistentry><varlistentry><term>
                  pop, <para><xref linkend="node-2661"/></para></term><listitem/></varlistentry><varlistentry><term>
                  prepend, <para><xref linkend="node-2661"/></para></term><listitem/></varlistentry><varlistentry><term>
                  push, <para><xref linkend="node-2661"/></para></term><listitem/></varlistentry><varlistentry><term>
                  remove, <para><xref linkend="node-2661"/></para></term><listitem/></varlistentry><varlistentry><term>
                  sort, <para><xref linkend="node-2661"/></para></term><listitem/></varlistentry><varlistentry><term>
                  unprepend, <para><xref linkend="node-2661"/></para></term><listitem/></varlistentry></variablelist></para></listitem></varlistentry><varlistentry><term>
              list (type), <para><xref linkend="node-2660"/></para></term><listitem><para><variablelist><varlistentry><term>
                  copylist, <para><xref linkend="node-2661"/></para></term><listitem/></varlistentry><varlistentry><term>
                  insert, <para><xref linkend="node-2661"/></para></term><listitem/></varlistentry><varlistentry><term>
                  length, <para><xref linkend="node-2661"/></para></term><listitem/></varlistentry><varlistentry><term>
                  pop, <para><xref linkend="node-2661"/></para></term><listitem/></varlistentry><varlistentry><term>
                  prepend, <para><xref linkend="node-2661"/></para></term><listitem/></varlistentry><varlistentry><term>
                  push, <para><xref linkend="node-2661"/></para></term><listitem/></varlistentry><varlistentry><term>
                  remove, <para><xref linkend="node-2661"/></para></term><listitem/></varlistentry><varlistentry><term>
                  sort, <para><xref linkend="node-2661"/></para></term><listitem/></varlistentry><varlistentry><term>
                  unprepend, <para><xref linkend="node-2661"/></para></term><listitem/></varlistentry></variablelist></para></listitem></varlistentry><varlistentry><term>
              list operators
            </term><listitem><para><variablelist><varlistentry><term>
                  copylist, <para><xref linkend="node-2661"/></para></term><listitem/></varlistentry><varlistentry><term>
                  insert, <para><xref linkend="node-2661"/></para></term><listitem/></varlistentry><varlistentry><term>
                  length, <para><xref linkend="node-2661"/></para></term><listitem/></varlistentry><varlistentry><term>
                  pop, <para><xref linkend="node-2661"/></para></term><listitem/></varlistentry><varlistentry><term>
                  prepend, <para><xref linkend="node-2661"/></para></term><listitem/></varlistentry><varlistentry><term>
                  push, <para><xref linkend="node-2661"/></para></term><listitem/></varlistentry><varlistentry><term>
                  remove, <para><xref linkend="node-2661"/></para></term><listitem/></varlistentry><varlistentry><term>
                  sort, <para><xref linkend="node-2661"/></para></term><listitem/></varlistentry><varlistentry><term>
                  unprepend, <para><xref linkend="node-2661"/></para></term><listitem/></varlistentry></variablelist></para></listitem></varlistentry><varlistentry><term>
              location, <para><xref linkend="node-2701"/></para></term><listitem/></varlistentry><varlistentry><term>
              log() function, <para><xref linkend="node-2678"/></para></term><listitem/></varlistentry></variablelist><variablelist><varlistentry><term>
              Mac OS X, <para><xref linkend="node-2620"/></para>, <para><xref linkend="node-2626"/></para>,
              <para><xref linkend="node-2742"/></para>, <para><xref linkend="node-2775"/></para></term><listitem><para><variablelist><varlistentry><term>
                  add-assign (+=), <para><xref linkend="node-2677"/></para></term><listitem/></varlistentry><varlistentry><term>
                  decrement (--), <para><xref linkend="node-2677"/></para></term><listitem/></varlistentry><varlistentry><term>
                  divide-assign (/=), <para><xref linkend="node-2677"/></para></term><listitem/></varlistentry><varlistentry><term>
                  increment (++), <para><xref linkend="node-2677"/></para></term><listitem/></varlistentry><varlistentry><term>
                  modulus-assign (%=), <para><xref linkend="node-2677"/></para></term><listitem/></varlistentry><varlistentry><term>
                  multiply-assign (*=), <para><xref linkend="node-2677"/></para></term><listitem/></varlistentry><varlistentry><term>
                  power-assign (^=), <para><xref linkend="node-2677"/></para></term><listitem/></varlistentry><varlistentry><term>
                  subtract-assign (-=), <para><xref linkend="node-2677"/></para></term><listitem/></varlistentry></variablelist></para></listitem></varlistentry><varlistentry><term>
              mathematical assignment operators
            </term><listitem><para><variablelist><varlistentry><term>
                  add-assign (+=), <para><xref linkend="node-2677"/></para></term><listitem/></varlistentry><varlistentry><term>
                  decrement (--), <para><xref linkend="node-2677"/></para></term><listitem/></varlistentry><varlistentry><term>
                  divide-assign (/=), <para><xref linkend="node-2677"/></para></term><listitem/></varlistentry><varlistentry><term>
                  increment (++), <para><xref linkend="node-2677"/></para></term><listitem/></varlistentry><varlistentry><term>
                  modulus-assign (%=), <para><xref linkend="node-2677"/></para></term><listitem/></varlistentry><varlistentry><term>
                  multiply-assign (*=), <para><xref linkend="node-2677"/></para></term><listitem/></varlistentry><varlistentry><term>
                  power-assign (^=), <para><xref linkend="node-2677"/></para></term><listitem/></varlistentry><varlistentry><term>
                  subtract-assign (-=), <para><xref linkend="node-2677"/></para></term><listitem/></varlistentry></variablelist></para></listitem></varlistentry><varlistentry><term>
              mathematical functions, <para><xref linkend="node-2678"/></para></term><listitem><para><variablelist><varlistentry><term>
                  addition (+), <para><xref linkend="node-2676"/></para></term><listitem/></varlistentry><varlistentry><term>
                  division (/), <para><xref linkend="node-2676"/></para></term><listitem/></varlistentry><varlistentry><term>
                  modulus (%), <para><xref linkend="node-2676"/></para></term><listitem/></varlistentry><varlistentry><term>
                  multiplication (*), <para><xref linkend="node-2676"/></para></term><listitem/></varlistentry><varlistentry><term>
                  power (^), <para><xref linkend="node-2676"/></para></term><listitem/></varlistentry><varlistentry><term>
                  subtraction (-), <para><xref linkend="node-2676"/></para></term><listitem/></varlistentry></variablelist></para></listitem></varlistentry><varlistentry><term>
              mathematical operators
            </term><listitem><para><variablelist><varlistentry><term>
                  addition (+), <para><xref linkend="node-2676"/></para></term><listitem/></varlistentry><varlistentry><term>
                  division (/), <para><xref linkend="node-2676"/></para></term><listitem/></varlistentry><varlistentry><term>
                  modulus (%), <para><xref linkend="node-2676"/></para></term><listitem/></varlistentry><varlistentry><term>
                  multiplication (*), <para><xref linkend="node-2676"/></para></term><listitem/></varlistentry><varlistentry><term>
                  power (^), <para><xref linkend="node-2676"/></para></term><listitem/></varlistentry><varlistentry><term>
                  subtraction (-), <para><xref linkend="node-2676"/></para></term><listitem/></varlistentry></variablelist></para></listitem></varlistentry><varlistentry><term>
              matrix (type), <para><xref linkend="node-2657"/></para></term><listitem/></varlistentry><varlistentry><term>
              Matrix class, <para><xref linkend="node-2827"/></para></term><listitem/></varlistentry><varlistentry><term>
              Matrix2D class, <para><xref linkend="node-2828"/></para></term><listitem/></varlistentry><varlistentry><term>
              Matrix3D class, <para><xref linkend="node-2829"/></para></term><listitem/></varlistentry><varlistentry><term>
              MatrixImage class, <para><xref linkend="node-2830"/></para></term><listitem/></varlistentry><varlistentry><term>
              max() function, <para><xref linkend="node-2678"/></para></term><listitem/></varlistentry><varlistentry><term>
              memory management, <para><xref linkend="node-2690"/></para></term><listitem/></varlistentry><varlistentry><term>
              MenuItem class, <para><xref linkend="node-2831"/></para></term><listitem/></varlistentry><varlistentry><term>
              MeshShape class, <para><xref linkend="node-2832"/></para></term><listitem/></varlistentry><varlistentry><term>
              method calls, <para><xref linkend="node-2680"/></para></term><listitem/></varlistentry><varlistentry><term>
              method definition, <para><xref linkend="node-2640"/></para></term><listitem/></varlistentry><varlistentry><term>
              min() function, <para><xref linkend="node-2678"/></para></term><listitem/></varlistentry><varlistentry><term>
              Mobile (class), <para><xref linkend="node-2698"/></para></term><listitem/></varlistentry><varlistentry><term>
              Mobile class, <para><xref linkend="node-2833"/></para></term><listitem/></varlistentry><varlistentry><term>
              move (method), <para><xref linkend="node-2701"/></para></term><listitem/></varlistentry><varlistentry><term>
              move-light method, <para><xref linkend="node-2704"/></para></term><listitem/></varlistentry><varlistentry><term>
              Movie class, <para><xref linkend="node-2744"/></para>, <para><xref linkend="node-2834"/></para></term><listitem/></varlistentry><varlistentry><term>
              movie export, <para><xref linkend="node-2744"/></para></term><listitem/></varlistentry><varlistentry><term>
              MPEG export, <para><xref linkend="node-2744"/></para></term><listitem/></varlistentry><varlistentry><term>
              multi-agent simulation, <para><xref linkend="node-2617"/></para></term><listitem/></varlistentry><varlistentry><term>
              MultiBody class, <para><xref linkend="node-2734"/></para>, <para><xref linkend="node-2835"/></para></term><listitem/></varlistentry></variablelist><variablelist><varlistentry><term>
              NaN (not-a-number), <para><xref linkend="node-2678"/></para></term><listitem/></varlistentry><varlistentry><term>
              neighbor detection, <para><xref linkend="node-2720"/></para></term><listitem/></varlistentry><varlistentry><term>
              networking, <para><xref linkend="node-2753"/></para></term><listitem/></varlistentry><varlistentry><term>
              NetworkServer class, <para><xref linkend="node-2836"/></para></term><listitem/></varlistentry><varlistentry><term>
              NeuralNetwork class, <para><xref linkend="node-2837"/></para></term><listitem/></varlistentry><varlistentry><term>
              nib files, <para><xref linkend="node-2742"/></para>, <para><xref linkend="node-2743"/></para></term><listitem/></varlistentry><varlistentry><term>
              notifications, <para><xref linkend="node-2722"/></para></term><listitem/></varlistentry></variablelist><variablelist><varlistentry><term>
              object (type), <para><xref linkend="node-2651"/></para></term><listitem><para><variablelist><varlistentry><term>
                  assignment (=), <para><xref linkend="node-2675"/></para></term><listitem/></varlistentry><varlistentry><term>
                  list, <para><xref linkend="node-2661"/></para></term><listitem/></varlistentry><varlistentry><term>
                  mathematical, <para><xref linkend="node-2676"/></para></term><listitem/></varlistentry><varlistentry><term>
                  mathematical assignment operators, <para><xref linkend="node-2677"/></para></term><listitem/></varlistentry></variablelist></para></listitem></varlistentry><varlistentry><term>
              object archiving, <para><xref linkend="node-2748"/></para></term><listitem><para><variablelist><varlistentry><term>
                  assignment (=), <para><xref linkend="node-2675"/></para></term><listitem/></varlistentry><varlistentry><term>
                  list, <para><xref linkend="node-2661"/></para></term><listitem/></varlistentry><varlistentry><term>
                  mathematical, <para><xref linkend="node-2676"/></para></term><listitem/></varlistentry><varlistentry><term>
                  mathematical assignment operators, <para><xref linkend="node-2677"/></para></term><listitem/></varlistentry></variablelist></para></listitem></varlistentry><varlistentry><term>
              Object class, <para><xref linkend="node-2838"/></para></term><listitem><para><variablelist><varlistentry><term>
                  assignment (=), <para><xref linkend="node-2675"/></para></term><listitem/></varlistentry><varlistentry><term>
                  list, <para><xref linkend="node-2661"/></para></term><listitem/></varlistentry><varlistentry><term>
                  mathematical, <para><xref linkend="node-2676"/></para></term><listitem/></varlistentry><varlistentry><term>
                  mathematical assignment operators, <para><xref linkend="node-2677"/></para></term><listitem/></varlistentry></variablelist></para></listitem></varlistentry><varlistentry><term>
              object dearchiving, <para><xref linkend="node-2748"/></para></term><listitem><para><variablelist><varlistentry><term>
                  assignment (=), <para><xref linkend="node-2675"/></para></term><listitem/></varlistentry><varlistentry><term>
                  list, <para><xref linkend="node-2661"/></para></term><listitem/></varlistentry><varlistentry><term>
                  mathematical, <para><xref linkend="node-2676"/></para></term><listitem/></varlistentry><varlistentry><term>
                  mathematical assignment operators, <para><xref linkend="node-2677"/></para></term><listitem/></varlistentry></variablelist></para></listitem></varlistentry><varlistentry><term>
              object-oriented programming, <para><xref linkend="node-2632"/></para></term><listitem><para><variablelist><varlistentry><term>
                  assignment (=), <para><xref linkend="node-2675"/></para></term><listitem/></varlistentry><varlistentry><term>
                  list, <para><xref linkend="node-2661"/></para></term><listitem/></varlistentry><varlistentry><term>
                  mathematical, <para><xref linkend="node-2676"/></para></term><listitem/></varlistentry><varlistentry><term>
                  mathematical assignment operators, <para><xref linkend="node-2677"/></para></term><listitem/></varlistentry></variablelist></para></listitem></varlistentry><varlistentry><term>
              observe method, <para><xref linkend="node-2722"/></para></term><listitem><para><variablelist><varlistentry><term>
                  assignment (=), <para><xref linkend="node-2675"/></para></term><listitem/></varlistentry><varlistentry><term>
                  list, <para><xref linkend="node-2661"/></para></term><listitem/></varlistentry><varlistentry><term>
                  mathematical, <para><xref linkend="node-2676"/></para></term><listitem/></varlistentry><varlistentry><term>
                  mathematical assignment operators, <para><xref linkend="node-2677"/></para></term><listitem/></varlistentry></variablelist></para></listitem></varlistentry><varlistentry><term>
              Open Dynamics Engine (ODE), <para><xref linkend="node-2726"/></para></term><listitem><para><variablelist><varlistentry><term>
                  assignment (=), <para><xref linkend="node-2675"/></para></term><listitem/></varlistentry><varlistentry><term>
                  list, <para><xref linkend="node-2661"/></para></term><listitem/></varlistentry><varlistentry><term>
                  mathematical, <para><xref linkend="node-2676"/></para></term><listitem/></varlistentry><varlistentry><term>
                  mathematical assignment operators, <para><xref linkend="node-2677"/></para></term><listitem/></varlistentry></variablelist></para></listitem></varlistentry><varlistentry><term>
              operators
            </term><listitem><para><variablelist><varlistentry><term>
                  assignment (=), <para><xref linkend="node-2675"/></para></term><listitem/></varlistentry><varlistentry><term>
                  list, <para><xref linkend="node-2661"/></para></term><listitem/></varlistentry><varlistentry><term>
                  mathematical, <para><xref linkend="node-2676"/></para></term><listitem/></varlistentry><varlistentry><term>
                  mathematical assignment operators, <para><xref linkend="node-2677"/></para></term><listitem/></varlistentry></variablelist></para></listitem></varlistentry><varlistentry><term>
              orphaned link, <para><xref linkend="node-2732"/></para></term><listitem/></varlistentry></variablelist><variablelist><varlistentry><term>
              Patch class, <para><xref linkend="node-2839"/></para></term><listitem/></varlistentry><varlistentry><term>
              PatchGrid class, <para><xref linkend="node-2840"/></para></term><listitem/></varlistentry><varlistentry><term>
              PatchToroid class, <para><xref linkend="node-2841"/></para></term><listitem/></varlistentry><varlistentry><term>
              path directive, <para><xref linkend="node-2696"/></para></term><listitem/></varlistentry><varlistentry><term>
              physical simulation, <para><xref linkend="node-2726"/></para></term><listitem/></varlistentry><varlistentry><term>
              PhysicalControl class, <para><xref linkend="node-2842"/></para></term><listitem/></varlistentry><varlistentry><term>
              physics, <para><xref linkend="node-2619"/></para>, <para><xref linkend="node-2726"/></para></term><listitem/></varlistentry><varlistentry><term>
              plugins, <para><xref linkend="node-2765"/></para></term><listitem/></varlistentry><varlistentry><term>
              PNG export, <para><xref linkend="node-2744"/></para></term><listitem/></varlistentry><varlistentry><term>
              PNG image files, <para><xref linkend="node-2709"/></para></term><listitem/></varlistentry><varlistentry><term>
              pointer (type), <para><xref linkend="node-2669"/></para></term><listitem/></varlistentry><varlistentry><term>
              PolygonCone class, <para><xref linkend="node-2843"/></para></term><listitem/></varlistentry><varlistentry><term>
              PolygonDisk class, <para><xref linkend="node-2844"/></para></term><listitem/></varlistentry><varlistentry><term>
              post-iterate (special method), <para><xref linkend="node-2642"/></para></term><listitem/></varlistentry><varlistentry><term>
              print, <para><xref linkend="node-2682"/></para></term><listitem/></varlistentry><varlistentry><term>
              printf, <para><xref linkend="node-2682"/></para></term><listitem/></varlistentry><varlistentry><term>
              PrismaticJoint class, <para><xref linkend="node-2733"/></para>, <para><xref linkend="node-2845"/></para></term><listitem/></varlistentry><varlistentry><term>
              pseudo-physics, <para><xref linkend="node-2727"/></para></term><listitem/></varlistentry><varlistentry><term>
              PushClusterGP class, <para><xref linkend="node-2846"/></para></term><listitem/></varlistentry><varlistentry><term>
              PushDiversityPool class, <para><xref linkend="node-2847"/></para></term><listitem/></varlistentry><varlistentry><term>
              PushGP class, <para><xref linkend="node-2848"/></para></term><listitem/></varlistentry><varlistentry><term>
              PushGPIndividual class, <para><xref linkend="node-2849"/></para></term><listitem/></varlistentry><varlistentry><term>
              PushInterpreter class, <para><xref linkend="node-2850"/></para></term><listitem/></varlistentry><varlistentry><term>
              PushProgram class, <para><xref linkend="node-2851"/></para></term><listitem/></varlistentry><varlistentry><term>
              PushProgramTransporter class, <para><xref linkend="node-2852"/></para></term><listitem/></varlistentry></variablelist><variablelist><varlistentry><term>
              QProgram class, <para><xref linkend="node-2853"/></para></term><listitem/></varlistentry><varlistentry><term>
              QSystem class, <para><xref linkend="node-2854"/></para></term><listitem/></varlistentry></variablelist><variablelist><varlistentry><term>
              random numbers, <para><xref linkend="node-2679"/></para></term><listitem/></varlistentry><varlistentry><term>
              randomGauss() function, <para><xref linkend="node-2678"/></para></term><listitem/></varlistentry><varlistentry><term>
              Real (class), <para><xref linkend="node-2698"/></para></term><listitem/></varlistentry><varlistentry><term>
              Real class, <para><xref linkend="node-2855"/></para></term><listitem/></varlistentry><varlistentry><term>
              reflections, <para><xref linkend="node-2705"/></para></term><listitem/></varlistentry><varlistentry><term>
              RevoluteJoint class, <para><xref linkend="node-2733"/></para>, <para><xref linkend="node-2856"/></para></term><listitem/></varlistentry><varlistentry><term>
              rotate-tool, <para><xref linkend="node-2622"/></para>, <para><xref linkend="node-2626"/></para></term><listitem/></varlistentry></variablelist><variablelist><varlistentry><term>
              save-as-xml (method), <para><xref linkend="node-2752"/></para></term><listitem/></varlistentry><varlistentry><term>
              save-snapshot, <para><xref linkend="node-2744"/></para></term><listitem/></varlistentry><varlistentry><term>
              schedule (method), <para><xref linkend="node-2702"/></para></term><listitem/></varlistentry><varlistentry><term>
              search path, <para><xref linkend="node-2696"/></para></term><listitem/></varlistentry><varlistentry><term>
              selection-tool, <para><xref linkend="node-2622"/></para>, <para><xref linkend="node-2626"/></para></term><listitem/></varlistentry><varlistentry><term>
              self, <para><xref linkend="node-2674"/></para></term><listitem/></varlistentry><varlistentry><term>
              sending objects, <para><xref linkend="node-2753"/></para></term><listitem/></varlistentry><varlistentry><term>
              set-acceleration (method), <para><xref linkend="node-2701"/></para></term><listitem/></varlistentry><varlistentry><term>
              set-bitmap-image Method, <para><xref linkend="node-2710"/></para></term><listitem/></varlistentry><varlistentry><term>
              set-color (method), <para><xref linkend="node-2700"/></para></term><listitem/></varlistentry><varlistentry><term>
              set-interface-item (method), <para><xref linkend="node-2742"/></para></term><listitem/></varlistentry><varlistentry><term>
              set-neighborhood-size (method), <para><xref linkend="node-2720"/></para></term><listitem/></varlistentry><varlistentry><term>
              set-velocity (method), <para><xref linkend="node-2701"/></para></term><listitem/></varlistentry><varlistentry><term>
              SGI image files, <para><xref linkend="node-2709"/></para></term><listitem/></varlistentry><varlistentry><term>
              shadow volumes, <para><xref linkend="node-2708"/></para></term><listitem/></varlistentry><varlistentry><term>
              shadows, <para><xref linkend="node-2705"/></para></term><listitem/></varlistentry><varlistentry><term>
              Shape class, <para><xref linkend="node-2857"/></para></term><listitem/></varlistentry><varlistentry><term>
              show-dialog (method), <para><xref linkend="node-2741"/></para></term><listitem/></varlistentry><varlistentry><term>
              simulation archiving, <para><xref linkend="node-2752"/></para></term><listitem/></varlistentry><varlistentry><term>
              simulation dearchiving, <para><xref linkend="node-2752"/></para></term><listitem/></varlistentry><varlistentry><term>
              sin() function, <para><xref linkend="node-2678"/></para></term><listitem/></varlistentry><varlistentry><term>
              snapshots, <para><xref linkend="node-2744"/></para></term><listitem/></varlistentry><varlistentry><term>
              Sound class, <para><xref linkend="node-2715"/></para>, <para><xref linkend="node-2858"/></para></term><listitem/></varlistentry><varlistentry><term>
              sounds, <para><xref linkend="node-2715"/></para></term><listitem/></varlistentry><varlistentry><term>
              space, <para><xref linkend="node-2618"/></para></term><listitem/></varlistentry><varlistentry><term>
              spatial simulation, <para><xref linkend="node-2618"/></para></term><listitem/></varlistentry><varlistentry><term>
              Sphere class, <para><xref linkend="node-2859"/></para></term><listitem/></varlistentry><varlistentry><term>
              Spring class, <para><xref linkend="node-2860"/></para></term><listitem/></varlistentry><varlistentry><term>
              sqrt() function, <para><xref linkend="node-2678"/></para></term><listitem/></varlistentry><varlistentry><term>
              stability, <para><xref linkend="node-2730"/></para></term><listitem/></varlistentry><varlistentry><term>
              Stationary (class), <para><xref linkend="node-2698"/></para></term><listitem/></varlistentry><varlistentry><term>
              Stationary class, <para><xref linkend="node-2861"/></para></term><listitem/></varlistentry><varlistentry><term>
              string (type), <para><xref linkend="node-2663"/></para></term><listitem/></varlistentry><varlistentry><term>
              subclass, <para><xref linkend="node-2638"/></para></term><listitem/></varlistentry><varlistentry><term>
              subexpressions, <para><xref linkend="node-2683"/></para></term><listitem/></varlistentry><varlistentry><term>
              super, <para><xref linkend="node-2674"/></para></term><listitem/></varlistentry></variablelist><variablelist><varlistentry><term>
              tan() function, <para><xref linkend="node-2678"/></para></term><listitem/></varlistentry><varlistentry><term>
              terrain, <para><xref linkend="node-2737"/></para></term><listitem/></varlistentry><varlistentry><term>
              Terrain class, <para><xref linkend="node-2862"/></para></term><listitem/></varlistentry><varlistentry><term>
              Tone class, <para><xref linkend="node-2863"/></para></term><listitem/></varlistentry><varlistentry><term>
              Tracer class, <para><xref linkend="node-2864"/></para></term><listitem/></varlistentry><varlistentry><term>
              transpose() function, <para><xref linkend="node-2678"/></para></term><listitem/></varlistentry><varlistentry><term>
              TurtleDrawing class, <para><xref linkend="node-2865"/></para></term><listitem/></varlistentry><varlistentry><term>
              types, <para><xref linkend="node-2644"/></para></term><listitem/></varlistentry></variablelist><variablelist><varlistentry><term>
              UniversalJoint class, <para><xref linkend="node-2733"/></para>, <para><xref linkend="node-2866"/></para></term><listitem/></varlistentry><varlistentry><term>
              update-neighbors (method), <para><xref linkend="node-2720"/></para></term><listitem/></varlistentry><varlistentry><term>
              use directive, <para><xref linkend="node-2695"/></para></term><listitem/></varlistentry><varlistentry><term>
              user interface, <para><xref linkend="node-2738"/></para></term><listitem/></varlistentry></variablelist><variablelist><varlistentry><term>
              vector (type), <para><xref linkend="node-2654"/></para></term><listitem/></varlistentry><varlistentry><term>
              Vector class, <para><xref linkend="node-2867"/></para></term><listitem/></varlistentry><varlistentry><term>
              vector components, setting and extracting, <para><xref linkend="node-2655"/></para></term><listitem/></varlistentry><varlistentry><term>
              vector operators, <para><xref linkend="node-2655"/></para></term><listitem/></varlistentry><varlistentry><term>
              VectorImage class, <para><xref linkend="node-2868"/></para></term><listitem/></varlistentry><varlistentry><term>
              velocity, <para><xref linkend="node-2701"/></para></term><listitem/></varlistentry></variablelist><variablelist><varlistentry><term>
              Wanderer class, <para><xref linkend="node-2869"/></para></term><listitem/></varlistentry><varlistentry><term>
              WAV sound files, <para><xref linkend="node-2715"/></para></term><listitem/></varlistentry><varlistentry><term>
              web-browser, <para><xref linkend="node-2753"/></para></term><listitem/></varlistentry><varlistentry><term>
              web-server, <para><xref linkend="node-2753"/></para></term><listitem/></varlistentry><varlistentry><term>
              while, <para><xref linkend="node-2687"/></para></term><listitem/></varlistentry><varlistentry><term>
              Windows, <para><xref linkend="node-2626"/></para>, <para><xref linkend="node-2777"/></para></term><listitem/></varlistentry></variablelist><variablelist><varlistentry><term>
              XML files, <para><xref linkend="node-2747"/></para></term><listitem/></varlistentry></variablelist><variablelist><varlistentry><term>
              zoom-tool, <para><xref linkend="node-2622"/></para>, <para><xref linkend="node-2626"/></para></term><listitem/></varlistentry></variablelist>
</chapter>
</book>
