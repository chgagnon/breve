@use Object.
@use Mobile.
@use Shape.
@use Drawing.

@include "isSensorCone.tz"

@define PI 3.141592653.
@define SENSORRANGE 4.	# The range of the IR-Cone
@define SENSORANGLE 60. # The opening angle of the IR-Cone
@define SENSORSIZE 0.3.	# The Size of the sensor Length = 2*Size

Mobile:IRSensor (aka IRSensors){

	+variables:
		sensornumber(int).
		sensordata(float).
		distance(float).
		sensorShape(object).
		sensorCone(object).
		owner(object).
		rel_position(vector).
		rel_rotation(matrix).
		
	+ to set-rel-y-rotation to f(float):
		self set-rel-rotation to [(cos(f),0,-sin(f)),(0,1,0),(sin(f),0,cos(f))].

	+ to set-rel-rotation to m (matrix):	
		rel_rotation = m*[(0,1,0),(-1,0,0),(0,0,1)].
	
	+to set-rel-position to v (vector):
		rel_position = v+(SENSORSIZE,0,0).
	
				
	+to init with-pos position(vector) and-rot rotation(matrix) and-owner o(object) and-number n(int):
		sensornumber = n.
		self set-rel-position to position.
		self set-rel-rotation to rotation.
		owner = o.
		self init2.
				
	+to init2:
		sensorCone = new IRSensorCone.
		sensorCone set-sensor to self.
		sensorCone set-shape to (new Shape init-with-polygon-cone radius SENSORRANGE*sin(SENSORANGLE*PI/180) sides 8 height SENSORRANGE).
		sensorCone set-color to (1,0,0).
		sensorCone set-transparency to 0.3.

		sensorShape = (new Shape init-with-polygon-cone radius SENSORSIZE sides 8 height SENSORSIZE*2).
		self set-shape to sensorShape.
		self set-color to (1,1,0).

		sensorCone handle-collisions with-type "Stationary" with-method "collide".
	#	sensorCone handle-collisions with-type "isAgent" with-method "agent-collide".
		sensordata = 0.
		self update-pos.
		return self.
	
    + to set-owner to o (object):
        owner = o.
	
	+ to	 detect a obstacle(object) at position(vector) facing face(vector):
	    #print "collide3".
	    #print position.
	    #print face.
		distance = |position - (self get-location)|.
		#                         maximum vertical range             maximum distance
		# TODO adjust to real sensoroutput range
		sensordata = (1-  distance/((SENSORRANGE)*sin(SENSORANGLE*PI/180)+(SENSORRANGE + SENSORSIZE*2))).
		#print sensordata.
		#d = new Drawing.
		#d draw-line from (10,10,10) to (position).
	
	+to detect a agent(object):
		owner detect a agent at (sensornumber).
	        
	+to get-data:
		return sensordata.
		
	+to iterate:
		sensordata=0.
		#print "iterate".
		self update-pos.
		
	+to update-pos:
	#print"update-pos".
		# move and rotate the sensor, relative to its owner
		self move to ((owner get-location) +( (owner get-rotation )* rel_position )).
		sensorCone move to ((owner get-location) +( (owner get-rotation )* (rel_position + rel_rotation*(0,SENSORSIZE*2 + SENSORRANGE,0) ))).
		self set-rotation to ((owner get-rotation) * rel_rotation).
		sensorCone set-rotation to ((owner get-rotation) * rel_rotation*[(1,0,0),(0,-1,0),(0,0,1)]).
}