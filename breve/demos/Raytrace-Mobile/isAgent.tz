@use Drawing.

@use Mobile.
@use Matrix.
@include "isSensor.tz"


#          \         /
#           \   1   /
#        0   \     /  2
#             \+=+/ 
# x     -------| |-------
# ^           /+=+\             
# |      5   /     \  3
# |         /   4   \
# |        /         \
# |
# |
# +-------------------> z

Mobile : isAgent  (aka isAgents){
	+ variables:
		shapee        (object).
		sensor_front  (object).
		sensor_left_fr   (object).
		sensor_right_fr  (object).
		hoodSize      (float).
		df, dlf, drf    (float).
		draw            (object).
		irSensors(list).
		
		
	+to init-sensors:
		
		irSensors {0} = (new IRSensor init with-pos( 2, 2,-2) and-rot [(1,0,0),(0,1,0),(0,0,1)]and-owner self and-number 0).
		irSensors {1} = (new IRSensor init with-pos( 2, 2, 0) and-rot [(1,0,0),(0,1,0),(0,0,1)]and-owner self and-number 1).
		irSensors {2} = (new IRSensor init with-pos( 2, 2, 2) and-rot [(1,0,0),(0,1,0),(0,0,1)]and-owner self and-number 2).
		irSensors {3} = (new IRSensor init with-pos(-2, 2, 2) and-rot [(1,0,0),(0,1,0),(0,0,1)]and-owner self and-number 3).
		irSensors {4} = (new IRSensor init with-pos(-2, 2, 0) and-rot [(1,0,0),(0,1,0),(0,0,1)]and-owner self and-number 4).
		irSensors {5} = (new IRSensor init with-pos(-2, 2,-2) and-rot [(1,0,0),(0,1,0),(0,0,1)]and-owner self and-number 5).

		irSensors {0}  set-rel-y-rotation to (300*PI/180).
		irSensors {1}  set-rel-y-rotation to (0*PI/180).
		irSensors {2}  set-rel-y-rotation to (60*PI/180).
		irSensors {3}  set-rel-y-rotation to (120*PI/180).
		irSensors {4}  set-rel-y-rotation to (180*PI/180).
		irSensors {5}  set-rel-y-rotation to (240*PI/180).
		self update-sensor-pos.
		
	+ to update-sensor-pos:
		irSensors {0}  update-pos.
		irSensors {1}  update-pos.
		irSensors {2}  update-pos.
		irSensors {3}  update-pos.
		irSensors {4}  update-pos.
		irSensors {5}  update-pos.
	
	+ to init:
		self init-sensors.
		shapee = (controller get-walker-shape).
		self set-shape to shapee.
		self set-color to (0,1,0.3).
		#self move to random[(100, 0, 100)]+(-50,1.8,-50).
		self move to (5,1.8,5).

		self rotate around-axis (0,1,0) by random[6.2].

		
	

		hoodSize = 30.
		sensor_front    = (new Sensor init-with id 0 direction (1,0, 0) max-distance hoodSize and-owner self).
		sensor_right_fr = (new Sensor init-with id 1 direction (0.5,0, 0.87) max-distance hoodSize and-owner self).
		sensor_left_fr = (new Sensor init-with id 2 direction (0.5,0,-0.87) max-distance hoodSize and-owner self).


		#self set-neighborhood-size to hoodSize.
		
		#self show-neighbor-lines.

		draw = new Drawing.
		draw set-color to (1,0,0) with-transparency 1.0.
		
		return self.
		
	+ to move to pos(vector):
		super move to pos.
		self update-sensor-pos.
				
	+ to detect a agent(object) at sensornumber(int):
		#print " detected a agent $agent at sensor $sensornumber".
		
	+ to receive the message (string) at sensor(int) from emitter(int):
		print"receive".
	
	+ to iterate:
		dlf = (irSensors{0} get-data).
		df  = (irSensors{1} get-data).
		drf = (irSensors{2} get-data).

#		printf "left-f: ".
#		print dlf.
#		printf "front: ".
#		print df.
#		printf "right-f: ".
#		print drf.

		if (df < 0.2): {
		   self set-rotational-velocity to (0, 0, 0).
		   self set-velocity to (self get-rotation)*(1,0,0).		
		
		} else {
		      self set-rotational-velocity to (0, 1, 0).
		      self set-velocity to (0,0,0).		
		}  

}

Abstract : Sensor {
    + variables:
	 direction (vector).
	 owner     (object).
	 maxDist   (float).
	 draw      (object).	 
	 id        (double).
	
    + to init-with id theID (double) direction theDirection (vector) max-distance theMaxDistance (float) and-owner theOwner (object):
         direction = theDirection/|theDirection|.
	 owner     = theOwner.
	 maxDist   = theMaxDistance.
	 id        = theID.
	 draw = new Drawing.
	 return self.

    + to get-data:
	 item (object).
	 world_dir (vector).
	 location  (vector).
	 hit (vector).
	 min (float).
	 mat (matrix).
	 bestHit (vector).

	 min = maxDist + 1.

	 mat = (owner get-rotation).

	 world_dir = mat*direction.
	 location  = (owner get-location).

	 #print (owner get-neighbors).

	 foreach item in (owner get-neighbors) : {		 
		    #item set-color to random[(1,1,1)].
			#print location, world_dir.
	  	 hit = (item raytrace from-location location with-direction world_dir).
		 if ((hit != (0,0,0)) && (|hit| < min)) :  {
		    min = |hit|. 
		    bestHit = hit.
		 }
         }
	 draw clear.
#	 if (min < 20) : {
	          draw draw-line from location to (location + bestHit).
#	 }
	 return (min + (random[7] - 3.5)).

}







































