@use Object.
@use Mobile.
@use Shape.
@use Drawing.
@use Real.

@define PI 3.141592653.
@define PI180 0.017453293.

Real:IRSensor (aka IRSensors){

	+variables:
		m_location(vector).
		m_rotation(matrix).
		sensorType(string).
		sensordata(float).
		owner(object).
		realWorldPointer_owner(pointer).
		draw(object).
		rel_position(vector).
		rel_rotation(matrix).
		communicationThreshold(float).


	+ to set-rel-y-rotation to f(float):
		self set-rel-rotation to [(cos(f),0,-sin(f)),(0,1,0),(sin(f),0,cos(f))].

	+ to set-rel-rotation to m (matrix):
	    rel_rotation = m.
	
	+to set-rel-position to v (vector):
		rel_position = v.
	
				
	+to init-with type t(string) rel-position position(vector) rel-rotation rotation(matrix) owner o(object):
		sensorType = t.
		self set-rel-position to position.
		self set-rel-rotation to rotation.
		owner = o.
		realWorldPointer_owner = o get-realWorldPointer.
		draw = new Drawing.
		sensordata = 0.
		self update-pos.
		communicationThreshold = 30.0.
		return self.
	
    + to set-owner to o (object):
        owner = o.
		
    + to get-owner:
        return owner.

	+ to can-send-ack to agent(object):
		qtest(float). #hier braucht man nicht nochmal ein komplettes raytrace machen
#wenn der hinweg frei ist kann das signal auch zurueck nur distanz und azimut beeinflussen den wert evtl anderer sensor
		qtest = calcQualNoRay(realWorldPointer_owner, (self get-location),
		(self get-rotation) ,(agent get-location) , sensorType).
		if (qtest > communicationThreshold):{
#			print ">!".
			return 1.
		}
#		print "qtest ack to low!", qtest.
		return 0.

	+ to send message message(string):
  		qtest (double).
		agents (list).
		i(object).
		col(int).
		col = random[100].
  		self update-pos.
 		draw clear.
		agents = all testAgent.
		draw set-color to (1,0,0).
		draw draw-line from (self get-location)to (self get-location) + (self get-rotation)*(0,0,27).

		foreach i in agents: {
			if(i!= owner):{
				qtest = calculateQualityToObject(realWorldPointer_owner, (self get-location), (self get-rotation) ,(i get-realWorldPointer) , sensorType).
				draw set-color to (0,0,0).
#				draw draw-line from (self get-location)to (i get-location).
				if (qtest > communicationThreshold):{ #3
#					print "sendquality:",qtest.
					i receiveMessage2 message message from(self get-owner ).

				}
			}
		}


	+ to move to location(vector):
		m_location = location.
	
	+ to get-location:
	  return m_location.

	+ to set-rotation to m(matrix):
	  m_rotation = m.

	+to get-rotation:
	  return m_rotation.
	  
	+to get-sensorType:
	  return sensorType.

	+to get-data:
		self update-pos.
		if (sensordata ==-1 ):{
			draw clear.
			draw set-color to (0.1, 0.1, 0.1).
			draw draw-line from (self get-location)to (self get-location) + (self get-rotation)*(0,0,30).
#
#			print "Raytracer: start sensing...".
			sensordata = irSense(realWorldPointer_owner, (self get-location), (self get-rotation) , sensorType).
#		print realWorldPointer_owner.
#		print (self get-location).
#		print (self get-rotation).
#			print sensordata.
#			print "Raytracer: ...sensing done".
		}
		return sensordata.
		
	+to iterate:
		sensordata = -1.
		#print "iterate".
		self update-pos.
		
	+to update-pos:
		# move and rotate the sensor, relative to its owner
		self move to ((owner get-location) +( (owner get-rotation )* rel_position )).
		self set-rotation to ((owner get-rotation) * rel_rotation).
}
