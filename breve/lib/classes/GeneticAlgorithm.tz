@use Object.

Object : GeneticAlgorithm {
	% The GeneticAlgorithm class allows you to set up a genetic algorithm, 
	% in which strategies can be evolved to solve a wide variety of problems.
	% <P>
	% To run a genetic algorithm, you will need to a create custom subclass
	% of this object, GeneticAlgorithm, and of its companion object 
	% OBJECT(GeneticProgrammingIndividual).
	% <P>
	% Your subclass of GeneticAlgorithm must implement two important methods:	
	% METHOD(start-fitness-test) and METHOD(end-fitness-test).  These methods
	% are automatically called at the beginning and end of the fitness tests	
	% respectively.

	+ variables:
		populations (list).
		testDuration (double).
		tournamentSize (int).
		populationSize (int).
		individualClass (string).
		currentPopulation (int).
		currentIndividual (int).
		crossoverPercent (int).
		mutationPercent (int).
		migrationPercent (int).
		generation (int).

	+ to init:
		testDuration = 20.
		populationSize = 30.
		currentIndividual = 0.
		mutationPercent = 75.
		crossoverPercent = 0.
		tournamentSize = 5.

		populations = { { }, { } }.

	+ section "Getting and Setting Parameters for the Genetic Algorithm"

	+ to set-test-duration to duration (double):
		% Sets the duration of a single fitness test.  Specifies that a single
		% individual should be allowed to run for duration simulated seconds 
		% before assessing its fitness and switching to the next individual.
		% The default value is 20.
		testDuration = duration.

	+ to get-test-duration:
		% Returns the duration of a single fitness test.  This value can be
		% set with the method METHOD(set-test-duration).  The default value
		% is 20.
		return testDuration.

	+ to set-population-size to size (int):
		% Sets the number of individuals in the population to size.
		populationSize = size.

	+ to get-population-size:
		% Returns the size of the population.  The default value is 30, and
		% can be set with METHOD(set-population-size).
		return populationSize.

	+ to set-mutation-percent to percent (int): 
		% Sets the probability of mutation to percent%.  This specifies the 
		% approximate percentage of agents to be generated through mutation.
		% The default value is 75%.
		mutationPercent = percent.

	+ to get-mutation-percent:
		% Returns the percent probability of mutation during reproduction.
		% The default value is 75%.
		return mutationPercent.

	+ to set-crossover-percent to percent (int):
		% Sets the probability of crossover to percent%.  This specifies the 
		% approximate percentage of agents to be generated through crossover
		% during reproduction.  Crossover is not enabled by default, so the 
		% default value is 0%.
		crossoverPercent = percent.

	+ to get-crossover-percent:
		% Returns the probability of crossover during reproduction.
		return crossoverPercent.

	+ to set-tournament-size to tsize (int):
		% Sets the tournament size to tsize.  The tournament size specifies
		% how many individuals are considered in a single selection "tournament".
		% The larger the tournament size, the more competative selection becomes.
		% The default value is 5.  
		tournamentSize = size.

	+ to get-tournament-size:
		% Returns the tournament size.  The tournament size specifies
		% how many individuals are considered in a single selection "tournament".
		% The larger the tournament size, the more competative selection becomes.
		% The tournament size can be set with METHOD(set-tournament-size).
		% The default value is 5.  
		return tournamentSize.

	+ to set-individual-class to className (string):
		% Call this method to specify the class representing an individual in your
		% genetic algorithm.  className must be a string representing a subclass
		% of OBJECT(GeneticAlgorithmIndividual).

		individualClass = className.

	+ to iterate:
		if | populations { 0 } | == 0: self generate-population.

	+ section "Methods Used Internally by the Genetic Algorithm"

	+ to generate-population:
		n (int).

		if populations{ 0 }: free populations{ 0 }.
		if populations{ 1 }: free populations{ 1 }.

		if individualClass == "": die "A GeneticAlgorithmIndividual subclass must be specified using the method \"set-individual-class\"".

		populations = { { }, { } }.

		for n = 0, n < populationSize, n++ : {
			push (controller make-new-instance of-class individualClass) onto populations{ 0 }.
			push (controller make-new-instance of-class individualClass) onto populations{ 1 }.
		}

		currentIndividual = -1.
		self switch-individual.

	+ to get-current-individual:
		% Returns the current GeneticAlgorithmIndividual subclass instance being evaluated.

		if | populations{ currentPopulation } | == 0: self generate-population.

		if currentIndividual == -1: return 0.

		return populations{ currentPopulation }{ currentIndividual }.

	+ to switch-individual: 
		% Switches to the next indivisual

		if currentIndividual != -1: self end-fitness-test of populations{ currentPopulation }{ currentIndividual }.

		currentIndividual++.

		if currentIndividual >= | populations{ currentPopulation } |: {
			self reproduce.
		}

		self start-fitness-test of populations{ currentPopulation }{ currentIndividual }.

		self schedule method-call "switch-individual" at-time (controller get-time) + testDuration.

	+ to reproduce:
		r, i, best (int).

		if | populations{ !currentPopulation } | != populationSize: {
			free populations{ !currentPopulation }.
			populations{ !currentPopulation } = populationSize new individualClass.
		}

		best = 0.

		for i = 1, i < | populations{ currentPopulation } |, i++: {
			if (populations{ currentPopulation }{ i } get-fitness) >
					(populations{ currentPopulation }{ best } get-fitness): best = i.
		}
		
		generation++.

		self report at-generation generation with-best-individual populations{ currentPopulation }{ best }.

		for i = 0, i < populationSize, i++: {
			r = random[100].

			if r < mutationPercent: {
				populations{ !currentPopulation }{ i } copy from (self tournament-select).
				populations{ !currentPopulation }{ i } mutate.
			} else if r < (mutationPercent + crossoverPercent): {
				populations{ !currentPopulation }{ i } crossover 
					from-parent1 (self touranment-select) from-parent2 (self tournament-select).
			} else if r < (mutationPercent + crossoverPercent + migrationPercent): {
			} else {
				populations{ !currentPopulation }{ i } copy from (self tournament-select).
			}
		}

		currentPopulation = !currentPopulation.
		currentIndividual = 0.

		self prepare-for-generation number generation.

	+ to tournament-select:
		% This method performs a tournament selection for reproduction.  It 
		% is used internally and typically not called by any other object.  

		n (int).
		best, test (int).

		best = random[ | populations{ currentPopulation } | - 1 ].

		for n=0, n<(tournamentSize - 1), n++: {
			test = random[ | populations{ currentPopulation } | - 1 ].

			if (populations{ currentPopulation }{ test } get-fitness) > 
					(populations{ currentPopulation }{ best } get-fitness): { 
				best = test.
			}
		}

		return populations{ currentPopulation }{ best }.

	+ section "Methods to Override in Custom Subclasses"

	+ to report at-generation generation (int) with-best-individual bestIndividual (object):
		% Prints out a report of the progress at each generation, with the most 
		% fit object passed in as bestIndividual.  The default implementation of 
		% this method simply prints out the generation number, best fitness and 
		% calls METHOD(examine) on the best individual, but you may override the 
		% method to print out any other desired information.

		print "### Generation $generation, best fitness: ", (bestIndividual get-fitness).
		self examine individual bestIndividual.

	+ to examine individual currentIndividual (object):
		% Called automatically during each generation's report, this method examines
		% and outputs information about an individual in the population.  The default
		% implementation simply prints out the object variable, but you may override 
		% this method to print out more information about the individual.
		print currentIndividual.

	+ to start-fitness-test of individual (object):
		% Implement this method to perform any setup necessary when the 
		% fitness test begins.

	+ to end-fitness-test of individual (object):
		% In this method, you should perform any cleanup neccessary when the 
		% fitness test ends.  You should also make sure that the individual's
		% fitness value is set using 
		% OBJECTMETHOD(GeneticAlgorithmIndividual:set-fitness).

	+ to prepare-for-generation number n (int):
		% This method is called when a generation is setup.  The default
		% implementation does nothing, but the method may be overriden
		% in order to carry out any preparations necessary for a new 
		% generation.
}

Object : GeneticAlgorithmIndividual {
	% This object represents a single individual in a OBJECT(GeneticAlgorithm).
	% To use the class OBJECT(GeneticAlgorithm), you must also implement a 
	% custom subclass of this class.  Your custom subclass should contain the
	% variables which will represent the genes for the genetic algorithm, and
	% must also implement a few methods used for genetic operators.
	% <P>
	% At a very minimum, you must implement your own versions of the methods
	% METHOD(compute-fitness), METHOD(copy) and METHOD(mutate).  If you intend 
	% to use the crossover 
	% genetic operator, you must also implement the method METHOD(crossover).
	% If these methods are not implemented by your subclass, the object will
	% trigger a runtime error.

	+ variables:
		fitness (double).

	+ to get-fitness:
		return fitness.

	+ to set-fitness to fitnessValue (double):
		fitness = fitnessValue.

	+ section "Methods to Override in Custom Subclasses"

	+ to copy from otherIndividual (object):
		% Implement this method to copy the genes from otherIndividual.  This method
		% must be implemented by your subclass.

		die "The method \"copy\" must be implemented in your GeneticAlgorithmIndividual subclass!".

	+ to mutate:
		% Implement this method to mutate the genes of this object.  This method
		% must be implemented by your subclass.

		die "The method \"mutate\" must be implemented in your GeneticAlgorithmIndividual subclass!".

	+ to crossover from-parent1 parent1 (object) from-parent2 parent2 (object):
		% Implement this method to make this object become a crossover of parent1 
		% and parent2.  This method must be implemented by your subclass if 
		% crossover is enabled.

		die "The method \"crossover\" must be implemented in your GeneticAlgorithmIndividual subclass!".
}
