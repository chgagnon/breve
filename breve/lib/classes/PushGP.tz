@use Push.
@use Control.
@use NetworkServer.

Object : PushGP {
	% This class is a special control class used to implement 
	% experiments using the Push Genetic Programming (PushGP)
	% system.  PushGP is a system which uses genetic programming
	% and the Push programming language to attempt to evolve 
	% solutions to a wide variety of problems.  For more 
	% information on Push and PushGP, see the class OBJECT(PushInterpreter).
	% <p>
	% This class is appropriate for evolving Push programs which
	% are only run once per fitness case.
	% <p>
	% To implement a PushGP experiment you will need to setup
	% a PushGP object which overrides two methods:
	% METHOD(setup-fitness-test), which sets up a fitness test
	% and METHOD(compute-error), which is used to compute the 
	% fitness of an individual.
	% <p>
	% Additionally, other methods in this class are useful for
	% configuring the genetic programming environment and a 
	% variety of parameters including population size, 
	% mutation rate, crossover rate, and the Push language 	
	% interpreter set.
	% <p>
	% Finally, you may also wish to add custom instructions 
	% to the Push interpreter objects which manipulate data
	% or trigger actions in the simulated world.  The Push
	% interpreter can be retrieved using the method 
	% METHOD(get-interpreter), and adding instructions is 
	% documented in OBJECT(PushInterpreter).

	+ variables:
		interpreter (object).
		pop1, pop2 (list).
		current, next (list).

		bestOfGen (object).
		totalSize (int).

		generation (int).
		input (float).

		inited (int).

		crossoverPercent, mutationPercent (float).
		tournamentSize (int).
		populationSize (int).
		currentIndividual (int).
		generationLimit (int).

  + section "Setting and Retrieving GP Parameters"

	+ to set-generation-limit to n (int):
		% Sets the generation limit to n.  If no solution is found by
		% the generation limit, the simulation with terminate.  The 
		% default value is 300.
		generationLimit = n.

	+ to get-generation-limit:
		% Returns the generation limit.  See METHOD(set-generation-limit)
		% for more information.
		return generationLimit.

	+ to set-tournament-size to n (int):
		% Sets the tournament size to n.  The tournament size determines 
		% how many individuals are examined during tournament selection.
		% The default value is 7.
		tournamentSize = n.

	+ to get-tournament-size: 
		% Returns the tournament size.  See METHOD(set-tournament-size)
		% for more information.
		return tournamentSize.

	+ to set-population-size to n (int):
		% Sets the population size to n and reinitializes the population.
		% The default value is 2000.
		populationSize = n.
		inited = 0.

	+ to get-population-size: 
		% Returns the population size.  See METHOD(set-population-size) for
		% more information.
		return populationSize.

	+ to set-crossover-percent to n (int):
		% Sets the percentage of agents generated by genetic crossover at 
		% each generation.  This should be a value between 0 and 100.  
		% The default value is 40.
		crossoverPercent = n.

	+ to get-crossover-percent:
		% Returns the crossover percent.  See METHOD(set-crossover-percent)
		% for more information.
		return crossoverPercent.

	+ to set-mutation-percent to n (int):
		% Sets the percentage of agents generated by genetic mutation at 
		% each generation.  This should be a value between 0 and 100.  
		% The default value is 40.
		mutationPercent = n.

	+ to get-mutation-percent:
		% Returns the mutation percent.  See METHOD(set-mutation-percent)
		% for more information.
		return mutationPercent.

	+ to read-interpreter-config from-file file (string):
		% Reads a configuration file for the interpreter used in the  
		% fitness tests.  Changing the configuration also reinitializes
		% the evolving population (since instructions sets may be changed).

		interpreter read-config from-file file.
		inited = 0.

	+ to init:
		populationSize = 2000.
		mutationPercent = 40.
		crossoverPercent = 40.
		tournamentSize = 7.
		generationLimit = 300.

		interpreter = new PushInterpreter.

	- to create-population:
		if pop1: free pop1.
		if pop2: free pop2.

		pop1 = populationSize new Individuals.
		pop2 = populationSize new Individuals.

		pop1 set-interpreter to interpreter.
		pop2 set-interpreter to interpreter.

		current = pop1.
		next = pop2.

		inited = 1.

	+ section "Getting the Push Interpreter Used During Evolution"

	+ to get-interpreter: 
		% Returns the OBJECT(PushInterpreter) object that this object is 
		% using for fitness tests.

		return interpreter.

	- to swap-current:
		% Used internally.
		if current == pop1: {
			current = pop2.
			next = pop1.
		} else {
			current = pop1.
			next = pop2.
		}

	- to run-tournament:
		% Used internally.

		n, test (int).
		best (object).

		best = current{ random[populationSize - 1] }.

		for n = 0, n < tournamentSize - 1, n++: {
			test = random[populationSize - 1].

			if (current{test} get-fitness) < (best get-fitness): best = current{test}.
		}

		return best.

	+ to auto-simplify program p (object):
		% Programs generated through genetic programming are often complicated and 
		% difficult to understand.  This method attempts to simplify an evolved  
		% push program while maintaining the same fitness.
		% <P>
		% Each time this method is invoked, a random simplification is preformed 
		% on the program p.  If the simplification does not harm the fitness, p
		% is modified to contain the simplification, otherwise, nothing happens.
		% This method should be called repeatedly -- perhaps 100 times or more 
		% to aggressively simplify an unweildy program.

		fitness, newFitness (float).
		newProgram (object).
		n (int).

		fitness = (self compute-fitness for-program p).

		newProgram = new PushProgram.

		newProgram copy-from program p.

		if random[1]: newProgram delete-random-subtree.
		else newProgram flatten-random-subtree.

		newFitness = (self compute-fitness for-program newProgram).	

		if newFitness == fitness: p copy-from program newProgram.

		free newProgram.

		return p.

	+ to iterate:
		n (int).
		percent (int).

		if !inited: self create-population.

		for n=0,n<100,n++: self evaluate.

		percent = (100.0 * currentIndividual / populationSize).

		controller set-display-message with-number 0 at-x -0.9 at-y -0.8 to "Generation $generation: $percent% Complete".

		# if we're breeding in the next timestep, we'll set the message now...

		if currentIndividual >= (populationSize - 100): 
			controller set-display-message with-number 0 at-x -0.9 at-y -0.8 to "Generation $generation: breeding".

	- to evaluate:
		fitness (float).
		n (int).

		fitness = (self compute-fitness for-program current{ currentIndividual }).
		
		if fitness < 0.0: {
			# this indicates an error -- give it an arbitrarily bad fitness
			print "warning: error value lower than 0 for GP individual".
			fitness = 100000000.
		}

		if fitness < 0.001: {
			print ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;".
			print ";; Solution found at generation $generation:", 
					(current{ currentIndividual }  get-string).

			for n=0,n<1000,n++: {
				self auto-simplify program current{ currentIndividual }.
			}

			print ";; Simplifies to:", (current{ currentIndividual }  get-string).

			controller end-simulation.
		}

		if !bestOfGen || (fitness < (bestOfGen get-fitness)): bestOfGen = current{ currentIndividual }.

		totalSize += (current{ currentIndividual } get-size).

		current{ currentIndividual } set-fitness to fitness.

		currentIndividual++.

		if currentIndividual == populationSize: {
			self reproduce.
			self report.
			self swap-current.
			currentIndividual = 0.
			generation++.
			bestOfGen = 0.
			totalSize = 0.

			if generation > generationLimit: {
				print ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;".
				print ";; FAILURE: no solution found after $generation generations".
				controller end-simulation.
			}
		}

	- to compute-fitness for-program p (object):
		n, invalid (int).
		errors (list).

		for n=0, n < (self count-fitness-cases), n++: {
			interpreter clear-stacks.

			self setup-fitness-test for-fitness-case n 
				with-interpreter interpreter.

			if (interpreter run code p): {
				# score for invalid programs.
				return 100000000.
			} else {
				push (self compute-error for-fitness-case n with-interpreter interpreter) onto errors.
			}
		}

		return (self compute-error-vector-fitness for-errors errors).

	+ to compute-error-vector-fitness for-errors errorList (list):
		fitness, value (double).

		# return stddev( errorList ).
		
		foreach value in errorList: fitness += | value |.

		return fitness.

	+ section "Methods Overridden by the User To Set Up PushGP Experiments"

	+ to setup-fitness-test for-fitness-case n (int) 
		with-interpreter interpreter (object):

		% This method must be overridden by the user in order to run a 
		% PushGP experiment.  The job of this method is to prepare to run 
		% the specified fitness test.  This typically means pushing input 
		% values onto the OBJECT(PushInterpreter) object's stacks.
		% <p>
		% In a symbolic regression problem, for example, this method might 
		% push a predetermined input value onto the float stack.
		% <pre>
		% 	interpreter push-float value inputValues{ n }.
		% </pre>

		die "The method setup-fitness-test must be overridden by the user -- see the class documentation for PushGPControl for more information".
	
	+ to compute-error for-fitness-case n (int) 
		with-interpreter interpreter (object):

		% This method must be overridden by the user in order to run a 
		% PushGP experiment.  The job of this method is to inspect the 
		% state of the OBJECT(PushInterpreter) object and determine
		% the fitness (in terms of error) of the specified fitness case.  
		% This typically involves comparing values from the interpreter's 
		% stacks against desired values.
		% <p>
		% For example, with a symbolic regression problem, this method 
		% might return the difference between the top of the float stack, 
		% and the predetermined "correct" answer for the specified fitness 
		% case.  For example:
		% <pre>
		% 	return (interpreter get-float-stack-top) - desiredOutputs{ n }.
		% </pre>

		die "The method compute-fitness must be overridden by the user -- see the class documentation for PushGPControl for more information".

	+ to report:
		% Logs information to the output at every generation.  This method 
		% may be overridden to provide more (or less) output data.

		n, size (int).
		bestFitness (float).

		totalSize /= populationSize.

		bestFitness = (bestOfGen get-fitness).

		print ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;".
		print ";; Generation: $generation".
		print ";; Average program size: $totalSize".
		print ";; Best error: $bestFitness".
		print ";; Best Individual: ", (bestOfGen get-string).
		print "".

		controller set-display-message with-number 2 at-x -0.9 at-y -0.9 to "Best Fitness: $bestFitness".

	- to reproduce:
		% Used internally.

		n (int).
		p1, p2 (object).

		while n < (mutationPercent / 100.0) * populationSize: {
			p1 = (self run-tournament).
			next{n} copy-from program p1.
			next{n} mutate with-max-new-code-size 10 with-interpreter interpreter.

			n++.
		}

		while n < ((crossoverPercent + mutationPercent) / 100.0) * populationSize: {
			p1 = (self run-tournament).
			p2 = (self run-tournament).
			next{n} crossover from-parent1 p1 from-parent2 p2.
			n++.
		}

		while n < populationSize: {
			p1 = (self run-tournament).
			next{n} copy-from program p1.
			n++.
		}
}

PushProgram : Individual (aka Individuals) {
	% A class used by OBJECT(PushGP), this is a single individual
	% in a PushGP run.  It is not typically used directly by the user.

	+ variables:
		interpreter (object).
		fitness (double).

	- to set-interpreter to newInterpreter (object):
		interpreter = newInterpreter.
		self make-random-code with-interpreter interpreter.

	+ to set-fitness to newFitness (double):
		% Sets the fitness of this object to newFitness.  You 
		% shouldn't call this method unless you're implementing
		% your own GP system.

		fitness = newFitness.

	+ to get-fitness: 
		% Returns the fitness of this GP individual.

		return fitness.
}

@define PUSHGP_SERVER_PORT		59175.

PushGP : PushClusterGP {
	+ variables:
		emmigrationHosts (list).
		emmigrationPercent (float).
		transfer (object).
		server (object).

	+ to init:
		server = new NetworkServer.
		server listen on-port PUSHGP_SERVER_PORT.
		server set-upload-recipient to self.
		emmigrationPercent = 10.

		transfer = new PushProgramTransporter.

	+ to accept-upload of immigrants (object) from h (string):
		print "Got $immigrants".
		free immigrants.

	+ to set-emmigration-percent to n (int):
		% Sets the percentage of agents generated by genetic emmigration at 
		% each generation.  This should be a value between 0 and 100.  
		% The default value is 40.
		emmigrationPercent = n.

	+ to get-emmigration-percent:
		% Returns the emmigration percent.  See METHOD(set-emmigration-percent)
		% for more information.
		return emmigrationPercent.

	+ to set-emmigration-hosts to hosts (list):
		emmigrationHosts = copylist hosts.

	+ to reproduce: 
		recipientHost (string).
		n (int).

		super reproduce.

		transfer clear.

		if | emmigrationHosts | == 0: return.

		for n=0, n<populationSize * (emmigrationPercent / 100.0), n++: transfer add program (self run-tournament).

		recipientHost = emmigrationHosts{ random[ | emmigrationHosts | - 1 ] }.
		transfer send-over-network to recipientHost on PUSHGP_SERVER_PORT.
}

Object : PushProgramTransporter {
	% Used by OBJECT(PushClusterGP).

	+ variables:
		programStrings (list).

	+ to add program p (object):
		push (p get-string) onto programStrings.

	+ to clear:
		programStrings = { }.

	+ to parse-programs with-interpreter i (object):
		code (string).
		program (object).
		result (list).

		for each code in programStrings: {
			program = new PushProgram.
			program parse program code.
			push program onto result.
		}

		return result.
}
