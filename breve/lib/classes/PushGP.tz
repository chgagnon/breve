@use Push.
@use Control.
@use NetworkServer.

Object : PushGP {
	% This class is a special control class used to implement 
	% experiments using the Push Genetic Programming (PushGP)
	% system.  PushGP is a system which uses genetic programming
	% and the Push programming language to attempt to evolve 
	% solutions to a wide variety of problems.  For more 
	% information on Push and PushGP, see the class OBJECT(PushInterpreter).
	% <p>
	% This class is appropriate for evolving Push programs which
	% are only run once per fitness case.
	% <p>
	% To implement a PushGP experiment you will need to setup
	% a PushGP object which overrides two methods:
	% METHOD(setup-fitness-test), which sets up a fitness test
	% and METHOD(compute-error), which is used to compute the 
	% fitness of an individual.
	% <p>
	% Additionally, other methods in this class are useful for
	% configuring the genetic programming environment and a 
	% variety of parameters including population size, 
	% mutation rate, crossover rate, and the Push language 	
	% interpreter set.
	% <p>
	% Finally, you may also wish to add custom instructions 
	% to the Push interpreter objects which manipulate data
	% or trigger actions in the simulated world.  The Push
	% interpreter can be retrieved using the method 
	% METHOD(get-interpreter), and adding instructions is 
	% documented in OBJECT(PushInterpreter).

	+ variables:
		interpreter (object).
		pop1, pop2 (list).
		current, next (list).

		bestOfGen (object).
		totalSize (int).
		totalErrors (double).

		generation (int).

		inited (int).

		crossoverPercent, mutationPercent (float).
		tournamentSize (int).
		populationSize (int).
		currentIndividual (int).
		generationLimit (int).

		seed (string).

  + section "Setting and Retrieving GP Parameters"

	+ to seed-population with-program pushProgram (object):
		% Uses pushProgram to seed the initial population.
		seed = (pushProgram get-string).

	+ to set-generation-limit to n (int):
		% Sets the generation limit to n.  If no solution is found by
		% the generation limit, the simulation with terminate.  The 
		% default value is 300.
		generationLimit = n.

	+ to get-generation-limit:
		% Returns the generation limit.  See METHOD(set-generation-limit)
		% for more information.
		return generationLimit.

	+ to set-tournament-size to n (int):
		% Sets the tournament size to n.  The tournament size determines 
		% how many individuals are examined during tournament selection.
		% The default value is 7.
		tournamentSize = n.

	+ to get-tournament-size: 
		% Returns the tournament size.  See METHOD(set-tournament-size)
		% for more information.
		return tournamentSize.

	+ to set-population-size to n (int):
		% Sets the population size to n and reinitializes the population.
		% The default value is 2000.
		populationSize = n.
		inited = 0.

	+ to get-population-size: 
		% Returns the population size.  See METHOD(set-population-size) for
		% more information.
		return populationSize.

	+ to set-crossover-percent to n (int):
		% Sets the percentage of agents generated by genetic crossover at 
		% each generation.  This should be a value between 0 and 100.  
		% The default value is 40.
		crossoverPercent = n.

	+ to get-crossover-percent:
		% Returns the crossover percent.  See METHOD(set-crossover-percent)
		% for more information.
		return crossoverPercent.

	+ to set-mutation-percent to n (int):
		% Sets the percentage of agents generated by genetic mutation at 
		% each generation.  This should be a value between 0 and 100.  
		% The default value is 40.
		mutationPercent = n.

	+ to get-mutation-percent:
		% Returns the mutation percent.  See METHOD(set-mutation-percent)
		% for more information.
		return mutationPercent.

	+ to read-interpreter-config from-file file (string):
		% Reads a configuration file for the interpreter used in the  
		% fitness tests.  Changing the configuration also reinitializes
		% the evolving population (since instructions sets may be changed).

		interpreter read-config from-file file.
		inited = 0.

	+ to init:
		populationSize = 2000.
		mutationPercent = 40.
		crossoverPercent = 40.
		tournamentSize = 7.
		generationLimit = 300.

		interpreter = new PushInterpreter.

	- to create-population:
		if pop1: free pop1.
		if pop2: free pop2.

		pop1 = populationSize new PushGPIndividuals.
		pop2 = populationSize new PushGPIndividuals.

		pop1 set-interpreter to interpreter.
		pop2 set-interpreter to interpreter.

		current = pop1.
		next = pop2.

		if seed: (pop1{0} parse program seed).

		inited = 1.

	+ section "Getting the Push Interpreter Used During Evolution"

	+ to get-interpreter: 
		% Returns the OBJECT(PushInterpreter) object that this object is 
		% using for fitness tests.

		return interpreter.

	- to swap-current:
		% Used internally.
		if current == pop1: {
			current = pop2.
			next = pop1.
		} else {
			current = pop1.
			next = pop2.
		}

	+ to run-tournament:
		% Runs a tournament selection from the population.  Used internally during
		% reproduction uses the tournament size set with 
		% METHOD(set-tournament-size).
		% <P>
		% This method may be overridden to implement a custom tournament selection
		% if desired, though the default implementation should suffice in most 
		% situations.

		n, test (int).
		best (object).

		best = current{ random[populationSize - 1] }.

		for n = 0, n < tournamentSize - 1, n++: {
			test = random[populationSize - 1].

			if (current{test} get-fitness) < (best get-fitness): best = current{test}.
		}

		return best.

	+ to auto-simplify program p (object):
		% Programs generated through genetic programming are often complicated and 
		% difficult to understand.  This method attempts to simplify an evolved  
		% push program while maintaining the same fitness.
		% <P>
		% Each time this method is invoked, a random simplification is preformed 
		% on the program p.  If the simplification does not harm the fitness, p
		% is modified to contain the simplification, otherwise, nothing happens.
		% This method should be called repeatedly -- perhaps 100 times or more 
		% to aggressively simplify an unweildy program.

		fitness, newFitness (float).
		newProgram (object).

		fitness = (self compute-fitness for-program p).

		newProgram = new PushGPIndividual.

		newProgram copy-from program p.

		if random[1]: newProgram delete-random-subtree.
		else newProgram flatten-random-subtree.

		newFitness = (self compute-fitness for-program newProgram).	

		if newFitness == fitness: p copy-from program newProgram.

		free newProgram.

		return p.

	+ to iterate:
		n (int).
		percent (int).

		if !inited: self create-population.

		for n=0,n<100,n++: self evaluate.

		percent = (100.0 * currentIndividual / populationSize).

		controller set-display-message with-number 0 at-x -0.9 at-y -0.8 to "Generation $generation: $percent% Complete".

		# if we're breeding in the next timestep, we'll set the message now...

		if currentIndividual >= (populationSize - 100): 
			controller set-display-message with-number 0 at-x -0.9 at-y -0.8 to "Generation $generation: breeding".

	- to evaluate:
		fitness (float).
		n (int).

		fitness = (self compute-fitness for-program current{ currentIndividual }).
		
		if fitness < 0.0: {
			# this indicates an error -- give it an arbitrarily bad fitness
			print "warning: error value lower than 0 for GP individual".
			fitness = 100000000.
		}

		if fitness < 0.001: {
			print ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;".
			print ";; Solution found at generation $generation:", 
					(current{ currentIndividual }  get-string).

			self examine program current{ currentIndividual }.

			controller end-simulation.
		}

		if !bestOfGen || (fitness < (bestOfGen get-fitness)): bestOfGen = current{ currentIndividual }.

		totalSize += (current{ currentIndividual } get-size).
		totalErrors += fitness.

		current{ currentIndividual } set-fitness to fitness.

		currentIndividual++.

		if currentIndividual == populationSize: {
			self reproduce.
			self report with-best bestOfGen.
			self swap-current.
			currentIndividual = 0.
			generation++.
			bestOfGen = 0.
			totalSize = 0.
			totalErrors = 0.

			if generation > generationLimit: {
				print ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;".
				print ";; FAILURE: no solution found after $generation generations".
				controller end-simulation.
			}
		}

	- to compute-fitness for-program p (object):
		n (int).
		errors (list).

		for n=0, n < (self count-fitness-cases), n++: {
			interpreter clear-stacks.

			self setup-fitness-test for-fitness-case n 
				with-interpreter interpreter.

			if (interpreter run code p): {
				# score for invalid programs.
				# return 100000000.
				push .1 + (self compute-error for-fitness-case n with-interpreter interpreter) onto errors.
			} else {
				push (self compute-error for-fitness-case n with-interpreter interpreter) onto errors.
			}
		}

		p set-errors to errors.

		return (self compute-error-vector-fitness for-errors errors).

	+ section "Methods Overridden by the User To Set Up PushGP Experiments"

	+ to examine program p (object):
		% This method is called when a solution is found.  You should override 
		% this method to preform any additional analysis you'd like.  Typically
		% this involves examining the program for generalization.
		% <P>
		% The default implementation simplifies the program p for 1000 iteration
		% using METHOD(auto-simplify) and prints out the result.
	
		n (int).

		for n=0,n<1000,n++: self auto-simplify program p.

		print ";; Simplifies to:", (current{ currentIndividual }  get-string).

	+ to compute-error-vector-fitness for-errors errorList (list):
		% This method takes a list of errors returned by METHOD(compute-error) for all 
		% fitness cases, and produces a fitness value.  The default implementation of 
		% this method computes the fitness by summing the absolute values of the errors,
		% which should suffice for most applications.
		% <P>
		% Overriding this method is optional.

		fitness, value (double).

		foreach value in errorList: fitness += | value |.

		return fitness.

	+ to setup-fitness-test for-fitness-case n (int) 
		with-interpreter interpreter (object):

		% This method must be overridden by the user in order to run a 
		% PushGP experiment.  The job of this method is to prepare to run 
		% the specified fitness test.  This typically means pushing input 
		% values onto the OBJECT(PushInterpreter) object's stacks.
		% <p>
		% In a symbolic regression problem, for example, this method might 
		% push a predetermined input value onto the float stack.
		% <pre>
		% 	interpreter push-float value inputValues{ n }.
		% </pre>

		die "The method setup-fitness-test must be overridden by the user -- see the class documentation for PushGPControl for more information".

	+ to count-fitness-cases:
		% This method must be overriden by the user in order to run a
		% PushGP experiment.  This method should return the number of 
		% fitness cases to be run.

		die "The method count-fitness-cases must be overridden by the user -- see the class documentation for PushGPControl for more information".
	
	+ to compute-error for-fitness-case n (int) 
		with-interpreter interpreter (object):

		% This method must be overridden by the user in order to run a 
		% PushGP experiment.  The job of this method is to inspect the 
		% state of the OBJECT(PushInterpreter) object and determine
		% the fitness (in terms of error) of the specified fitness case.  
		% This typically involves comparing values from the interpreter's 
		% stacks against desired values.
		% <p>
		% For example, with a symbolic regression problem, this method 
		% might return the difference between the top of the float stack, 
		% and the predetermined "correct" answer for the specified fitness 
		% case.  For example:
		% <pre>
		% 	return (interpreter get-float-stack-top) - desiredOutputs{ n }.
		% </pre>

		die "The method compute-fitness must be overridden by the user -- see the class documentation for PushGPControl for more information".

	+ to report with-best bestIndividual (object):
		% Logs information to the output at every generation.  This method 
		% may be overridden to provide more (or less) output data.  
		% <P>
		% The argument bestIndividual is the best individual in the population
		% and is provided so that it may be inspected by the user if this method
		% is overridden.

		bestFitness (float).
		errors (list).

		totalSize /= populationSize.
		totalErrors /= populationSize.

		bestFitness = (bestIndividual get-fitness).
		errors = (bestIndividual get-errors).

		print ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;".
		print ";; -*- Report at generation $generation".
		print ";; Best Individual: ".
		print (bestIndividual get-string).
		print ";; Errors for best individual: ", errors.
		print ";; Total errors for best individual: $bestFitness".
		print ";; Size of best individual (points):", (bestIndividual get-size).
		print ";;".
		print ";; Average total errors in population: $totalErrors".
		print ";; Average program size in population (points): $totalSize".
		print "".

		controller set-display-message with-number 2 at-x -0.9 at-y -0.9 to "Best Fitness: $bestFitness".

	- to reproduce:
		% Used internally.

		n (int).
		p1, p2 (object).

		while n < (mutationPercent / 100.0) * populationSize: {
			p1 = (self run-tournament).
			next{n} copy-from program p1.
			next{n} mutate with-max-new-code-size 10 with-interpreter interpreter.

			n++.
		}

		while n < ((crossoverPercent + mutationPercent) / 100.0) * populationSize: {
			p1 = (self run-tournament).
			p2 = (self run-tournament).
			next{n} crossover from-parent1 p1 from-parent2 p2 with-interpreter interpreter.
			n++.
		}

		while n < populationSize: {
			p1 = (self run-tournament).
			next{n} copy-from program p1.
			n++.
		}
}

PushProgram : PushGPIndividual (aka PushGPIndividuals) {
	% A class used by OBJECT(PushGP), this is a single individual
	% in a PushGP run.  It is not typically used directly by the user.

	+ variables:
		interpreter (object).
		fitness (double).
		errors (list).

	- to set-interpreter to newInterpreter (object):
		interpreter = newInterpreter.
		self make-random-code with-interpreter interpreter.

	- to set-errors to errorList (list):
		errors = errorList.

	+ to get-errors:
		% Returns the current list of errors for an individual as determined
		% by the fitness test.
		return errors.

	+ to set-fitness to newFitness (double):
		% Sets the fitness of this object to newFitness.  You 
		% shouldn't call this method unless you're implementing
		% your own GP system.

		fitness = newFitness.

	+ to get-fitness: 
		% Returns the fitness of this GP individual.

		return fitness.
}

@define PUSHGP_SERVER_PORT		59175.

PushGP : PushClusterGP {
	% PushClusterGP is a version of OBJECT(PushGP) that allows individual
	% programs in a genetic programming run to migrate to runs on other 
	% networked machines.  
	% <P>
	% Turning a single machine PushGP experiment to a multiple machine 
	% PushClusterGP experiment is simple.  Just provide a list of the 
	% hosts running the simulation to METHOD(set-emigration-hosts).
	% <P>
	% Note: using the PushClusterGP object will open a tcp server on 
	% port 59175.

	+ variables:
		emigrationHosts (list).
		emigrationPercent (float).
		transfer (object).
		server (object).
		lastTransfer (object).
		port (int).

	+ to init:
		server = new NetworkServer.
		server listen on-port PUSHGP_SERVER_PORT.
		server set-upload-recipient to self.
		emigrationPercent = 3.

		transfer = new PushProgramTransporter.

		port = PUSHGP_SERVER_PORT.

	- to accept-upload of immigrants (object) from h (string):
		free lastTransfer.
		lastTransfer = immigrants.

	+ to set-emigration-percent to n (int):
		% Sets the percentage of agents generated by genetic emigration at 
		% each generation.  This should be a value between 0 and 100, but 
		% should typically be relatively low: mutation and crossover should
		% be the primary genetic operators.
		% The default value is 3.

		emigrationPercent = n.

	+ to get-emigration-percent:
		% Returns the emigration percent.  See METHOD(set-emigration-percent)
		% for more information.

		return emigrationPercent.

	+ to set-emigration-hosts to hosts (list):
		% Sets the PushClusterGP object to send individual programs to 
		% hosts.

		emigrationHosts = copylist hosts.

	- to reproduce: 
		recipientHost (string).
		n (int).
		p1, p2 (object).
		index (int).

		while n < (mutationPercent / 100.0) * populationSize: {
			p1 = (self run-tournament).
			next{n} copy-from program p1.
			next{n} mutate with-max-new-code-size 10 with-interpreter interpreter.

			n++.
		}

		while n < ((crossoverPercent + mutationPercent) / 100.0) * populationSize: {
			p1 = (self run-tournament).
			p2 = (self run-tournament).
			next{n} crossover from-parent1 p1 from-parent2 p2.
			n++.
		}

		while n < ((crossoverPercent + mutationPercent + emigrationPercent) / 100.0) * populationSize: {
			if lastTransfer: p1 = (lastTransfer get-program number index).
			else p1 = (self run-tournament).

			next{n} copy-from program p1.
			index++.
			n++.
		}

		while n < populationSize: {
			p1 = (self run-tournament).
			next{n} copy-from program p1.
			n++.
		}

		transfer clear.

		if | emigrationHosts | == 0: return.

		for n=0, n<populationSize * (emigrationPercent / 100.0), n++: transfer add program (self run-tournament).

		recipientHost = emigrationHosts{ random[ | emigrationHosts | - 1 ] }.
		transfer send-over-network to recipientHost on PUSHGP_SERVER_PORT.
}

Object : PushProgramTransporter {
	% Used by OBJECT(PushClusterGP) to send Push programs over the network.
	% No user-level methods are provided for this class.

	+ variables:
		programStrings (list).

	- to add program p (object):
		push (p get-string) onto programStrings.

	- to clear:
		programStrings = { }.

	- to parse-programs with-interpreter i (object):
		code (string).
		program (object).
		result (list).

		for each code in programStrings: {
			program = new PushProgram.
			program parse program code.
			push program onto result.
		}

		return result.

	- to get-program number n (int): 
		code (object).
		code = new PushProgram.

		if n > | programStrings |: return code.
		code parse program programStrings{ n }.
		return code.
}
